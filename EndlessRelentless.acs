/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM//	This code is required to be compiled as a BEHAVIOR lump of TITLEMAP
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	#include "zcommon.acs" #include "zdaemon.acs"
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	#libdefine PBslots 5 #libdefine MBslots 10	#libdefine None 0
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	#libdefine ZDaemon 1 #libdefine Zandronum 2 #libdefine GZDoom 3
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		1:	ServerInfo[];
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		2:	WinnerNames[];
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		3:	LegendNames[];
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		4:	MoneyInfo[];
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		5:	MoneyNAME[];
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		6:	FlagInfo[];
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/	global	int		7:	FlagCost[];
/*MMMMMMMMMMM Z MMMNhhhhhhhhhhhhhhhhhhhhhmMNhhhhhhhhhhhhhhhhhhhhhhhhhmMmhhhhhhhhhhhhhhhhhhhNMdhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhmMMmhhhhhhhhhhhhhhhMMhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhNMdhhhhhhhhhhhhhhhhhhhhhNMmhhhhhhhhhhhhhhhhhhhhhhNMMMMMMM*/	global	int		8:	MemoOwner[];
/*MMMMMMMMMMMMMMMMMo                     yMy               .o/       +M+                   mN`                                   `+mm+.            `Nm                         -oo-            dM.                    `dM-                     .NMMMMMMM*/	global	int		9:	MemoOwnerMSG[];
/*MMMMMMMMMM E MMMM.                    `NM:               -My       +M+                   mN`                                     .omd+`          `Nm                       -ymh:             dM`                    -Md                      oMMMMMMMM*/	str BlockAt[PBslots][PBslots] = {{"X"}};
/*MMMMMMMMMMMMMMMNh                     /Mm                -My       +M+                   mN`                                       .omd/`        `Nm                     .smh:               dM`                    yM/                     `mMMMMMMMM*/
/*MMMMMMMMM B MMMMo............`        hMo     .........../My       +M+       `...........mN-...........................              .omd/       `Nm        ...........-smh:     `...........dM`       ............-NN`        L A          /MMMMMMMMM*/
/*MMMMMMMMMMMMMMNNddddddddddddd-       .MM.    `hddddddddddmMy       +M+       odddddddddddNMddddddddmNNddddddddddmNmddNNs.              .mN`      `Nm       .dddddddddddmMs       +dddddddddddNM`      `hdddddddddddNMo                      hMMMMMMMMM*/
/*MMMMMMMM E MMMMs                     oMd                 :My       +M+                   mN`       -yNh-`       :Ms  :hNNs.             dM`      `Nm                   +M+                   dM`                  `mN.                     .MMMMMMMMMM*/
/*MMMMMMMMMMMMMdM-                     mM/                 -My       +M+                   mN`         -yNo       :Ms    :hMNs.           dM`      `Nm                   /M+                   dM`                  :Mh                      sMMMMMMMMMM*/
/*MMMMMMM R MMMMm                     :MN`                 -My       +M+                   mN`           -+       :Ms      :hMNs.         dM`      `Nm                   /M+                   dM`                  hM:                     `NMMMMMMMMMM*/
/*MMMMMMMMMMMMyMo                   ..yMs       .........../My       +M+       `...........mN`                    :Ms        :dMNs`       dM`      `Nm        ...........oMo...........        dM-...........      .Md      O U T E R       +MMMMMMMMMMM*/
/*MMMMMM P MMMNM.                   /mMM:      `dddddddddddmMy       /Mh.      odddddddddddMN`                    :Ms          :hd:       dM`       mN:      .dddddddddddmMNddddddddddd-      :NMdddddddddddh      sM+                      mMMMMMMMMMMM*/
/*MMMMMMMMMMMMMh                      /mm+`                :My        :hNs.                mN`                    :Ms                     dM`       `sNd:                /M+                :hNy.                 `NN`    W O R L D S      :MMMMMMMMMMMM*/
/*MMMMM A MMMhM/        yo.            `+mm+`              -My          :dNs.              mN`      .d:           :Ms                     dM`         .sNd:              /M+              :hNy.                   +Ms                      hMMMMMMMMMMMM*/
/*MMMMMMMMMMMNm`        /dNo.            `+mm+`            -My           `:dNs.            mN`      `sNd:         :Ms                     dM`           .sNh:            /M+            :hNy-                     dM-                     .MMMMMMMMMMMMM*/
/*MMMM L 's        ......-oNNo.............-//-............/My.............-+NNs...........//.........:hMh:......./My.....................:/..............:hNh:..........+Mo............//:....................../Md......................sMMMMMMMMMMMMM*/
/*MMMMMMMMMMMNNNNNNNNNNNNNNMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMMNNNNNNNNNNNNNNNMMMNNNNNNNNNNNNNNNNNNNNNNNNMMNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMMNNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMM/   \MMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMMMMMMMMMMMMMMMM/   \MMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMM/   \MMMMMMMMMMMMMMM*/
/*MMMMMM  E  MMMMMMM  N  MMMMMMMM  D  MMMMMMMM  L  MMMMMMMM  E  MMMMMMMM  S  MMMMMMMM  S  MMMMMMMMMMMMMMMMMMMMMM  R  MMMMMMM  E  MMMMMMMM  L  MMMMMMMM  E  MMMMMMMM  N  MMMMMMMM  T  MMMMMMMM  L  MMMMMMMM  E  MMMMMMMM  S  MMMMMMMM  S  MMMMMMMMMMMMMMM*/
/*MMMMMM\   /MMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMMMMMMMMMMMMMMMM\   /MMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMM\   /MMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
/*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM





	This game was made to be compatible with 3 ports: ZDaemon, Zandronum and GZDoom. If you see some strange coding decisions, most likely ZDaemon compatibility is the reason for that.
	ZDaemon is an old-ass port and requires some gimmicky wayouts here and there. For example:
	1)When you compile it, make sure none of the scripts or functions carries more than 20 scope-defined variables inside of it!
	2)Don't use 'random`, use RNG function instead!
	3)Don't use StrParam function if it lasts longer than 1 tic. A string will be lost the very next tic! I use map sectors at the bottom to store important strparam info.
	4)Any new string should be at least defined as double quotation marks. Otherwise it can cause bugs in ZDaemon.

	To compile this script you have to use Zdaemon.acs as a base + manually written zandronum's stuff to zdefs.acs and zspecial.acs
	This script is a titlemap's BEHAVIOR.

	ZDAEMON PARAMS: 	set sv_joinlimit 1;		set sv_acs_world_exit 1;	set acs_always_preserve_globals 1
						DMFLAGS: 1327140		DMFLAGS2: 1179712


	ZANDRONUM PARAMS:	sv_randomcoopstarts 1
						DMFLAGS: 21512196		DMFLAGS2: 256				ZADMFLAGS: 7390032						ZACOMPATFLAGS: 131088

	*/


#libdefine LaunchVersion  	4
#libdefine LastChangeLog 	34


#libdefine HUDX_CHANGELOG 					768					#libdefine HUDY_CHANGELOG 					576

function void ChangeLog (int Ver, int Logg, int First)
{
int p;
str String = ""; str a = "";	str end = "";	bool ColorI;	str ColorS = ""; str Space = "";	str Logs = "";	str Ports = "";
if (First)	End = "Type CHANGELOG in console to view it again.";
int counter = LastChangeLog;
int Minus = LastChangeLog - Ver;
	if (Minus > 15)
		if (!Logg)
			{
			Ver = LastChangeLog - 15;
			End = StrParam(s:"...and more. ", s:End);
			}

										/*
											TCL
											CASE 0: String = "HUGE:       ";	break;
											CASE 1: String = "IMPORTANT:  ";	break;
											CASE 2: String = "WORTHY:     ";	break;
											CASE 3: String = "MINOR:      ";	break;
										*/

While(counter > Ver)
	{
	Space = "";
			Switch(counter)
				{
						CASE 1:			p = None;				a = StrParam(s:TCL(0),	s:PortCL(p),	s:"Long and tedious work on the procedural generation system.");
				break;	CASE 2:			p = None;				a = StrParam(s:TCL(0),	s:PortCL(p),	s:"Long and tedious work on the main game logic.");
				break;	CASE 3:			p = None;				a = StrParam(s:TCL(0),	s:PortCL(p),	s:"Tedious work on the geometry, resources, DEHACKED/DECORATE.");
				break;	CASE 4:			p = ZDaemon;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added ZDaemon compatibility");
				break;	CASE 5:			p = GZDoom;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added GZDoom demo mode.");
				break;	CASE 6:			p = None;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added a hub. Placed hidden bonuses and winners monuments.");
				break;	CASE 7:			p = None;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added Seasons/Stage system. Competitive mode i.e.");
				break;	CASE 8:			p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added Database support. Able to save various game info there.");
				break;	CASE 9:			p = None;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added Money system. Added a monk shop in the hub.");
				break;	CASE 10:		p = None;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added Pong minigame for spectators. Either PvP or PvAI.");
				break;	CASE 11:		p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added Mod Settings menu and minor menu changes in general.");
				break;	CASE 12:		p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added an Auto-Login feature with security encryption system.");
				break;	CASE 13:		p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added multiple advertisements to appear at the start of the round.");
				break;	CASE 14:		p = None;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added an experimantal seed with obstacles system, to be a further base.");
				break;	CASE 15:		p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added national and special flags. Players can choose their association.");
				break;	CASE 16:		p = None;				a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Added this ChangeLog.");
				break;	CASE 17:		p = None;				a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Added a more obvious necessity to jump into hub teleport.");
				break;	CASE 18:		p = Zandronum;			a = StrParam(s:TCL(3),	s:PortCL(p),	s:"Added an option to turn off Pong overlay for spectators.");
				break;	CASE 19:		p = None;				a = StrParam(s:TCL(3),	s:PortCL(p),	s:"Dynamic surv.countdown; Money Transfer fix; Advert Template in Menu.");
				break;	CASE 20:		p = Zandronum;			a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Applying a flag now costs money, to prevent inappropriate changes.");
				break;	CASE 21:		p = Zandronum;			a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Added Enemy Locator item. Easier to find the remaining monsters.");
				break;	CASE 22:		p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Relendless now use an adjacent automate login system UniAccount(UACC).");
				break;	CASE 23:		p = Zandronum;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Redone Scoreboard system, now parameters get linked to account ID.");
				break;	CASE 24:		p = Zandronum;			a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Redone join menu and minor things of it.");
				break;	CASE 25:		p = None;				a = StrParam(s:TCL(3),	s:PortCL(p),	s:"Archvile can't ressurect monsters; Pain Elementals damage when explode.");
				break;	CASE 26:		p = Zandronum;			a = StrParam(s:TCL(3),	s:PortCL(p),	s:"Added mini-tutorial, that automatically start in the first launch.");
				break;	CASE 27:		p = None;				a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Added Radar. It's now easier to navigate the map.");
				break;	CASE 28:		p = Zandronum;			a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Added an Auto-Buy feature.");
				break;	CASE 29:		p = ZDaemon;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Competitive seasons; Floor damage, HUD, intermission bugs fixed.");
				break;	CASE 30:		p = None;				a = StrParam(s:TCL(3),	s:PortCL(p),	s:"Added visual pit fatality. Old source code included for viewing.");
				break;	CASE 31:		p = ZDaemon;			a = StrParam(s:TCL(2),	s:PortCL(p),	s:"Stage winner or advert owner can now leave perm memo in a hub area.");
				break;	CASE 32:		p = ZDaemon;			a = StrParam(s:TCL(1),	s:PortCL(p),	s:"Backported some Abilities, backported quiz. Semifix of invisible walls.");
				break;	CASE 33:		p = None;				a = StrParam(s:TCL(-1),	s:PortCL(p),	s:"New seeding system, to make playground less patternised.");
				break;	CASE 34:		p = ZDaemon;			a = StrParam(s:TCL(-1),	s:PortCL(p),	s:"Automated leaderboard permanentation(Flambeau,Keyboard_Doomer,ZeroDev)");
				//break;	CASE 29:		a = StrParam(s:TCL(1),	s:"ZDaemon compat: Leaderboard storing(Flambeau, Keyboard_Doomer, ZeroDev).");
				}

	/*
	Switch(ColorI)
		{
		Case FALSE:		ColorS = "\cj";		ColorI = TRUE;		break;
		Case TRUE:		ColorS = "\cu";		ColorI = FALSE;		break;
		}
	*/

				if (Minus < 10)		Space = StrParam(s:Space, s:" ");
				if (Minus < 100)	Space = StrParam(s:Space, s:" ");


	String	= StrParam(s:ColorS, 	s:String,	s:Space, i:Minus, s:". ",  				s:a, s:"\n");
	Minus--;
	counter--;
	}

String = StrParam(s:"\ct---------------------------------- CHANGELOG ----------------------------------", s:"\cj\n\n\n", s:String, s:"\n");

Switch(Logg)
	{
	CASE false:

	SetFont("ERFONT");
	SetHudSize(HUDX_CHANGELOG, HUDY_CHANGELOG, false);
	HudMessage(s:String, s:"\cu", s:End, s:"\n"; 		HUDMSG_FADEINOUT|HUDMSG_NOWRAP,		0,			CR_WHITE, int2fix(HUDX_CHANGELOG/2),	int2fix(HUDY_CHANGELOG/2), 	12.0, 	1.0,	 3.0);

	break;



	CASE True:

	Log(s:String);

	break;
	}
}

function str TCL (int Type)
{
str String = "";
Switch(Type)
	{
	CASE -1: 	String = "\cdIN PROGRESS:  ";	break;
	CASE 0:		String = "HUGE:         ";		break;
	CASE 1: 	String = "IMPORTANT:    ";		break;
	CASE 2: 	String = "WORTHY:       ";		break;
	CASE 3: 	String = "MINOR:        ";		break;
	}
return String;
}





function str PortCL (int Type)
{
str String = "";
Switch(Type)
	{
	CASE None:			String = "       ";			break;
	CASE ZDaemon: 		String = "[ZDa]  ";		break;
	CASE Zandronum: 	String = "[ZAN]  ";		break;
	CASE GZDoom: 		String = "[GZD]  ";		break;
	}
return String;
}


function str LaunchVersionMsg (int Type)
{
str String = "";

Switch(Type)
	{
//	CASE 0:	String = "------------------------------------------------------------------------";
	CASE 0:	String = StripColors(StrParam(s:"Greetings, ", n:0, s:"! Enjoy your stay!"));				break;
	CASE 1:	String = "Security Update! Please reassure your Login, Password and Flag!";					break;
	CASE 2:	String = "Security Update! Please reassure your Login/Password!";							break;
	CASE 3:	String = "Flags Indexation was changed! Please reassure your Flag!";						break;
	}

return String;
}







#libdefine ER_ServerDate 				"..well, never played yet,"
#libdefine ER_ServerName 				"..uh, no server played on."
#libdefine MaxServerNameChars 			26 ////////////////////////

/*

  ______   ______   .__   __.      _______.___________.    ___      .__   __. .___________.    _______.
 /      | /  __  \  |  \ |  |     /       |           |   /   \     |  \ |  | |           |   /       |
|  ,----'|  |  |  | |   \|  |    |   (----`---|  |----`  /  ^  \    |   \|  | `---|  |----`  |   (----`
|  |     |  |  |  | |  . `  |     \   \       |  |      /  /_\  \   |  . `  |     |  |        \   \
|  `----.|  `--'  | |  |\   | .----)   |      |  |     /  _____  \  |  |\   |     |  |    .----)   |
 \______| \______/  |__| \__| |_______/       |__|    /__/     \__\ |__| \__|     |__|    |_______/


*/


/////////////////////////////////////// ACTOR TIDS

#libdefine PLAYER_TID 					32000	// Player Header
#libdefine ImpossibleNum				32754

#libdefine PlayerRadius					16
#libdefine PlayerHeight					56

#libdefine ACTORTID_InputArea 			3
#libdefine ACTORTID_PortalsUpper 		20
#libdefine ACTORTID_PortalsLower 		21
#libdefine ACTORTID_SSGplatform 		22
#libdefine ACTORTID_PortalMemo 			23


#libdefine ACTORTID_DynamicTid 			10000	// - 11000
#libdefine ACTORTID_PlayerSpawner 		11000	//


#libdefine ACTORTID_PortSpot 			32767
#libdefine ACTORTID_ZandronumTag 		32766
#libdefine ACTORTID_SkyboxCamera 		32765
#libdefine ACTORTID_GZDoomTag 			32763
#libdefine ACTORTID_InputPortal			32762
#libdefine ACTORTID_SkyfallInner		32761
#libdefine ACTORTID_HubCoin				32750 // -53
#libdefine ACTORTID_HubBigCoin			32747 // -49
#libdefine ACTORTID_ShopCamera			32745
#libdefine ACTORTID_GenCamera			32744
#libdefine ACTORTID_PlaygroundCenter	32743
#libdefine ACTORTID_GenCam				32742
#libdefine ACTORTID_SkyChant 			32741
#libdefine ACTORTID_DroneCam			32740
#libdefine ACTORTID_WinnerCam			32739
//#libdefine ACTORTID_Debug				32738
#libdefine ACTORTID_PlaygroundCamera	32738 //-4 35


#libdefine ACTORTID_AmbientWater 		32734
#libdefine ACTORTID_AmbientSpot 		32733
#libdefine ACTORTID_AmbientSound 		32732
#libdefine ACTORTID_Item 				32731
#libdefine ACTORTID_Projectile 			32730

#libdefine ACTORTID_NorthWestCorner 	32729
#libdefine ACTORTID_SouthEastCorner 	32728
#libdefine ACTORTID_DeathSubstance 		32727

#libdefine ACTORTID_MainTeleport 		1
#libdefine ACTORTID_Enemy 				31000
#libdefine ACTORTID_Boss				32098
#libdefine ACTORTID_Temp				32097

#libdefine ACTORTID_Hub 				32100
#libdefine ACTORTID_Skyfall 			32200
#libdefine ACTORTID_DemoEnd 			31900 // -31

#libdefine SkyfallOffset 				6144

//////////////////////////////////////// SECTOR TAGS

#libdefine SECTORTAG_HubMIN 			2
#libdefine SECTORTAG_HubMAX				13
#libdefine SECTORTAG_MemoSector			14
#libdefine SECTORTAG_WaggleFloor		9
#libdefine SECTORTAG_WaggleCeiling		10
#libdefine SECTORTAG_Pit 				99
#libdefine SECTORTAG_Skybox 			30000	// 30001 - 30064
#libdefine SECTORTAG_Spawn				11
#libdefine SECTORTAG_ShaftCoreEdge		32767
#libdefine SECTORTAG_ShaftSlope			32766
#libdefine SECTORTAG_SkyfallGround		32765
#libdefine SECTORTAG_ShaftOuterEdge		32764
#libdefine SECTORTAG_ShaftOuterPaling	32763
#libdefine SECTORTAG_ShaftCore			32762
#libdefine SECTORTAG_SubstanceDeath		32761

#libdefine TIDRAM_WinnerNames 			10000
#libdefine TIDRAM_LegendNames 			10300
#libdefine TIDRAM_ExitMarkerA 			10400
#libdefine TIDRAM_ExitMarkerB			10401
#libdefine TIDRAM_SkyboxVolume 			10402
#libdefine TIDRAM_HubMusic 				10403
#libdefine TIDRAM_WinCamera 			10404
#libdefine TIDRAM_MapReset	 			10405
#libdefine TIDRAM_MoneyChar	 			10406
#libdefine TIDRAM_Port					10407
#libdefine TIDRAM_CantJoinZDA			10408
#libdefine TIDRAM_SkyType				10409
#libdefine TIDRAM_GameSim				10410
#libdefine TIDRAM_JoinTImeLeft			10411
#libdefine TIDRAM_RoundMusic 			10412
#libdefine TIDRAM_Intro		 			10413
#libdefine TIDRAM_EnemyCount		 	10414
#libdefine TIDRAM_SystemDay		 		10415
#libdefine TIDRAM_Database		 		10416
#libdefine TIDRAM_Season		 		10417
#libdefine TIDRAM_Stage		 			10418
#libdefine TIDRAM_Try		 			10419
#libdefine TIDRAM_QuizTimer		 		10420
#libdefine TIDRAM_AdvertisementCost		10421
#libdefine TIDRAM_PasswordA		 		10430
#libdefine TIDRAM_PasswordB		 		10431
#libdefine TIDRAM_AdvertisementSlot		10432
#libdefine TIDRAM_StartPoint			10433
#libdefine TIDRAM_SubstanceLineOffset	10434// + 4
										//10439
#libdefine TIDRAM_Temp					10440


#libdefine TIDRAM_HoldTime				10535
#libdefine TIDRAM_Money	 				10500 // - 10531
#libdefine TIDRAM_FlagCost	 			10700 // - 10781
#libdefine TIDRAM_FlagUpdate	 		10750
#libdefine TIDRAM_Radar	 				10801 // -10825
#libdefine TIDRAM_Ability	 			10900 // - 10931


#libdefine TIDRAM_Mood					12500
#libdefine TIDRAM_Location				12501


#libdefine TIDRAM_MemoOwner			12600 // +15(max Zdaemon name chars)
#libdefine TIDRAM_MemoOwnerSYNC		12616
#libdefine TIDRAM_MemoOwnerType		12617
#libdefine TIDRAM_MemoMSGexist		12618

/////////////////////////////////////// LINE TAGS
#libdefine LINETAG_PlaygroundPerimeter	99
#libdefine LINETAG_ShaftEdge			98
#libdefine LINETAG_ShaftBase			97
#libdefine LINETAG_SkyfallPaling		96
#libdefine LINETAG_PlaygroundFence		95
#libdefine LINETAG_HubLogo				94
#libdefine LINETAG_VolumetricA 			32756
#libdefine LINETAG_VolumetricB 			32757
#libdefine LINETAG_VolumetricC			32758
#libdefine LINETAG_VolumetricD_up		32759
#libdefine LINETAG_VolumetricD_dn		32760
#libdefine LINETAG_ChangelogTX			31999
#libdefine LINETAG_ChangelogSTR			31998
#libdefine LINETAG_Outside				31997

#libdefine LINETAG_ZDaemonLegends 		30100
#libdefine LINETAG_ZandronumLegends		30208
#libdefine LINETAG_MemoOwnerString 		30300 //+128
#libdefine LINETAG_MemoOwnerVolume 		30500

#libdefine LINETAG_VolumetricPortal		32755
#libdefine LINETAG_Skybox				30000 //30001 - 30064


#libdefine CapeHeader 	   				5000
#libdefine CapeHeaderINNER 				CapeHeader + 50




#libdefine PlayerDiameter				32

//////////////////////////////////////



#libdefine For_ActivatorOnly 			0
#libdefine For_Everyone					1
#libdefine For_ClientOnly 				2


#libdefine GenDel_FloorFifth 			2
#libdefine GenDel_Border 				4
#libdefine GenDel_Height 				1

#libdefine MaxMiniBlocks 				80

#libdefine BottomLine 					-1
#libdefine Sec 							35
#libdefine DemoTime						60*3
#libdefine AFKTIME						35*120
#libdefine BYTE 						0
#libdefine FIXED 						1
#libdefine MaxTimeout					35*2
#libdefine MaxClientPitch				0.088897
#libdefine StandartVolume				127
#libdefine DroneCamHeight				192//384
#libdefine GenCamDistance				2080
#libdefine MoneyTransferFee				25
#libdefine MoneyTransferFeeInt			100/MoneyTransferFee
#libdefine QuizAnswerTime				15
#libdefine AdvertisementCost			75
#libdefine FlagPrice					125
#libdefine EnemyLocatorTime				SEC*3
//#libdefine EnemyLocatorCost				5

#libdefine CheckLoginIn					6
#libdefine IdleIntervalCheck			6
#libdefine MarkedXInfo					10
#libdefine DataStoreInterval			15
#libdefine SourceCodeTime				86400/2 //115200

#libdefine PlaygroundBlocks 			PBslots*PBslots
#libdefine MiniBlocks 					MBslots*MBslots
#libdefine BlockDiameter 				576
#libdefine BlockCenter 					36

#libdefine MaxContainerTries 			16
#libdefine MaxRounds 					5
#libdefine DOESNT_MATTER 				-1

#libdefine MaxPlayers					32
#libdefine MaxMinigamePlayers			8
#libdefine MaxStages					25
#libdefine MaxLegends 					3
#libdefine MaxMoney						250
#libdefine MaxEnemy						255
#libdefine PanicTime 					30
#libdefine JoinTime 					15
#libdefine FlowInverseTime 				15


#libdefine TakeBreath 					Sec*4
#libdefine MoveInstantly 				65536
#libdefine MinAllowedInput 				3
#libdefine InstantDeath 				666
#libdefine DefaultChaseDist 			90

#libdefine NotSpectator 				0
#libdefine TrueSpectator 				1
#libdefine DeadSpectator 				2

#libdefine MaxNameCharsZDA 				6
#libdefine MaxNameCharsZAN 				12
#libdefine MaxPortNameCharsZDA 			15
#libdefine MaxPortNameCharsZAN 			32
#libdefine MaxMemoOwnerMSGChars 		41
#libdefine MemoOwnerSphereLines 		128
#libdefine MemoOwnerType				MaxPortNameCharsZDA + 2
#libdefine AsLastWinner					1
#libdefine AsAdvertOwner				2

#libdefine MaxInfoChars					74		//55
#libdefine MaxEncMethod					5
#libdefine Encrypt						0
#libdefine Decrypt						1

#libdefine MaxByte						32767

#libdefine fromCvar_WINNERS 			0
#libdefine fromArray_WinnerNames 		1
#libdefine fromCvar_LEGENDS 			2
#libdefine fromArray_LegendNames 		3

#libdefine SVDT_Season					1
#libdefine SVDT_Stage					2
#libdefine SVDT_Try						3
#libdefine SVDT_Winners					4
#libdefine SVDT_Legends					5
#libdefine SVDT_MemoOwnerType			6
#libdefine SVDT_MemoOwner				7
#libdefine SVDT_MemoOwnerMSG			8


#libdefine OneBlock 					1
#libdefine TwoBlocks 					2
#libdefine ThreeBlocks 					3
#libdefine FourBlocks 					4
#libdefine AllowedContainerTypes 		4
#libdefine StartBlock 					999
#libdefine FinishBlock 					998
#libdefine SpecialBlocks 				998


#libdefine ToRIGHT 						1
#libdefine ToDOWN 						2
#libdefine ToLEFT 						3
#libdefine ToUP 						4
#libdefine ToRIGHT_or_ToLEFT 			5
#libdefine ToUP_or_ToDOWN 				6
#libdefine ANG_to_RIGHT 				256
#libdefine ANG_to_DOWN 					192
#libdefine ANG_to_LEFT 					128
#libdefine ANG_to_UP 					64
#libdefine ANG_to_UpRight 				32
#libdefine ANG_to_RightDown 			224
#libdefine ANG_to_DownLeft				160
#libdefine ANG_to_LeftUp				96

#libdefine Stairs_NORMAL 				1
#libdefine Stairs_DIAGONAL_right 		2
#libdefine Stairs_DIAGONAL_left 		3

#libdefine MONSTER 						1
#libdefine ACTORB 						2

#libdefine AxisX 						0
#libdefine AxisY 						1




#libdefine gs_IDLE 						0
#libdefine gs_LOADING 					1
#libdefine gs_ACTIVE 					2
#libdefine gs_END 						3




#libdefine COLORTEXT_MAIN 				9		//WHITE
#libdefine COLORTEXT_SECO 				2		//gray






#libdefine HUDid_FlagChoose 			190

#libdefine HUDid_JOIN_ICON 				200
#libdefine HUDid_JOIN_LETTER 			201
#libdefine HUDid_JOIN_BACK 				202
#libdefine HUDid_CLIENTCREDITS 			300
#libdefine HUDid_CLIENTCREDTIT1 		301
#libdefine HUDid_CLIENTCREDTIT2 		302
#libdefine HUDid_CLIENTCREDTIT3 		303
#libdefine HUDid_CLIENTCREDTIT4 		304
#libdefine HUDid_CLIENTCREDITEND 		305

#libdefine HUDid_AddAuthor				450
#libdefine HUDid_AddPurchase			451
#libdefine HUDid_AddMessage				452
#libdefine HUDid_AddBackground 			453


#libdefine HUDmg_PTS 					500
#libdefine HUDmg_BALL 					600
#libdefine HUDmg_PlayerName 			700
#libdefine HUDmg_Slider 				800
#libdefine HUDmg_Background 			900
#libdefine HUDmg_Background2 			901

#libdefine HUDid_Waypoint 				1100

#libdefine HUDid_TOP_TITLE 				1101
#libdefine HUDid_MIDDLE_TITLE 			1102
#libdefine HUDid_BOTTOM_TITLE 			1103

#libdefine HUDid_TOP_BACK 				1106
#libdefine HUDid_TOP_ICON 				1105
#libdefine HUDid_TOP_LETTER 			1104

#libdefine HUDid_MIDDLE_BACK 			1109
#libdefine HUDid_MIDDLE_ICON 			1108
#libdefine HUDid_MIDDLE_LETTER 			1107

#libdefine HUDid_BOTTOM_BACK 			1112
#libdefine HUDid_BOTTOM_ICON 			1111
#libdefine HUDid_BOTTOM_LETTER 			1110

#libdefine HUDid_VBOTTOM_BACK 			1115
#libdefine HUDid_VBOTTOM_ICON 			1114
#libdefine HUDid_VBOTTOM_LETTER 		1113

#libdefine HUDid_TOASTY					1119
#libdefine HUDid_INPUTNOTE 				1120
#libdefine HUDid_PRINTSCORES 			1121
#libdefine HUDid_PRINTFLAGS 			1122 //+5
#libdefine HUDid_InputName 				1130

#libdefine HUDid_NoteEDGETOPmsg 		1131
#libdefine HUDid_NoteSPECIALmsg 		1132
#libdefine HUDid_NoteTOPmsg 			1133
#libdefine HUDid_NoteMIDmsg 			1134
#libdefine HUDid_NoteBOTmsg 			1135
#libdefine HUDid_NoteVBOTmsg 			1136
#libdefine HUDid_NoteEDGETOPicon 		1137
#libdefine HUDid_NoteSPECIALicon 		1138
#libdefine HUDid_NoteTOPicon 			1139
#libdefine HUDid_NoteMIDicon 			1140
#libdefine HUDid_NoteBOTicon 			1141
#libdefine HUDid_NoteVBOTicon 			1142

#libdefine HUDid_MoneyBack 				1151
#libdefine HUDid_MoneyValue 			1150
#libdefine HUDid_MoneyIcon 				1149


#libdefine HUDid_MGback1 				1201
#libdefine HUDid_MGback2 				1202
#libdefine HUDid_MGback3 				1203
#libdefine HUDid_MGback4 				1204
#libdefine HUDid_MGback5 				1205




#libdefine HUDid_DebugSERVER			1300
#libdefine HUDid_DebugCLIENT			1301

#libdefine HUDid_EnemyMarker 			1500
#libdefine HUDid_ScoreboardBack 		1501




//MINIGAME

#libdefine HUDid_IconSelection 			2000
#libdefine HUDid_UnitInCellsHeader 		2010
#libdefine HUDid_FXHeader 				2100


#libdefine HUDid_SHOP_ICON 				3700
#libdefine HUDid_SHOP_LETTER 			3701
#libdefine HUDid_SHOP_BACKA 			3802
#libdefine HUDid_SHOP_BACKB 			3803
#libdefine HUDid_SHOP_BACKc 			3850

#libdefine HUDid_RADAR 					3450
#libdefine HUDid_Angle 					3400
#libdefine HUDid_ABILITY_ICON 			3500
#libdefine HUDid_ABILITY_LETTER 		3501
#libdefine HUDid_ABILITY_BACKA 			3602
#libdefine HUDid_ABILITY_BACKB 			3603
#libdefine HUDid_ABILITY_BACKc 			3650

#libdefine HUDid_ScreenFade 			4000





#libdefine	noteFadeIn_Long 			2.0
#libdefine	noteFadeIn_Standart 		1.0
#libdefine	noteFadeIn_Short 			0.5
#libdefine	noteFadeIn_None 			0.0

#libdefine	noteHold_Started 			4.0
#libdefine	noteHold_Failed 			3.0
#libdefine	noteHold_Long 				8.0
#libdefine	noteHold_VLong 				15.0
#libdefine	noteHold_Standart 			5.0
#libdefine	noteHold_Short 				3.0
#libdefine	noteHold_None 				0.0

#libdefine	noteFadeOut_Started 		1.0
#libdefine	noteFadeOut_Failed 			2.0
#libdefine	noteFadeOut_Long 			4.0
#libdefine	noteFadeOut_Standart 		2.0
#libdefine	noteFadeOut_Short 			1.0
#libdefine	noteFadeOut_None 			0.0




#libdefine notepara_CENTER 				0
#libdefine notepara_ALIGN 				1

#libdefine notepose_EDGETOP 			1
#libdefine notepose_SPECIAL 			2
#libdefine notepose_TOP 				3
#libdefine notepose_MID 				4
#libdefine notepose_BOT 				5
#libdefine notepose_VBOT				6

#libdefine HUDX_FULLSCREEN 				8
#libdefine HUDY_FULLSCREEN 				6

#libdefine HUDX_HUGE 					40
#libdefine HUDY_HUGE					30

#libdefine HUDX_VERYBIG 				160
#libdefine HUDY_VERYBIG 				120

#libdefine HUDX_BIG 					320
#libdefine HUDY_BIG 					240

#libdefine HUDX_LARGE 					480
#libdefine HUDY_LARGE					360

#libdefine HUDX_MEDIUM 					640
#libdefine HUDY_MEDIUM 					480

#libdefine HUDX_SMALL 					1024
#libdefine HUDY_SMALL 					768

#libdefine HUDX_VERYSMALL				1280
#libdefine HUDY_VERYSMALL				960

#libdefine HUDX_TINY					2560
#libdefine HUDY_TINY					1920


#libdefine X_MUTUAL 					HUDX_MEDIUM/2	+	HUDX_MEDIUM/3	+	HUDX_MEDIUM/10
#libdefine Y_MUTUAL 					HUDY_MEDIUM/2	-	HUDY_MEDIUM/3


#libdefine X_TOP_TITLE					HUDX_MEDIUM/2
#libdefine Y_TOP_TITLE					HUDY_MEDIUM/4 - 32
#libdefine X_MIDDLE_TITLE				HUDX_BIG/2
#libdefine Y_MIDDLE_TITLE				HUDY_BIG/4
#libdefine X_BOTTOM_TITLE				HUDX_MEDIUM/2
#libdefine Y_BOTTOM_TITLE				HUDY_MEDIUM/4 + 32



#libdefine ToastySize					74
#libdefine ToastySpeed					10
#libdefine ToastyHold					15
#libdefine X_JOINTIMEOFFSET				80
#libdefine Y_MONEY						Y_MUTUAL		-	Y_MUTUAL/3		-	Y_MUTUAL/3
#libdefine Y_EDGETOP					HUDY_MEDIUM/2	-	HUDY_MEDIUM/2	+	8

#libdefine X_TOP_BACK					X_MUTUAL
#libdefine Y_TOP_BACK					Y_MUTUAL		-	Y_MUTUAL/3
#libdefine X_TOP_ICON					X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_TOP_ICON					Y_MUTUAL		-	Y_MUTUAL/3
#libdefine X_TOP_LETTER					X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_TOP_LETTER					Y_MUTUAL		-	Y_MUTUAL/3

#libdefine X_MIDDLE_BACK				X_MUTUAL
#libdefine Y_MIDDLE_BACK				Y_MUTUAL
#libdefine X_MIDDLE_ICON				X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_MIDDLE_ICON				Y_MUTUAL
#libdefine X_MIDDLE_LETTER				X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_MIDDLE_LETTER				Y_MUTUAL

#libdefine X_BOTTOM_BACK				X_MUTUAL
#libdefine Y_BOTTOM_BACK				Y_MUTUAL		+	Y_MUTUAL/3
#libdefine X_BOTTOM_ICON				X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_BOTTOM_ICON				Y_MUTUAL		+	Y_MUTUAL/3
#libdefine X_BOTTOM_LETTER				X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_BOTTOM_LETTER				Y_MUTUAL		+	Y_MUTUAL/3


#libdefine X_RADAR 						HUDX_BIG/2	-	HUDX_BIG/3	-	HUDX_BIG/10  - 8*2
#libdefine Y_RADAR						HUDY_BIG/2	+	HUDY_BIG/4	+	HUDY_BIG/24

#libdefine X_VBOTTOM_BACK				X_MUTUAL
#libdefine Y_VBOTTOM_BACK				Y_MUTUAL		+	Y_MUTUAL/3*2
#libdefine X_VBOTTOM_ICON				X_MUTUAL		-	X_MUTUAL/22
#libdefine Y_VBOTTOM_ICON				Y_MUTUAL		+	Y_MUTUAL/3*2
#libdefine X_VBOTTOM_LETTER				X_MUTUAL		+	X_MUTUAL/64
#libdefine Y_VBOTTOM_LETTER				Y_MUTUAL		+	Y_MUTUAL/3*2



#libdefine X_FULLSCREEN					HUDX_FULLSCREEN/2
#libdefine Y_FULLSCREEN					HUDY_FULLSCREEN/2


#libdefine DN_IconOffset				HUDX_MEDIUM/3 + HUDX_MEDIUM/6

#libdefine ICON_None 					32
#libdefine ICON_Exclamation 			33
#libdefine ICON_Location 				35
#libdefine ICON_Checkmark 				36
#libdefine ICON_Clock 					37
#libdefine ICON_Exit 					38
#libdefine ICON_Mission 				39
#libdefine ICON_Weapon 					40
#libdefine ICON_Sad 					41
#libdefine ICON_Money 					42
#libdefine ICON_Waypoint 				43
#libdefine ICON_Zzz		 				44
#libdefine ICON_Shop		 			45
#libdefine ICON_Minigame		 		46
#libdefine ICON_HEADER_Load 			48
#libdefine ICON_HEADER_Clock 			52
#libdefine ICON_Round 					63
#libdefine ICON_Boss 					64
#libdefine ICON_EnemyCount 				65
#libdefine ICON_Substance 				66
#libdefine ICON_ChaseCam 				80
#libdefine ICON_DroneCam 				81
#libdefine ICON_GenCam 					82
#libdefine ICON_Special					83
#libdefine ICON_SourceCode				84
#libdefine ICON_Quiz					85
#libdefine ICON_Music					86
#libdefine ICON_EnemyMarker				87
#libdefine ICON_Port					88
#libdefine ICON_ZDaemon					89
#libdefine ICON_Zandronum				90
#libdefine ICON_GZDoom					91
#libdefine ICON_WhiteScreen 			112
#libdefine ICON_BlackScreen 			113
#libdefine ICON_Slider 					117

#libdefine RADAR_Base 					33
#libdefine RADAR_Empty 					34
#libdefine RADAR_Start 					35
#libdefine RADAR_Finish					36
#libdefine RADAR_StartFinish			37
#libdefine RADAR_Ang 					48
#libdefine RADAR_Ally 					74


#libdefine AdvertAlpha					0.30	//0.45
#libdefine PurchaseAdvertAlpha			0.25	//0.3
#libdefine RadarBackAlpha				0.35
#libdefine MissionFailed_Hold			3.0
#libdefine MissionFailed_FadeIn			1.0
#libdefine MissionFailed_FadeOut		1.0

#libdefine FREELOOK_LIMIT_UP 			-40
#libdefine FREELOOK_LIMIT_DOWN 			39





#libdefine mus_CALM 					0
#libdefine mus_NORM 					1
#libdefine mus_EPIC 					2


#libdefine SCRIPT_InputEnter 			30
#libdefine SCRIPT_InputBackspace 		31
#libdefine SCRIPT_InputChar 			32
#libdefine SCRIPT_Buy					33
#libdefine SCRIPT_FadeProjectile 		34
#libdefine SCRIPT_Changelog 			35

#libdefine SCRIPT_DestroyProjectile 	99

#libdefine PlaygroundRoot 				0

#libdefine HubRoot 						10240
#libdefine HubRadius 					896
#libdefine InputroomRoot 				4096
#libdefine InputroomRadius 				576
#libdefine PlaygroundRadius 			PBslots*576/2 + 256



#libdefine ps_DEAD 						0
#libdefine ps_HUB 						1
#libdefine ps_PLAYGROUND 				2
#libdefine ps_INPUT 					3

//--------------------------------------------------------------
#libdefine ProjRole_EMIT 				0
#libdefine ProjRole_DEVOUR 				1
#libdefine SIDE_SIDEY 					2

#libdefine area_FLOOR 					1
#libdefine area_CEILING 				2
#libdefine area_FLOORnCEIL				3
#libdefine area_Preparation				4

#libdefine SoilICE 						1
#libdefine SoilMUD 						2

#libdefine ProjHoleHeight 				16
#libdefine ProjHoleSize 				32

#libdefine ProjParam_EMITSPOT 			1
#libdefine ProjParam_DEVOURSPOT 		2
#libdefine ProjParam_TYPE 				3
#libdefine ProjParam_SPEED				4
#libdefine ProjParam_ANGLE				5
#libdefine ProjParam_DELAY				6
#libdefine ProjParam_HEIGHT				7
#libdefine ProjParam_TIMER				8

#libdefine ProjectilaParams				9
#libdefine ProjectilaSlots				16*PlaygroundBlocks
//--------------------------------------------------------------
//SERVERINFO

#libdefine 		ServerStarted 			0
#libdefine 		SEASON 					1
#libdefine 		STAGE 					2
#libdefine 		TRY 					3
#libdefine 		RegisteredPlayers 		4
#libdefine 		CREDITS 				5
#libdefine 		ZANmapwin 				6
#libdefine 		CHEATED 				7
#libdefine 		QuizIn 					8
#libdefine 		AdvertQueue				9
#libdefine 		MaxCharsAllStages		10
#libdefine 		WinDates				11

#libdefine		LayoutType_Random 		0
#libdefine		LayoutType_ByTheList 	1
#libdefine		LayoutType_Boss 		2

#libdefine 		AccomplishByENEMYONLY 	0
#libdefine 		AccomplishByTELEPORT	1

#libdefine CREDITS_StartAt 				1000

#libdefine InfoType_ORDER				0
#libdefine InfoType_BORDERTYPE			1
#libdefine InfoType_EntryX				2
#libdefine InfoType_EntryY				3
#libdefine InfoType_BLOCKSAMOUNT		4


#libdefine TransferToCvar 				0
#libdefine TransferToArray 				1




#libdefine refreshspot_ITEM				1
#libdefine refreshspot_PROJECTILE		2
#libdefine refreshspot_DEFAULT			3

#libdefine DefaultFloorHeight			0
#libdefine DefaultCeilingHeight 		4096
#libdefine DefaultPitFloorHeight 		-1024
#libdefine DefaultPitCeilingHeight 		4096


#libdefine SectorSpecial_CLEAR 					-1
#libdefine SectorSpecial_FLOW 					1
#libdefine SectorSpecial_DEATH					2
#libdefine SectorSpecial_Scroll_HORIZONTAL		3
#libdefine SectorSpecial_Scroll_VERTICAL		4
#libdefine SectorSpecial_FRICTION				5


#libdefine mood_EARTH					1
#libdefine mood_COLONY					2
#libdefine mood_SPACE					3

 int GAMEINFO[12];
//GAMEINFO
#libdefine		PortIs					0
#libdefine 		DemoVersion 			1
#libdefine 		InputNameTime 			2
#libdefine 		WinnerPlayerNum 		3
#libdefine		GameTest				4
#libdefine		MaxNameChars			5
#libdefine		RoundsCount				6
#libdefine		MapTime					7
#libdefine		AbsoluteTime			8
#libdefine		MinigameWinPlayaNum		9
#libdefine		MinigameWinPlayaPTS		10
#libdefine		NextTry					11


#libdefine 		FlatBASEtx 				12510
#libdefine 		FlatSECOtx 				12511
#libdefine 		FlatEDGEtx 				12512
#libdefine 		FlatFAILtx 				12513
#libdefine 		FlatCOALtx 				12514
#libdefine 		FlatPORTtx 				12515
#libdefine 		FlatWATEtx 				12516
#libdefine 		FlatBOMBtx 				12517
#libdefine 		FlatSCRLtx 				12518
#libdefine 		FlatICEYtx 				12519
#libdefine 		FlatWORMtx 				12520
#libdefine 		FlatMUDDtx 				12521
#libdefine 		FlatICEDtx 				12522
#libdefine 		CeilBASEtx 				12523
#libdefine 		CeilSECOtx 				12524
#libdefine 		WallBASEtx 				12525
#libdefine 		WallSECOtx 				12526
#libdefine 		WallEDGEtx 				12527
#libdefine 		WallFENCtx 				12528
#libdefine 		WallRAIStx 				12529



int RoundInfo[57];

#libdefine 		CurrentRound 			0
#libdefine 		StartpointTAG 			1
#libdefine 		FinishpointTAG 			2
#libdefine 		GlobalCeilingHeight 	3
#libdefine 		GlobalFloorHeight 		4


#libdefine 		LoadSegments 			5
#libdefine 		StairsChance 			6
#libdefine 		OptEntranceX 			7
#libdefine 		OptEntranceY 			8
#libdefine 		CurrFloorHeight			9
#libdefine 		OldCurrFloorHeight 		10
#libdefine 		HeightSeg 				11
#libdefine 		InvertedRoute 			12
#libdefine 		AddBorderEntryHeightX 	13
#libdefine 		AddBorderEntryHeightY 	14
#libdefine 		InvertedStairs 			15
#libdefine		BorderExceptionCounter 	16
#libdefine		PitFloorHeight 			17
#libdefine		PitCeilingHeight 		18
#libdefine		MaxSubstanceHeight 		19
#libdefine		CurrSubstanceHeight 	20
#libdefine		AbsSubstanceHeight 		21
#libdefine		SubstanceLineOffset 	22
#libdefine		SubstanceMoveDelay	 	23
#libdefine		SubstanceMoveTimer	 	24
#libdefine		adventureCounter		25			//in secs
#libdefine		CheckpointWinner	 	26
#libdefine		FlowSpeed	 			27
#libdefine		MiniStartpoint	 		28
#libdefine		MiniFinishpoint	 		29
#libdefine		MiniCheckPoint	 		30
#libdefine		SectorItemCounter	 	31
#libdefine		HealthSpawnerCounter	32
#libdefine		HealthSpawnerQueue		33
#libdefine		WeaponSpawnerCounter	34
#libdefine		WeaponSpawnerQueue		35
#libdefine		MoneySpawnerCounter		36
#libdefine		MoneySpawnerQueue		37
#libdefine		AmmoSpawnerCounter		38
#libdefine		AmmoSpawnerQueue		39
#libdefine		sct_RED					40
#libdefine		sct_GREEN				41
#libdefine		sct_BLUE				42
#libdefine		sct_DESATURATE			43
#libdefine		sct_BRIGHTNESS			44
#libdefine		sct_FADEDIV				45
#libdefine 		CheckpointReached 		46
#libdefine 		PlaygroundReached 		47
#libdefine 		TimeGiven				48
#libdefine		ArmorSpawnerCounter		49
#libdefine		ArmorSpawnerQueue		50
#libdefine		EnemyCounter			51
#libdefine		StairsDecided			52
#libdefine		MinigamePlayerCount		53
#libdefine		EnemyAmmo				54
#libdefine		WormsRestart			55
#libdefine		SoilRestart				56

#libdefine 		StairsHeight 			128


#libdefine		InvasionStartTime 		15
#libdefine 		DefaultFloorTexture 	1
#libdefine 		DefaultCeilingTexture 	2
#libdefine 		DefaultBorderFloorTexture 		3
#libdefine 		DefaultBorderCeilingTexture 	4







int PlayerScore			[MaxPlayers];
int PlayerCheckpoint	[MaxPlayers];
int PlayerAnswer		[MaxPlayers];
int PlayerFlag			[MaxPlayers];
int PlayerToasty		[MaxPlayers];
str CurrentName			[MaxPlayers*2] = {"-1"};
/*
0 - 31		= Player Name
32 - 63		= Player database ID
64 - 95		= Source Code Request
*/

#libdefine		MaxAdds					4
#libdefine		MaxAddCharsX			70
#libdefine		MaxAddCharsY			20
#libdefine		AdvertHoldTime			5
#libdefine		MaxAddColors			22
#libdefine 		AdvertisementCvar 		"ER_ADD"
#libdefine 		Ability					"Mana1" //"ElectricBolts"
#libdefine 		Money					"BlasterAmmo"

#libdefine 		adv_COLOR				0
#libdefine 		adv_COST				1
str Advertisement[MaxAdds + 1][MaxAddCharsY + 1];
int AdvertisementMisc[MaxAdds + 1][2];


int AdventureInfo[MaxRounds + 1][8];

#libdefine	adv_TYPE 					0
#libdefine 		adventure_BOSS 			1
#libdefine 		adventure_MAZE 			2
#libdefine 		adventure_LINEAR 		3
#libdefine 		adventure_RAISE 		4
#libdefine 		adventure_INVASION 		5
#libdefine 		adventure_FLOW 			6

#libdefine adv_DIFFICULTY   			1
#libdefine adv_MUSIC   					2
#libdefine adv_BOSS   					3
#libdefine adv_WEAPON 					4
#libdefine adv_RANDOMEVENT 				5
#libdefine 		event_BOMB				1

#libdefine adv_BOSSMAXHP 				6
#libdefine adv_MINICHECKPOINTS 			7







	#libdefine id_None					0

#libdefine id_minWEAPON 		1
	#libdefine id_Pistol				1
	#libdefine id_Shotgun				2
	#libdefine id_Chaingun				3
	#libdefine id_SuperShotgun			4
	#libdefine id_Railgun				5
	#libdefine id_RocketLauncher		6
	#libdefine id_PlasmaRifle			7
	#libdefine id_BFG9000				8
#libdefine id_maxWEAPON 		8

#libdefine id_minAMMO			9
	#libdefine id_Clip					9
	#libdefine id_ClipBox				10
	#libdefine id_Shell					11
	#libdefine id_ShellBox				12
	#libdefine id_RocketAmmo			13
	#libdefine id_RocketBox				14
	#libdefine id_Cell					15
	#libdefine id_CellPack				16
	#libdefine id_Backpack				17
#libdefine id_maxAMMO 			17

#libdefine id_minHEALTH			18
	#libdefine id_Stimpack 				18
	#libdefine id_Medkit 				19
#libdefine id_maxHEALTH			19

#libdefine id_minArmor			20
	#libdefine id_ArmorBonus 			20
	#libdefine id_GreenArmor 			21
	#libdefine id_BlueArmor 			22
#libdefine id_maxArmor			22

#libdefine id_minMoney			23
	#libdefine id_SmallCoin 			23
	#libdefine id_BigCoin 				24
#libdefine id_maxMoney			24

#libdefine id_minMisc			25
	#libdefine id_AllMap 				25
	#libdefine id_Soulsphere 			26
#libdefine id_maxMisc			26



#libdefine id_minENEMY			27
	#libdefine id_Zombieman 			27
	#libdefine id_Imp					28
	#libdefine id_ShotgunGuy			29
	#libdefine id_Demon					30
	#libdefine id_LostSoul				31
	#libdefine id_HeavyWeaponDude		32
	#libdefine id_Spectre				33
	#libdefine id_Cacodemon				34
	#libdefine id_HellKnight			35
	#libdefine id_BaronOfHell			36
	#libdefine id_Mancubus				37
	#libdefine id_Arachnotron			38
	#libdefine id_Archvile				39
	#libdefine id_SpiderMastermind		40
	#libdefine id_PainElemental			41
	#libdefine id_Railgunner			42
	#libdefine id_Cyberdemon			43
#libdefine id_maxENEMY			43

#libdefine id_minPROJECTILE		44
	#libdefine id_ImpBall 				44
	#libdefine id_BaronBall 			45
	#libdefine id_ArachnotronShot 		46
	#libdefine id_PlasmaBall 			47
	#libdefine id_CacoBall 				48
	#libdefine id_RevenantBall			49
	#libdefine id_MancubusShot 			50
	#libdefine id_Rocket 				51
	#libdefine id_BFGBall 				52
#libdefine id_maxPROJECTILE		52

#libdefine id_minMARINE			53
	#libdefine id_MarineBFG 			53
	#libdefine id_MarinePlasma			54
	#libdefine id_MarineBerserk 		55
	#libdefine id_MarineChaingun 		56
	#libdefine id_MarineRocket 			57
	#libdefine id_MarineShotgun 		58
	#libdefine id_MarineRailgun 		59
	#libdefine id_MarineSSG				60
#libdefine id_maxMARINE			60



#libdefine id_minAbility		61
	#libdefine id_SourceCode			61
	#libdefine id_GenCam				62
	#libdefine id_ChaseCam				63
	#libdefine id_DroneCam				64
	#libdefine id_MoneyTransfer			65
	#libdefine id_Advertisement			66
	#libdefine id_EnemyLocator			67

#libdefine id_maxAbility		67

#libdefine tc_GREY 						1
#libdefine tc_WHITE 					2
#libdefine tc_BROWN 					3
#libdefine tc_PEACH 					4
#libdefine tc_RED 						5
#libdefine tc_PINK 						6
#libdefine tc_YELLOW 					7
#libdefine tc_BLUE 						8
#libdefine tc_GREEN 					9







int 	GAMESTATE,
		TimeLeft,
		LoadBit,
		TempSEASON,
		TempSTAGE,
		TempTRY;

bool 	Deploying;



#libdefine		mg_WIDTH				384
#libdefine		mg_HEIGHT				256

#libdefine 		HUDX_MINIGAME			160*8 	//1280
#libdefine 		HUDY_MINIGAME			120*8	//960

#libdefine 		mg_CenterX				HUDX_MINIGAME/2
#libdefine 		mg_CenterY				HUDY_MINIGAME/2 //+ HUDY_MINIGAME/4

#libdefine 		mg_offsetX				mg_CenterX - mg_WIDTH/2
#libdefine 		mg_offsetY				mg_CenterY - mg_HEIGHT/2


#libdefine		mg_AlphaMax				0.75
#libdefine		mg_AlphaMin				0.2
#libdefine		mg_AlphaDec				0.0025

#libdefine		mg_SliderLen			5
#libdefine		mg_SliderRadius			mg_SliderLen*8/2
#libdefine		mg_SliderSpeed			8
#libdefine		mg_BallRadius			4
#libdefine		mg_MaxActivity			SEC*15
#libdefine		mg_MaxAI				2




#libdefine		MGRAM_Sequence			12000

#libdefine		MGRAM_BallPosY			12001
#libdefine		MGRAM_BallPosX1			12002
#libdefine		MGRAM_BallPosX2			12003

#libdefine		MGRAM_PlayerPos			12100
#libdefine		MGRAM_PlayerActivity	12200
#libdefine		MGRAM_PlayerPTS			12300
#libdefine		MGRAM_EvenOdd			12400


#libdefine 		ClientMsgDelay			0.05


#libdefine button_ACTION 				0
#libdefine button_QUIT 					1




#libdefine		MaxObstacles			10
int ContainerObstacle[MaxObstacles];


//TIMEGIVENS

#libdefine		TG_WALL					6




/*

 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.                .______        ___           _______. __    ______
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |        _       |   _  \      /   \         /       ||  |  /      |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |       (_)      |  |_)  |    /  ^  \       |   (----`|  | |  ,----'
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |                |   _  <    /  /_\  \       \   \    |  | |  |
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   |        _       |  |_)  |  /  _____  \  .----)   |   |  | |  `----.
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__|       (_)      |______/  /__/     \__\ |_______/    |__|  \______|


*/







function int abs (int x)
{
	if (x < 0)
	return -x;

	return x;
}

function int invert (int x)
{
	x = -1*x;

return x;
}




function int int2fix(int value)
{
	return value * 1.0;
}



function int tic2sec(int Value)
{
	return FixedDiv(Value << 16, 35.0);
}


function int isEven (int num)
{
    return !(num & 1);
}



function int RNG (int min, int max)
{
int result;
	Switch(GetPort())
		{
		CASE ZDaemon:		result = ZD_rand(min, max);		break;
		CASE Zandronum:
		CASE GZDoom:		result = random(min, max);		break;
		}
return result;
}




function int StrToNum(str s)	//AToI
{
    int start = 0;
    bool negative = false;
    int n = 0;
    int len = StrLen(s);
    // Check if we start with a negative sign
    if (GetChar(s, 0) == '-')
    {
        negative = true;
        start++;
    }

    // Go through every character in the string
    for (int i=start; i<len; i++)
    {
        int char = GetChar(s, i);

        // Check that we are actually converting a number
        if (char < '0' || char > '9')
        {
            print(s:"ERROR, attempting to convert ", c:char, s:" to number!");
            continue;
        }

        // Add the number to our total
        n = n*10 + (char-'0');
    }

    if (negative)
        n = -n;

    return n;
}




function int ClientCount(void) // code by Korshun, edited by TDRR
{
    int count = 0;
    for (int i = 0; i < 32; i++)
        if (PlayerInGame(i) || (PlayerIsSpectator(i) > 0))
            count++;
    return count;
}


function bool ClientExist (int PlayerNum)
{
bool Result;
if (PlayerInGame(PlayerNum) | (PlayerIsSpectator(PlayerNum) > 0))	Result = TRUE;

return Result;
}



function str PrintClock(int seconds) {
    int m = seconds / 60;
    int s = seconds % 60;

    str result = StrParam(d: m, s: ":");
    if (s < 10) result = StrParam(s: result, d: 0);
    result = StrParam(s: result, d: s);
    return result;
}




function bool BinarySwitch (bool Value)
{
if (Value == true) Value = false;
else value = true;
return Value;
}


function int GetPlayerTopIndex (void)
{
int Maxx;

Switch(GetPort())
	{
	case ZDaemon:	Maxx	=	PlayerTopIndex(); 		break;
	case Zandronum:
	case GZDoom:
					for (int i = 0; i < MaxPlayers; i++)
						{
						if (ClientExist (i))	Maxx = i;
						}
	break;
	}

return Maxx;
}



function int RandomNoZero (int Min, int Max)
{
int Result;
int tendency = RNG(0,1);
Switch(tendency)
	{
	Case 0: Result = RNG(Min, -1); break;
	Case 1: Result = RNG(1, Max); break;
	}
return Result;
}




function int RandomRange (int Num)
{
int Result;
int tendency = RNG(0,1);
Switch(tendency)
	{
	Case 0: Result = RNG(-Num, 	-1); 	break;
	Case 1: Result = RNG(1, 	Num); 	break;
	}
return Result;
}



function int WithinHundred (int Num)
{
int Result;
		if (Num < 0)	Result = 0;
else 	if (Num > 100)	Result = 100;
else Result = Num;
return Result;
}


function str PlusMinusChar(int Num)
{
str Result = "";
if (Num >= 0) 	Result = StrParam(s:" + ", i:abs(Num));
else			Result = StrParam(s:" - ", i:abs(Num));
return Result;
}



function int CharToUpper(int input)
{
    if (input >= 'a' && input <= 'z')
    {
        return input ^ 0x20;
    }

    return input;
}

function str StrToUpper(str input)
{
    str output = "";

    for (int i = 0; i < StrLen(input); i++)
    {
        int upper = CharToUpper(GetChar(input, i));
        output = StrParam(s: output, c: upper);
    }
    return output;
}




function str StripColors(str input) //DrinkyBird + Mr.Satan
{
  str output = ""; bool isCol = false; bool isBracket = false;
  for (int i = 0; i < StrLen(input); i++)
  {
    int c = GetChar(input, i);
    if (GetChar(input, i) == '\\' && GetChar(input, i + 1) == 'c') { isCol = true; i++; }
    else if (c == 0x1C) { isCol = true; }
    else if (isCol)
    {
      if (c == '[') { isBracket = true; }
      else if (c == ']') { isBracket = false; }
      if (!isBracket) { isCol = false; }
    }
    else { output = StrParam(s: output, c: c); }
  }
  return output;
}



function void Set_AllGodmode (bool set)
{
	for (int i = 0; i < GetPlayerTopIndex() ; i++) {
		SetActorProperty(PLAYER_TID+i,APROP_Invulnerable,set);
	}
}


//Thrillster
function int len_int (int value) {
  int length = 1;
  while (value > 9) {
    length++;
    value /= 10;
  }
  return length;
}






function int GetPortPitch (int Direction)
{
int Result;
Switch(GetPort())
	{
	CASE ZDaemon:
		Switch(Direction)
			{
			CASE ToUP:		Result = -0.088897;		break;
			CASE ToDOWN:	Result =  0.155548;		break;
			}
	break;

	CASE Zandronum:
		Switch(Direction)
			{
			CASE ToUP:		Result = -0.155563; 	break;
			CASE ToDOWN:	Result =  0.155548;		break;
			}
	break;

	CASE GZDoom:
		Switch(Direction)
			{
			CASE ToUP:		Result = -0.25; 		break;
			CASE ToDOWN:	Result =  0.25;			break;
			}
	break;
	}
return Result;
}









function str StringNoEdgeSpaces (str String)
{
int counter, Edge;
str Result = "";
int MaxStrChars = StrLen(String);
/*
                                                        _        _   _           __             _
  _ _ ___ _ __  _____ _____   ____ __  __ _ __ ___ ___ (_)_ _   | |_| |_  ___   / _|_ _ ___ _ _| |_
 | '_/ -_) '  \/ _ \ V / -_) (_-< '_ \/ _` / _/ -_|_-< | | ' \  |  _| ' \/ -_) |  _| '_/ _ \ ' \  _|
 |_| \___|_|_|_\___/\_/\___| /__/ .__/\__,_\__\___/__/ |_|_||_|  \__|_||_\___| |_| |_| \___/_||_\__|
                                |_|
*/

While(Edge < MaxStrChars)
{
if (GetChar(String, Edge) == 32) Edge++;
else break;
}



counter = Edge;
while(counter < MaxStrChars)
{
Result =   StrParam(s:Result, c:GetChar(String, counter));
counter++;
}

String = Result; counter = 0;	Result = "";
/*
                                                        _        _   _          _             _
  _ _ ___ _ __  _____ _____   ____ __  __ _ __ ___ ___ (_)_ _   | |_| |_  ___  | |__  __ _ __| |__
 | '_/ -_) '  \/ _ \ V / -_) (_-< '_ \/ _` / _/ -_|_-< | | ' \  |  _| ' \/ -_) | '_ \/ _` / _| / /
 |_| \___|_|_|_\___/\_/\___| /__/ .__/\__,_\__\___/__/ |_|_||_|  \__|_||_\___| |_.__/\__,_\__|_\_\
                                |_|
*/

Edge = StrLen(String) - 1;



While(Edge > 0)
{
if (GetChar(String, Edge) == 32) Edge--;
else break;
}



while(counter <= Edge)
{
Result =   StrParam(s:Result, c:GetChar(String, counter));        // StrParam(s:Result, c:WinnerNames[InputHeader + counter]);
counter++;
}
Return Result;

}




function int GetPort (void)
{
int Result = GetSectorLightLevel(TIDRAM_Port);
return Result;
}




function void SetPort (void)
{
int Result;
//																				CLIENTSIDE										SERVERSIDE
		if (IsTIDUsed(ACTORTID_GZDoomTag) 		== true)		{		Light_ChangeToValue(TIDRAM_Port, GZDoom);		GAMEINFO[PortIs] = GZDoom;		}
else 	if (IsTIDUsed(ACTORTID_ZandronumTag) 	== true)		{		Light_ChangeToValue(TIDRAM_Port, Zandronum);	GAMEINFO[PortIs] = Zandronum;	}
else															{		Light_ChangeToValue(TIDRAM_Port, ZDaemon);		GAMEINFO[PortIs] = ZDaemon;		}

}




function bool IsCompetitive (void)
{
bool Result;

Switch(GetPort())
	{
	CASE ZDaemon: 	if (NetMode() > 1)																		if (ServerInfo[SEASON])		if (ServerInfo[STAGE])	Result = TRUE;	break;
	CASE Zandronum:	if (IsNetworkGame())		if (StrLen(StrParam(s:GetCvarString("databasefile"))))		if (ServerInfo[SEASON])		if (ServerInfo[STAGE])	Result = TRUE;	break;
	}

return Result;
}



function str MergedStringInfo (int SplitterChar, int InfoType, str InputString)
{
str String = "";
int counter, SplitCounter;



		while (counter < StrLen(InputString))
			{
			if 	(GetChar(InputString, counter) == SplitterChar)
									{
									SplitCounter++;
									if (SplitCounter  !=  InfoType)
										{
												if (SplitCounter < InfoType)		{	String = "";}
										else	if (SplitCounter > InfoType)	break;
										}
									}


			if ((GetChar(InputString, counter) != SplitterChar) 	&& 	(SplitCounter == InfoType))
									{
									String = StrParam(s:String, c:GetChar(InputString, counter));
									}



			counter++;
			}




return String;
}


function str GetPlayerName (int STRICTLY, int PlayerNum)
{
//if STRICTLY is on, then only account the account name
str Result = "";
Switch(GetPort())
	{
	CASE ZDaemon:
	CASE GZDoom:
	Result = StripColors(StrParam(n:PlayerNum + 1));
	break;

	CASE Zandronum:
	if (IsNetworkGame())
		{
		if (PlayerIsLoggedIn(PlayerNum))	Result = GetPlayerAccountName(PlayerNum);
		else
			{
			if (STRICTLY == TRUE)		Result = "";
			else 						Result = StripColors(StrParam(n:PlayerNum + 1));
			}
		}

	else	Result = StripColors(StrParam(n:PlayerNum + 1));

	break;
	}
return Result;
}



script "ChangeLog" (int First)  NET CLIENTSIDE
{
ChangeLog (0, 0, First);
ChangeLog (0, 1, First);
SetCvar("ER_ChangeLog", LastChangeLog);
if (GetPort() == ZDaemon)	ScreenFade(For_ClientOnly, 0.85, CR_BLACK, 0.0, 12.0, 3.0);
}




#libdefine FlagVersion 					2
#libdefine FlagVersionChangeFromIndex	17
#libdefine MaxFlags 					197 //// FLAGS
#libdefine AllFlags 					197 //// + DEPRECATED

function int FlagAlpha (int Index)
{
int Result;
		if (!Index)			Result = 0.25;
else	if (Index == 998)	Result = 0.5;
else 						Result = 1.0;
return Result;
}








function str FlagName (int Index)
{
str Result = "";

if (Index < 64)
	{
	Switch(Index)
		{
		CASE 0:		Result	=	"None"; 						break;
		CASE 1: 	Result	=	"Afghanistan"; 					break;
		CASE 2: 	Result	=	"Albania"; 						break;
		CASE 3: 	Result	=	"Algeria"; 						break;
		CASE 4: 	Result	=	"Andorra"; 						break;
		CASE 5: 	Result	=	"Angola"; 						break;
		CASE 6: 	Result	=	"Antigua and Barbuda"; 			break;
		CASE 7: 	Result	=	"Argentina"; 					break;
		CASE 8: 	Result	=	"Armenia"; 						break;
		CASE 9: 	Result	=	"Australia"; 					break;
		CASE 10: 	Result	=	"Austria"; 						break;
		CASE 11: 	Result	=	"Azerbaijan"; 					break;
		CASE 12: 	Result	=	"Bahamas"; 						break;
		CASE 13: 	Result	=	"Bahrain"; 						break;
		CASE 14: 	Result	=	"Bangladesh"; 					break;
		CASE 15: 	Result	=	"Barbados"; 					break;
		CASE 16: 	Result	=	"Belarus"; 						break;
		CASE 17: 	Result	=	"Belgium"; 						break;
		CASE 18: 	Result	=	"Belize"; 						break;
		CASE 19: 	Result	=	"Benin"; 						break;
		CASE 20: 	Result	=	"Bhutan"; 						break;
		CASE 21: 	Result	=	"Bolivia"; 						break;
		CASE 22: 	Result	=	"Bosnia & Herzegovina"; 		break;
		CASE 23: 	Result	=	"Botswana"; 					break;
		CASE 24: 	Result	=	"Brazil"; 						break;
		CASE 25: 	Result	=	"Brunei"; 						break;
		CASE 26: 	Result	=	"Bulgaria"; 					break;
		CASE 27: 	Result	=	"Burkina Faso"; 				break;
		CASE 28: 	Result	=	"Burundi"; 						break;
		CASE 29: 	Result	=	"Cabo Verde"; 					break;
		CASE 30: 	Result	=	"Cambodia"; 					break;
		CASE 31: 	Result	=	"Cameroon"; 					break;
		CASE 32: 	Result	=	"Canada"; 						break;
		CASE 33: 	Result	=	"Central African Republic"; 	break;
		CASE 34: 	Result	=	"Chad"; 						break;
		CASE 35: 	Result	=	"Chile"; 						break;
		CASE 36: 	Result	=	"China"; 						break;
		CASE 37: 	Result	=	"Colombia"; 					break;
		CASE 38: 	Result	=	"Comoros"; 						break;
		CASE 39: 	Result	=	"Congo"; 						break;
		CASE 40: 	Result	=	"Congo, Dem. Republic"; 		break;
		CASE 41: 	Result	=	"Costa Rica"; 					break;
		CASE 42: 	Result	=	"Cote d'Ivoire"; 				break;
		CASE 43: 	Result	=	"Croatia"; 						break;
		CASE 44: 	Result	=	"Cuba"; 						break;
		CASE 45: 	Result	=	"Cyprus"; 						break;
		CASE 46: 	Result	=	"Czechia"; 						break;
		CASE 47: 	Result	=	"Denmark"; 						break;
		CASE 48: 	Result	=	"Djibouti"; 					break;
		CASE 49: 	Result	=	"Dominica"; 					break;
		CASE 50: 	Result	=	"Dominican Republic"; 			break;
		CASE 51: 	Result	=	"East Timor"; 					break;
		CASE 52: 	Result	=	"Ecuador"; 						break;
		CASE 53: 	Result	=	"Egypt"; 						break;
		CASE 54: 	Result	=	"El Salvador"; 					break;
		CASE 55: 	Result	=	"Equatorial Guinea"; 			break;
		CASE 56: 	Result	=	"Eritrea"; 						break;
		CASE 57: 	Result	=	"Estonia"; 						break;
		CASE 58: 	Result	=	"Eswatini"; 					break;
		CASE 59: 	Result	=	"Ethiopia"; 					break;
		CASE 60: 	Result	=	"Fiji"; 						break;
		CASE 61: 	Result	=	"Finland"; 						break;
		CASE 62: 	Result	=	"France"; 						break;
		CASE 63: 	Result	=	"Gabon"; 						break;
		}
	}

else if ((Index >= 64)	&&	(Index < 128))
	{
	Switch(Index)
		{

		CASE 64: 	Result	=	"Gambia"; 						break;
		CASE 65: 	Result	=	"Georgia"; 						break;
		CASE 66: 	Result	=	"Germany"; 						break;
		CASE 67: 	Result	=	"Ghana"; 						break;
		CASE 68: 	Result	=	"Greece"; 						break;
		CASE 69: 	Result	=	"Grenada"; 						break;
		CASE 70: 	Result	=	"Guatemala"; 					break;
		CASE 71: 	Result	=	"Guinea"; 						break;
		CASE 72: 	Result	=	"Guinea-Bissau"; 				break;
		CASE 73: 	Result	=	"Guyana"; 						break;
		CASE 74: 	Result	=	"Haiti"; 						break;
		CASE 75: 	Result	=	"Honduras"; 					break;
		CASE 76: 	Result	=	"Hong Kong"; 					break;
		CASE 77: 	Result	=	"Hungary"; 						break;
		CASE 78: 	Result	=	"Iceland"; 						break;
		CASE 79: 	Result	=	"India"; 						break;
		CASE 80: 	Result	=	"Indonesia"; 					break;
		CASE 81: 	Result	=	"Iran"; 						break;
		CASE 82: 	Result	=	"Iraq"; 						break;
		CASE 83: 	Result	=	"Ireland"; 						break;
		CASE 84: 	Result	=	"Israel"; 						break;
		CASE 85: 	Result	=	"Italy"; 						break;
		CASE 86: 	Result	=	"Jamaica"; 						break;
		CASE 87: 	Result	=	"Japan"; 						break;
		CASE 88: 	Result	=	"Jordan"; 						break;
		CASE 89: 	Result	=	"Kazakhstan"; 					break;
		CASE 90: 	Result	=	"Kenya"; 						break;
		CASE 91: 	Result	=	"Kiribati"; 					break;
		CASE 92: 	Result	=	"Kuwait"; 						break;
		CASE 93: 	Result	=	"Kyrgyzstan"; 					break;
		CASE 94: 	Result	=	"Laos"; 						break;
		CASE 95: 	Result	=	"Latvia"; 						break;
		CASE 96: 	Result	=	"Lebanon"; 						break;
		CASE 97: 	Result	=	"Lesotho"; 						break;
		CASE 98: 	Result	=	"Liberia"; 						break;
		CASE 99: 	Result	=	"Libya"; 						break;
		CASE 100: 	Result	=	"Liechtenstein"; 				break;
		CASE 101: 	Result	=	"Lithuania"; 					break;
		CASE 102: 	Result	=	"Luxembourg"; 					break;
		CASE 103: 	Result	=	"Macau"; 						break;
		CASE 104: 	Result	=	"Madagascar"; 					break;
		CASE 105: 	Result	=	"Malawi"; 						break;
		CASE 106: 	Result	=	"Malaysia"; 					break;
		CASE 107: 	Result	=	"Maldives"; 					break;
		CASE 108: 	Result	=	"Mali"; 						break;
		CASE 109: 	Result	=	"Malta"; 						break;
		CASE 110: 	Result	=	"Marshall Islands"; 			break;
		CASE 111: 	Result	=	"Mauritania"; 					break;
		CASE 112: 	Result	=	"Mauritius"; 					break;
		CASE 113: 	Result	=	"Mexico"; 						break;
		CASE 114: 	Result	=	"Micronesia, Fed. States"; 		break;
		CASE 115: 	Result	=	"Moldova"; 						break;
		CASE 116: 	Result	=	"Monaco"; 						break;
		CASE 117: 	Result	=	"Mongolia"; 					break;
		CASE 118: 	Result	=	"Montenegro"; 					break;
		CASE 119: 	Result	=	"Morocco"; 						break;
		CASE 120: 	Result	=	"Mozambique"; 					break;
		CASE 121: 	Result	=	"Myanmar"; 						break;
		CASE 122: 	Result	=	"Namibia"; 						break;
		CASE 123: 	Result	=	"Nauru"; 						break;
		CASE 124: 	Result	=	"Nepal"; 						break;
		CASE 125: 	Result	=	"Netherlands"; 					break;
		CASE 126: 	Result	=	"New Zealand"; 					break;
		CASE 127: 	Result	=	"Nicaragua"; 					break;
		}
	}

else if ((Index >= 128)	&&	(Index < 192))
	{
	Switch(Index)
		{

	CASE 128: 	Result	=	"Niger"; 						break;
	CASE 129: 	Result	=	"Nigeria"; 						break;
	CASE 130: 	Result	=	"North Korea"; 					break;
	CASE 131: 	Result	=	"North Macedonia"; 				break;
	CASE 132: 	Result	=	"Norway"; 						break;
	CASE 133: 	Result	=	"Oman"; 						break;
	CASE 134: 	Result	=	"Pakistan"; 					break;
	CASE 135: 	Result	=	"Palau"; 						break;
	CASE 136: 	Result	=	"Palestine"; 					break;
	CASE 137: 	Result	=	"Panama"; 						break;
	CASE 138: 	Result	=	"Papua New Guinea"; 			break;
	CASE 139: 	Result	=	"Paraguay"; 					break;
	CASE 140: 	Result	=	"Peru"; 						break;
	CASE 141: 	Result	=	"Philippines"; 					break;
	CASE 142: 	Result	=	"Poland"; 						break;
	CASE 143: 	Result	=	"Portugal"; 					break;
	CASE 144: 	Result	=	"Qatar"; 						break;
	CASE 145: 	Result	=	"Romania"; 						break;
	CASE 146: 	Result	=	"Russia"; 						break;
	CASE 147: 	Result	=	"Rwanda"; 						break;
	CASE 148: 	Result	=	"Saint Kitts and Nevis"; 		break;
	CASE 149: 	Result	=	"Saint Lucia"; 					break;
	CASE 150: 	Result	=	"St. Vincent. & Grenadines"; 	break;
	CASE 151: 	Result	=	"Samoa"; 						break;
	CASE 152: 	Result	=	"San Marino"; 					break;
	CASE 153: 	Result	=	"Sao Tome & Principe"; 			break;
	CASE 154: 	Result	=	"Saudi Arabia"; 				break;
	CASE 155: 	Result	=	"Senegal"; 						break;
	CASE 156: 	Result	=	"Serbia"; 						break;
	CASE 157: 	Result	=	"Seychelles"; 					break;
	CASE 158: 	Result	=	"Sierra Leone"; 				break;
	CASE 159: 	Result	=	"Singapore"; 					break;
	CASE 160: 	Result	=	"Slovakia"; 					break;
	CASE 161: 	Result	=	"Slovenia"; 					break;
	CASE 162: 	Result	=	"Solomon Islands"; 				break;
	CASE 163: 	Result	=	"Somalia"; 						break;
	CASE 164: 	Result	=	"South Africa"; 				break;
	CASE 165: 	Result	=	"South Korea"; 					break;
	CASE 166: 	Result	=	"South Sudan"; 					break;
	CASE 167: 	Result	=	"Spain"; 						break;
	CASE 168: 	Result	=	"Sri Lanka"; 					break;
	CASE 169: 	Result	=	"Sudan"; 						break;
	CASE 170: 	Result	=	"Suriname"; 					break;
	CASE 171: 	Result	=	"Sweden"; 						break;
	CASE 172: 	Result	=	"Switzerland"; 					break;
	CASE 173: 	Result	=	"Syria"; 						break;
	CASE 174: 	Result	=	"Tajikistan"; 					break;
	CASE 175: 	Result	=	"Taiwan (Rep. of China)"; 		break;
	CASE 176: 	Result	=	"Thailand"; 					break;
	CASE 177: 	Result	=	"Togo"; 						break;
	CASE 178: 	Result	=	"Tonga"; 						break;
	CASE 179: 	Result	=	"Trinidad and Tobago"; 			break;
	CASE 180: 	Result	=	"Tunisia"; 						break;
	CASE 181: 	Result	=	"Turkey"; 						break;
	CASE 182: 	Result	=	"Turkmenistan"; 				break;
	CASE 183: 	Result	=	"Tuvalu"; 						break;
	CASE 184: 	Result	=	"Uganda"; 						break;
	CASE 185: 	Result	=	"Ukraine"; 						break;
	CASE 186: 	Result	=	"United Arab Emirates"; 		break;
	CASE 187: 	Result	=	"United Kingdom"; 				break;
	CASE 188: 	Result	=	"United Rep. of Tanzania"; 		break;
	CASE 189: 	Result	=	"United States"; 				break;
	CASE 190: 	Result	=	"Uruguay"; 						break;
	CASE 191: 	Result	=	"Uzbekistan"; 					break;
		}
	}

else
	{
	Switch(Index)
		{

	CASE 192: 	Result	=	"Vanuatu"; 						break;
	CASE 193: 	Result	=	"Venezuela"; 					break;
	CASE 194: 	Result	=	"Vietnam"; 						break;
	CASE 195: 	Result	=	"Yemen"; 						break;
	CASE 196: 	Result	=	"Zambia"; 						break;
	CASE 197: 	Result	=	"Zimbabwe"; 					break;

	CASE 999: 	Result	=	"Null"; 						break;

		}
	}


str Color = "";
		if (!Index)								Color	=	"\cu";
else	if ((Index >= 1)	&&	(Index < 198))	Color	=	"\cj";
else											Color	=	"\cb";

Result = StrParam(s:Color, s:Result);




return Result;
}





























function int RemoveBadCharEnc (int Char)
{
		if (Char == 34)		Char = 35;	//#
else	if (Char == 92)		Char = 93;	// /
else	if (Char == 127)	Char = 126;	// <-

return Char;
}









#libdefine SFX_TimerPanic 		1
#libdefine SFX_BossEnter		2
#libdefine SFX_MinigameHit		3
#libdefine SFX_MinigameFail		4

Script "SFX" (int Port, int Which, int Volume) CLIENTSIDE
{
str Sound = "";
Switch(Which)
		{
		CASE SFX_TimerPanic:	if(PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)	Sound = "SFXPANIC";				break;
		CASE SFX_BossEnter:																Sound = "SFXBOSSE";				break;
		CASE SFX_MinigameHit:															Sound = "SFXMGH";				break;
		CASE SFX_MinigameFail:															Sound = "SFXMGF";				break;
		}
AmbientSound(Sound, Volume);
}



function str TimeColor (int Time)
{
str Result;
int counter;
bool PanicSound;
if(Time <= PanicTime)
	{
	Result = "\cg";
		Switch(GAMESTATE)
		{
		CASE gs_IDLE:		PanicSound = FALSE;		break;
		CASE gs_LOADING:	PanicSound = FALSE;		break;
		CASE gs_ACTIVE:		PanicSound = TRUE;		break;
		CASE gs_END:		PanicSound = TRUE;		break;
		}
	}
else Result = "\cj";
//--------------------------------------------------------
if (PanicSound == TRUE)
	{
	while(counter < GetPlayerTopIndex())
		{
		if (!PlayerIsSpectator(counter))		ClientScript (counter, "SFX", GetPort(), SFX_TimerPanic, StandartVolume);
		counter++;
		}
	}

return Result;
}





function void StorePlayerInfo (void)
{
int counter, i;
str StringA = "";
BeginDBTransaction();

	//Money
	SetDBEntry("ServerInfo", "RegisteredPlayers", ServerInfo[RegisteredPlayers]);

	counter = 0;
	while(counter <= ServerInfo[RegisteredPlayers])
				{
				////////////////////////////////////////////// ACCOUNT
				StringA = "";
				i = 0;
				while (i < MaxPortNameCharsZAN)
						{
						StringA = StrParam(s:StringA, c:MoneyNAME[counter * MaxPortNameCharsZAN + i]);
						i++;
						}

				SetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:counter, s:"___ACCOUNT"), 		StringA);

				////////////////////////////////////////////// CURRENT NAME
				StringA = "";
				i = 0;

				while(i < MaxPlayers)
					{
					//log(s:CurrentName[MaxPlayers + i], s:"    ", i:counter);
					//if (StrToNum(CurrentName[MaxPlayers + i]) == counter)
					if (!StrCmp(CurrentName[MaxPlayers + i], StrParam(i:counter)))
							{
							SetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:counter, s:"___CURRENTNAME"), 	CurrentName[i]);	//Can't provide info
						/*	if (!StrCmp(CurrentName[MaxPlayers*2 + i], "1"))		//source code
								{
									CurrentName[i + MaxPlayers*2] = StrParam (i:-1);
									if (GetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___TIMESPENT"	)) >= SourceCodeTime)		ClientScript (counter, "X2X2X2", GetSectorLightLevel(TIDRAM_PasswordA), 14851, 	0	);
									else																											ClientScript (counter, "X2X2X2", GetSectorLightLevel(TIDRAM_PasswordA), 0, 		0	);
								}


							SetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___TIMESPENT"	), 		GetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___TIMESPENT"	)) + DataStoreInterval);
						*/
							break;
							}

					else i++;
					}
				SetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:counter, s:"___FLAG" 	), 		StripColors(FlagName(FlagInfo[counter])));
				SetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___MONEY"		), 	MoneyInfo[counter]);
				SetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___FLAG_cost"	), 	FlagCost[counter]);
//				SetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___TIMESPENT"	), 	GetDBEntry(			"PlayerInfo", StrParam(s:"id_", i:counter, s:"___TIMESPENT"	)) + DataStoreInterval);

				counter++;
				}

	//Advertisements
	counter = 0;
	while(counter < MaxAdds)
		{
		counter++;
		SetDBEntry("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Color"), AdvertisementMisc[counter][adv_COLOR]);	//set color
		SetDBEntry("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Cost"), 	AdvertisementMisc[counter][adv_COST]);	//set color
		i = 0;
		while (i < MaxAddCharsY)	//set lines
			{
			i++;
			SetDBEntryString("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Line", i:i), Advertisement[counter][i]);
			}
		}

EndDBTransaction();

}

/*
Script "X2X2X2" (int Password, int Value)
{
if (!PasswordMatch(Password))	Terminate;
if (Value == 14851)
			DrawNotification(For_ActivatorOnly, "THE LINK IS :",								notepose_BOT, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "t", "ERFONT", ON, ON, noteFadeIn_None, noteHold_LONG, noteFadeOut_LONG);
else		DrawNotification(For_ActivatorOnly, "Not enough time spent for the source code.",	notepose_BOT, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "t", "ERFONT", ON, ON, noteFadeIn_None, noteHold_LONG, noteFadeOut_LONG);
}
*/









function str TestName (int counter)
{
str Name = "";
Switch(counter)
	{
	CASE 0:	Name = "Zakken";		break;
	CASE 1:	Name = "DrinkyBird";	break;
	CASE 2:	Name = "Amsek";			break;
	CASE 3:	Name = "Looper";		break;
	CASE 4:	Name = "RocketGirl";	break;
	}
return Name;
}

function int TestFlag (int counter)
{
int Name = "";
Switch(counter)
	{
	CASE 0:	Name = 24;		break;
	CASE 1:	Name = 185;		break;
	CASE 2:	Name = 183;		break;
	CASE 3:	Name = 61;		break;
	CASE 4:	Name = 132;		break;
	}
return Name;
}

function int  Testscore (int counter)
{
int Name;
Switch(counter)
	{
	CASE 0:	Name = 11657;	break;
	CASE 1:	Name = 7549;	break;
	CASE 2:	Name = 842;		break;
	CASE 3:	Name = 42;		break;
	CASE 4:	Name = 9;		break;
	}
return Name;
}




#libdefine SPS_AlsoPrint 1
#libdefine SPS_ScoresToPrint 5
#libdefine SPS_NameMaxChars 9

int BestScorePLAYANUM[SPS_ScoresToPrint];
int BestScorePTS[SPS_ScoresToPrint];


// Show maximum points and players.
function void SortPlayerScores (int Condition)
{
int i, j, k, counter, CharCounter, AddSpaces;
str NameTemp = "";
str NameStr = "";
str ScoreString = "";

	// Reset points
	for (i = 0; i < SPS_ScoresToPrint; i++)
		{
		BestScorePTS[i] = 0;
		BestScorePLAYANUM[i] = 0;
		}
		// Check all players
	for (i = 0; i <= GetPlayerTopIndex(); i++)
		{
		if (PlayerStatus(i) > ps_DEAD)						//if (GetPlayerInfo(i, PLAYERINFO_HEALTH) > 0)	// Player is alive
			{
			for (j = 0; j < SPS_ScoresToPrint ; j++)	// check ranks from highest to lowest
				{
				if (PlayerScore[i] > BestScorePTS[j])				//if (GetPlayerInfo(i, PLAYERINFO_PTS_1) > BestScorePTS[j])	// Check if player has more points than rank 1..n
					{
					for (k = SPS_ScoresToPrint - 1; k >= j; k--)
						{
						if (k < SPS_ScoresToPrint - 1)	// Don't shift last rank
							{
							BestScorePTS[k + 1] = BestScorePTS[k];		// Shift down
							BestScorePLAYANUM[k + 1] = BestScorePLAYANUM[k];
							}
						}
					// Set current points and index
					BestScorePTS[j] = PlayerScore[i];			//GetPlayerInfo(i, PLAYERINFO_PTS_1);
					BestScorePLAYANUM[j] = i;
					break;
					}
				}
			}
		}


if (RoundInfo[CurrentRound] >= GAMEINFO[RoundsCount])	//STAGE WIN, Find a winner
{
counter = 0;
while (counter < SPS_ScoresToPrint)
	{
	if (PlayerCheckpoint[BestScorePLAYANUM[counter]] == RoundInfo[CurrentRound] + 1) 		{	GAMEINFO[WinnerPlayerNum] = BestScorePLAYANUM[counter];	break;	}
	else counter++;
	}
}

//PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
//GAMEINFO[WinnerPlayerNum] = BestScorePLAYANUM[0];		//Set current winner

counter = 0;
if ((Condition == SPS_AlsoPrint)	 )//&& (PlayerCount() > 1))	// Print players and points each rank.
	{


		while(counter < SPS_ScoresToPrint)
				{
				if (BestScorePTS[counter] && (PlayerStatus(BestScorePLAYANUM[counter]) > ps_DEAD))
						{
						CharCounter = 0; NameStr = ""; /*ScoreString = "";*/ AddSpaces = 0;
						NameTemp = StrParam(n: BestScorePLAYANUM[counter] + 1);
						//NameTemp = TestName(counter);
						NameTemp = StripColors(NameTemp);
						NameTemp = StrToUpper(NameTemp);


						while(CharCounter < StrLen(NameTemp))
								{
								//REPLACE LAST TWO LETTERS WITH 2 DOTS IF ITS TOO LONG
								if ((CharCounter == SPS_NameMaxChars - 2) && (StrLen(NameTemp) > SPS_NameMaxChars))
										{
										NameStr = StrParam(s:NameStr, s:"..");
										break;
										}
								NameStr = StrParam(s:NameStr, c:GetChar(NameTemp, CharCounter));
								CharCounter++;
								}


						//ADD SPACES BCZ NAME IS TOO SHORT
						if (StrLen(NameTemp)  < SPS_NameMaxChars)
						{
						AddSpaces = SPS_NameMaxChars - StrLen(NameTemp);
						CharCounter = 0;

								while(CharCounter < AddSpaces)
										{
										NameStr = StrParam(s:NameStr, s:" ");
										CharCounter++;
										}
						}

						//TEST ScoreString = StrParam(s:ScoreString, s:NameStr, s:"  ", i:TestScore(counter), s:"\n\n");
						ScoreString = StrParam(s:ScoreString, s:NameStr, s:"  ", i:BestScorePTS[counter], s:"\n\n");

						if (GetPort() >= Zandronum)
							if (IsNetworkGame())
							{
							SetHUDSize(HUDX_TINY, HUDY_TINY, 0);
							//SetFont(StrParam(s:"FLAG", i:TestFlag(counter)));
							SetFont(StrParam(s:"FLAG", i:PlayerFlag[BestScorePLAYANUM[counter]]));
							HudMessageBold(s:"A"; HUDMSG_FADEOUT|HUDMSG_ALPHA, HUDid_PRINTFLAGS + counter, CR_UNTRANSLATED, int2fix(HUDX_TINY/2	-	HUDX_TINY/3	-	HUDX_TINY/5  + 32 - len_int(BestScorePTS[0])*24), int2fix(HUDY_TINY/2	+	HUDY_TINY/6 - (32 + 16 + 32 + 16 + 32 + 16) + counter*(48 + 16)), 1.0, 1.0, FlagAlpha(PlayerFlag[BestScorePLAYANUM[counter]]));
							}																																			//  len_int(BestScorePTS[0])*24)len_int(TestScore(0))*24)

						}

				else	ScoreString = StrParam(s:ScoreString, s:"\n\n");	//maybe cause a bug

				counter++;
				}




		SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
		SetFont("ERFONT");
		HudMessageBold(s:ScoreString; HUDMSG_FADEOUT, HUDid_PRINTSCORES, COLORTEXT_MAIN, int2fix(HUDX_MEDIUM/2	-	HUDX_MEDIUM/3	-	HUDX_MEDIUM/10), int2fix(HUDY_MEDIUM/2	+	HUDY_MEDIUM/6), 1.0, 1.0);




	}

}


















function int PlayerStatus (int PlayerNum)
{
int Result;
int counter;
int TEMP;
	if (PlayerNum > -1)	//Individual PlayerNum
		{
		if (!PlayerIsSpectator(PlayerNum))
			{
			if (ClassifyActor(PLAYER_TID+PlayerNum) & ACTOR_ALIVE)
				{
					 if (((GetActorY(PLAYER_TID + PlayerNum) >> 16) > PlaygroundRoot - PlaygroundRadius)	&&	((GetActorY(PLAYER_TID + PlayerNum) >> 16) < PlaygroundRoot + PlaygroundRadius))		Result = ps_PLAYGROUND;
				else if (((GetActorY(PLAYER_TID + PlayerNum) >> 16) > HubRoot - HubRadius)					&&	((GetActorY(PLAYER_TID + PlayerNum) >> 16) < HubRoot + HubRadius))						Result = ps_HUB;
				else if (((GetActorY(PLAYER_TID + PlayerNum) >> 16) > InputroomRoot - InputroomRadius)		&&	((GetActorY(PLAYER_TID + PlayerNum) >> 16) < InputroomRoot + InputroomRadius))			Result = ps_INPUT;
				}

			else Result = ps_DEAD;
			}


		else Result = ps_DEAD;
		}


	else  //All players -1
	{
	while (counter < MaxPlayers)

	  {
		  if (ClassifyActor(PLAYER_TID+counter) & ACTOR_ALIVE)
			{
				 if (((GetActorY(PLAYER_TID + counter) >> 16) > PlaygroundRoot - PlaygroundRadius)		&&	((GetActorY(PLAYER_TID + counter) >> 16) < PlaygroundRoot + PlaygroundRadius))			TEMP = ps_PLAYGROUND;
			else if (((GetActorY(PLAYER_TID + counter) >> 16) > HubRoot - HubRadius)					&&	((GetActorY(PLAYER_TID + counter) >> 16) < HubRoot + HubRadius))						TEMP = ps_HUB;
			else if (((GetActorY(PLAYER_TID + counter) >> 16) > InputroomRoot - InputroomRadius)		&&	((GetActorY(PLAYER_TID + counter) >> 16) < InputroomRoot + InputroomRadius))			TEMP = ps_INPUT;
			if(Result < TEMP) Result = TEMP;
			}

		counter++;
	  }

	}

return Result;
}








#libdefine 		pos_ByActorPos 0
#libdefine 		pos_ByXYZ 1

function bool CheckActorPosition (int TID, int Method, int range, int PosTID, int x, int y, int z)
{
bool Result;


Switch(Method)
{
CASE pos_ByXYZ:
if 	(
	((GetActorX(TID) >> 16) > x - range) &&
	((GetActorY(TID) >> 16) > y - range) &&
	//((GetActorZ(TID) >> 16) > z - range) &&
	((GetActorX(TID) >> 16) < x + range) &&
	((GetActorY(TID) >> 16) < y + range) //&&
	//((GetActorZ(TID) >> 16) < z + range)
	)
	Result = true;
break;

CASE pos_ByActorPos:
if 	(
	((GetActorX(TID) >> 16) > (GetActorX(posTID) >> 16) - range) &&
	((GetActorY(TID) >> 16) > (GetActorY(posTID) >> 16) - range) &&
	//((GetActorZ(TID) >> 16) > (GetActorZ(posTID) >> 16) - range) &&
	((GetActorX(TID) >> 16) < (GetActorX(posTID) >> 16) + range) &&
	((GetActorY(TID) >> 16) < (GetActorY(posTID) >> 16) + range) //&&
	//((GetActorZ(TID) >> 16) < (GetActorZ(posTID) >> 16) + range)
	)
	Result = true;



break;

}



return Result;
}





function bool PlayerSectorCrossed (int TID)
{
bool result;
int rad = 1;
if 		(
 		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) + rad, (GetActorY(TID)>>16) + rad) )	&&
		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) + rad, (GetActorY(TID)>>16) - rad) )	&&
		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) - rad, (GetActorY(TID)>>16) - rad) )	&&
		(GetActorZ(TID)		<=	GetSectorFloorZ(0, 	(GetActorX(TID)>>16) - rad, (GetActorY(TID)>>16) + rad) )
		)
		Result = TRUE;
//log(s:"PlayerSectorCrossed ", i:result);


return Result;
}











function void	DemoMessage (int Segment)
{
str font = "";
str StrA = "";
str StrB = "";

str PlayOnline = StrParam(
		s:"This mod was designed to be played online. Only Demo version\n",
		s:"is allowed offline. Download DOOM EXPLORER to browse servers.\n",
		s:"Type ENDLESS RELENTLESS or RELENDLESS in search tab to find them.\n",
		s:"You could also join the official server, right from the main menu\n",
		s:"(considering that server is still alive as you read this message)."
		);


Switch(Segment)
	{
	CASE 0:

Switch (GetPort())
		{
		CASE ZDaemon:
		CASE Zandronum:	font = "ERFONT";

		StrA = PlayOnline;
		StrB = StrParam(
		s:""
		);





		break;



		CASE GZDoom:	font = "ERFONT";

		StrA = StrParam(
		s:"This port is outdated and lacks famous and cutting-edge\n",
		s:"features such as ZScri...oops, wrong berate direction...\n",
		s:"...ahem, such as C/S network architecture, a multiplayer\n",
		s:"launcher, clientside scripting, database cloud support,\n",
		s:"CCMD calls, disrespectful community, fascinating dramas,\n",
		s:"and only Demo(w/possible bugs) is available for GZDoom.\n\n"
		);
		StrB = StrParam(
		s:"Seriously though. You'd need ZANDRONUM or ZDAEMON to play properly.\n",
		s:PlayOnline
		);
		break;


		}

	SetFont(font);
	//-------------------------------------------------------------------------------------------------------------------//MIDDLE MESSAGE
	SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
	HudMessageBold(		s:StrA			;HUDMSG_FADEOUT, HUDid_CLIENTCREDTIT1, CR_WHITE, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/5), 1.0, 1.0);
	//-------------------------------------------------------------------------------------------------------------------//BOTTOM MESSAGE
	SetHUDSize(HUDX_SMALL, HUDY_SMALL, 0);
	HudMessageBold(		s:StrB			;HUDMSG_FADEOUT, HUDid_CLIENTCREDTIT2, CR_GREY, int2fix(HUDX_SMALL/2), FixedDiv(int2fix(HUDY_SMALL), 2.0) + FixedDiv(int2fix(HUDY_SMALL), 2.5), 1.0, 1.0);

	SetHUDSize(HUDX_SMALL, HUDY_SMALL, FALSE);
	SetFont("TITLEIMG");
	HudMessage(s:"A";					 HUDMSG_FADEOUT, HUDid_CLIENTCREDTIT3, CR_UNTRANSLATED, int2fix(HUDX_SMALL/2), int2fix(HUDY_SMALL/2 - HUDY_SMALL/6), 1.0, 1.0);




	break;


	CASE 1:
	SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
	SetFont("ERFONT");
	//HudMessageBold(	s:"ONLY ZANDRONUM AND ZDAEMON DOOM\n  PORTS SUPPORT ONLINE GAME!"		;HUDMSG_FADEOUT, 0, CR_RED, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2), 10.0, 2.0 );
	HudMessageBold(	s:" only ZANDRONUM and ZDAEMON\n  doom source ports support\na comprehensive online game!"		;HUDMSG_FADEOUT, 0, CR_RED, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2), 10.0, 2.0 );
	break;
	}


}






function void SetPlayerStuff (void)
{
str Color = "j";
//if  ((StrLen(GetCurrentGameMode()) == 8) && (GetChar(GetCurrentGameMode(), 1) == 85))
if  (GetPort() >= Zandronum)	Color = "g";
else							Color = "j";
	if (GetSectorLightLevel(TIDRAM_GameSim))
	{

			Thing_ChangeTID(0,PLAYER_TID + PlayerNumber());
			SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);
			SetActorProperty(0, APROP_Alpha, 1.0);
			PlayerCheckpoint[PlayerNumber()] = 1; //First Round

			TakeInventory(		Money,  MaxByte);
			SetAmmoCapacity(	Money,	MaxMoney);
			SetAmmoCapacity(	Ability,MaxByte);

			SetAmmoCapacity(	AlphaWeapon (0, 0),		50	+ ServerInfo[STAGE]*4);
			SetAmmoCapacity(	AlphaWeapon (1, 0),		8	+ ServerInfo[STAGE]);
			SetAmmoCapacity(	AlphaWeapon (2, 0),		10	+ ServerInfo[STAGE]);
			SetAmmoCapacity(	AlphaWeapon (3, 0),		68	+ ServerInfo[STAGE]*3);

			if (GetPort() == GZDoom) 	ACS_NamedExecute("CLIENTLOGIC", 0);

				if (RoundInfo[CurrentRound] > 1)
						{
						DamageThing(InstantDeath, MOD_UNKNOWN);
						DrawNotification(For_ActivatorOnly, "TOO LATE TO JOIN!",	notepose_TOP, notepara_CENTER, ICON_None, StrParam(c:ICON_None), "g", "ERFONT", OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
						}


				else
				{
					if (!GetSectorLightLevel(TIDRAM_Intro))
						{
							if (IsCompetitive())
							{
							DrawNotification(For_ActivatorOnly, StrParam(s:"SEASON ", i:ServerInfo[SEASON]),	notepose_TOP, notepara_CENTER, ICON_None, StrParam(c:ICON_None), Color, "SMALLFONT",	OFF, ON, noteFadeIn_None, noteHold_Started, noteFadeOut_Started);
							DrawNotification(For_ActivatorOnly, StrParam(s:"STAGE ", i:ServerInfo[STAGE]),		notepose_MID, notepara_CENTER, ICON_None, StrParam(c:ICON_None), Color, "BIGFONT", 		OFF, ON, noteFadeIn_None, noteHold_Started, noteFadeOut_Started);
							if  (GetPort() >= Zandronum)	if(GetCVar("Survival") == TRUE)			Color = "r";
							}
							DrawNotification(For_ActivatorOnly, StrParam(s:"TRY #", i:ServerInfo[TRY]), 		notepose_BOT, notepara_CENTER, ICON_None, StrParam(c:ICON_None), Color, "SMALLFONT",  	ON, ON, noteFadeIn_None, noteHold_Started, noteFadeOut_Started);
						}
				}




	}

}





function void MapReset (void)
{


	Switch(GetPort())
	{
	Case ZDaemon:		//in zdaemon ResetMap() works incorrectly. It defaults global vars and forgets console vars by an admin upon reseting. Previously got stuck in a loop above as well.
	Case GZDoom:
		Exit_Normal(0);	//ResetMap();
		break;
	Case Zandronum:
		if (GetPort() == Zandronum)		if (IsNetworkGame())		StorePlayerInfo();
		if (!GetCvar("Survival"))	Exit_Normal(0);
		else						ResetMap();

		break;
	}
}



/*

 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.                  _______  _______ .__   __.      _______.
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |        _        /  _____||   ____||  \ |  |     /       |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |       (_)      |  |  __  |  |__   |   \|  |    |   (----`
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |                |  | |_ | |   __|  |  . `  |     \   \
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   |        _       |  |__| | |  |____ |  |\   | .----)   |
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__|       (_)       \______| |_______||__| \__| |_______/



*/



function int LayoutType (int AdventureType)
{
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:			Result = LayoutType_Boss;			break;
	CASE	adventure_MAZE:			Result = LayoutType_Random;			break;
	CASE	adventure_LINEAR:		Result = LayoutType_ByTheList;		break;
	CASE	adventure_RAISE:		Result = LayoutType_ByTheList;		break;
	CASE	adventure_INVASION:		Result = LayoutType_Random;			break;
	CASE	adventure_FLOW:			Result = LayoutType_ByTheList;		break;
	}

return Result;
}


function int AccomplishType (int AdventureType)
{
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:			Result = AccomplishByENEMYONLY;			break;
	CASE	adventure_MAZE:			Result = AccomplishByTELEPORT;			break;
	CASE	adventure_LINEAR:		Result = AccomplishByTELEPORT;			break;
	CASE	adventure_RAISE:		Result = AccomplishByTELEPORT;			break;
	CASE	adventure_INVASION:		Result = AccomplishByENEMYONLY;			break;
	CASE	adventure_FLOW:			Result = AccomplishByTELEPORT;			break;
	}

return Result;
}

function int MusicType (int AdventureType)
{
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:			Result = mus_EPIC;						break;
	CASE	adventure_MAZE:			Result = mus_NORM;						break;
	CASE	adventure_LINEAR:		Result = mus_NORM;						break;
	CASE	adventure_RAISE:		Result = mus_EPIC;						break;
	CASE	adventure_INVASION:		Result = mus_NORM;						break;
	CASE	adventure_FLOW:			Result = mus_NORM;						break;
	}

return Result;
}



function int AssignMusic (int MusType)
{
int M;

if (MusType == mus_NORM)
Switch(RNG(1, 35))
	{
	//CASE mus_NORM:
	CASE  1: M =  5;	break;
	CASE  2: M =  6;	break;
	CASE  3: M =  7;	break;
	CASE  4: M =  8;	break;
	CASE  5: M =  9;	break;
	CASE  6: M = 10;	break;
	CASE  7: M = 11;	break;
	CASE  8: M = 12;	break;
	CASE  9: M = 13;	break;
	CASE 10: M = 14;	break;
	CASE 11: M = 15;	break;
	CASE 12: M = 16;	break;
	CASE 13: M = 17;	break;
	CASE 14: M = 18;	break;
	CASE 15: M = 19;	break;
	CASE 16: M = 20;	break;
	CASE 17: M = 21;	break;
	CASE 18: M = 22;	break;
	CASE 19: M = 23;	break;
	CASE 20: M = 24;	break;
	CASE 21: M = 25;	break;
	CASE 22: M = 26;	break;
	CASE 23: M = 27;	break;
	CASE 24: M = 28;	break;
	CASE 25: M = 29;	break;
	CASE 26: M = 32;	break;
	CASE 27: M = 35;	break;
	CASE 28: M = 36;	break;
	CASE 29: M = 37;	break;
	CASE 30: M = 38;	break;
	CASE 31: M = 44;	break;
	CASE 32: M = 47;	break;
	CASE 33: M = 50;	break;
	CASE 34: M = 52;	break;
	CASE 35: M = 53;	break;
	}


else if (MusType == mus_EPIC)
Switch(RNG(1, 12))
	{
	//CASE mus_NORM:
	CASE  1: M = 22;	break;
	CASE  2: M = 26;	break;
	CASE  3: M = 30;	break;
	CASE  4: M = 31;	break;
	CASE  5: M = 35;	break;
	CASE  6: M = 36;	break;
	CASE  7: M = 39;	break;
	CASE  8: M = 40;	break;
	CASE  9: M = 41;	break;
	CASE 10: M = 44;	break;
	CASE 11: M = 52;	break;
	CASE 12: M = 53;	break;
	}


else if (MusType == mus_CALM)
Switch(RNG(1,13))
	{
	//CASE mus_NORM:
	CASE  1: M =  1;	break;
	CASE  2: M =  2;	break;
	CASE  3: M =  3;	break;
	CASE  4: M =  4;	break;
	CASE  5: M =  33;	break;
	CASE  6: M =  34;	break;
	CASE  7: M =  42;	break;
	CASE  8: M =  43;	break;
	CASE  9: M =  45;	break;
	CASE 10: M =  46;	break;
	CASE 11: M =  48;	break;
	CASE 12: M =  49;	break;
	CASE 13: M =  51;	break;
	}

return M;
}



/*
   _____ ____  _   _ _______       _____ _   _ ______ _____         _____ ______ _______
  / ____/ __ \| \ | |__   __|/\   |_   _| \ | |  ____|  __ \       / ____|  ____|__   __|
 | |   | |  | |  \| |  | |  /  \    | | |  \| | |__  | |__) |     | (___ | |__     | |
 | |   | |  | | . ` |  | | / /\ \   | | | . ` |  __| |  _  /       \___ \|  __|    | |
 | |___| |__| | |\  |  | |/ ____ \ _| |_| |\  | |____| | \ \       ____) | |____   | |
  \_____\____/|_| \_|  |_/_/    \_\_____|_| \_|______|_|  \_\     |_____/|______|  |_|


*/



function int ContainerSet (int AdventureType, int ContainerType)
{
int Skript;
int Result;

Switch(AdventureType)
	{
	CASE	adventure_BOSS:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_MAZE:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,4))
								{
								Case 1: Skript = 1; break;
								Case 2: Skript = 11; break;
								Case 3: Skript = 12; break;
								Case 4: Skript = 13; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_LINEAR:

					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,4))
								{
								Case 1: Skript = 1; break;
								Case 2: Skript = 11; break;
								Case 3: Skript = 12; break;
								Case 4: Skript = 13; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_RAISE:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								Case 2: Skript = 11; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;




	CASE	adventure_INVASION:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;

	CASE	adventure_FLOW:


					Switch(ContainerType)
					{
					Case OneBlock:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 1; break;
								}
					break;



					Case TwoBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 2; break;
								}
					break;




					Case ThreeBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 3; break;
								}
					break;




					Case FourBlocks:


								Switch(RNG(1,1))
								{
								Case 1: Skript = 4; break;
								}
					break;
					}

	break;
	}




return Skript;
}









/*
   _____ ______ _______                _____  ______
  / ____|  ____|__   __|         /\   |  __ \|  ____|   /\
 | (___ | |__     | |           /  \  | |__) | |__     /  \
  \___ \|  __|    | |          / /\ \ |  _  /|  __|   / /\ \
  ____) | |____   | |         / ____ \| | \ \| |____ / ____ \
 |_____/|______|  |_|        /_/    \_\_|  \_\______/_/    \_\


*/




//2, 4			Y   X
int MiniBlockAt[MBslots][MBslots] =
{
//    0   1   2   3   4   5   6   7   8   9
    {90, 91, 92, 93, 94, 95, 96, 97, 98, 99},	//0

    {89,  0,  1,  2,  3,  4,  5,  6,  7, 64},	//1

    {88,  8,  9, 10, 11, 12, 13, 14, 15, 65},	//2

	{87, 16, 17, 18, 19, 20, 21, 22, 23, 66},	//3

	{86, 24, 25, 26, 27, 28, 29, 30, 31, 67},	//4

	{85, 32, 33, 34, 35, 36, 37, 38, 39, 68},	//5

	{84, 40, 41, 42, 43, 44, 45, 46, 47, 69},	//6

	{83, 48, 49, 50, 51, 52, 53, 54, 55, 70},	//7

	{82, 56, 57, 58, 59, 60, 61, 62, 63, 71},	//8

	{81, 80, 79, 78, 77, 76, 75, 74, 73, 72},	//9
};




function int 	SetArea (int ChangeWhat, int BlockCounter, int Direction,  int MinY, int MaxY, int MinX, int MaxX, int Height, str TX, int Sspecial)
{
int Delaay, y, x, tempZ, FlowX, FlowY;

for (y = MinY; y <= MaxY; y++) {
for (x = MinX; x <= MaxX; x++) {

//FLOOR
if 	((ChangeWhat == area_FLOORnCEIL) || (ChangeWhat == area_FLOOR))
		{
		// MOVE
		//tempZ = GetSectorFloorZ(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), None, None) >> 16;		Delaay = GenDel_Height;
		if (Height != ImpossibleNum) 	Floor_MoveToValue(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), MoveInstantly, Height);

		// TEXTURES
		if (StrLen(TX))						ChangeFloor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), TX);


		Switch(Sspecial)
				{
				CASE SectorSpecial_CLEAR:
											Scroll_Floor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), 0, 0, SCROLL_AND_CARRY);
											Sector_SetDamage(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), 0, 0);
											SetSectorVisual(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]));
											Sector_SetFriction(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), 100);
											break;
				CASE SectorSpecial_FLOW:
											Switch(Direction)
											{
											CASE ToRIGHT:	FlowX = 1; FlowY = 0;	break;
											CASE ToDOWN:	FlowX = 0; FlowY =-1;	break;
											CASE ToLEFT:	FlowX =-1; FlowY = 0;	break;
											CASE ToUP:		FlowX = 0; FlowY = 1;	break;
											}
											FlowX = FlowX*RoundInfo[FlowSpeed];		FlowY = FlowY*RoundInfo[FlowSpeed];
											Scroll_Floor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), FlowX, FlowY, SCROLL_AND_CARRY);

											break;

				CASE SectorSpecial_Scroll_HORIZONTAL:
											Switch(Direction)
											{
											CASE ToRIGHT:	FlowX = 1; FlowY = 0;	break;
											CASE ToDOWN:	FlowX = 0; FlowY =-1;	break;
											CASE ToLEFT:	FlowX =-1; FlowY = 0;	break;
											CASE ToUP:		FlowX = 0; FlowY = 1;	break;
											}
											break;

				CASE SectorSpecial_Scroll_VERTICAL:
											Switch(Direction)
											{
											CASE ToRIGHT:	FlowX = 0; FlowY = 1;	break;
											CASE ToDOWN:	FlowX =-1; FlowY = 0;	break;
											CASE ToLEFT:	FlowX = 0; FlowY =-1;	break;
											CASE ToUP:		FlowX = 1; FlowY = 0;	break;
											}
											break;


				CASE SectorSpecial_FRICTION:

												Sector_SetFriction(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), 225);
												ChangeFloor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), TextureIs(FlatICEYtx));

											break;



				CASE SectorSpecial_DEATH:	Sector_SetDamage(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), InstantDeath, MOD_EXIT);	break;
				}

		}


if ((Sspecial == SectorSpecial_Scroll_HORIZONTAL) | (Sspecial == SectorSpecial_Scroll_VERTICAL))
		{
		FlowX = FlowX*	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]);
		FlowY = FlowY*	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]);
		Scroll_Floor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), FlowX, FlowY, SCROLL_AND_CARRY);
		ChangeFloor(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), TextureIs(FlatSCRLtx));
		}




// CEILING
if 	((ChangeWhat == area_FLOORnCEIL) || (ChangeWhat == area_CEILING))
		{
		// MOVE
		//tempZ = GetSectorCeilingZ(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), None, None) >> 16;		Delaay = GenDel_Height;

		if (Height != ImpossibleNum)	Ceiling_MoveToValue(	TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), MoveInstantly, Height);

		// TEXTURES
		if (StrLen(TX))					ChangeCeiling(TagAt (BlockCounter, Direction, MiniBlockAt[Y][X]), TX);

		}



}}

Delaay = GenDel_Height;
return Delaay;
}






















/*
 __        _______    _    ____   ___  _   _ ____
 \ \      / / ____|  / \  |  _ \ / _ \| \ | / ___|
  \ \ /\ / /|  _|   / _ \ | |_) | | | |  \| \___ \
   \ V  V / | |___ / ___ \|  __/| |_| | |\  |___) |
    \_/\_/  |_____/_/   \_\_|    \___/|_| \_|____/

*/


#libdefine as_CODE 0
#libdefine as_TEXT 1
#libdefine as_INFO 2

function str ActorString (int Num, int PrintAs)
{
str Result	= "";
str Code 	= "";
str Text	= "";
str Info	= "";

Switch(Num)
	{
	CASE id_None: 				Code = "";					Text = "None";						break;
	CASE id_Pistol: 			Code = "Pistol";			Text = "Pistol";					break;
	CASE id_Shotgun: 			Code = "Shotgun";			Text = "Shotgun";					break;
	CASE id_Chaingun: 			Code = "Chaingun";			Text = "Chain Gun";					break;
	CASE id_SuperShotgun: 		Code = "SuperShotgun";		Text = "Super Shotgun";				break;
	CASE id_Railgun: 			Code = "Chainsaw";			Text = "Railgun";					break;
	CASE id_RocketLauncher: 	Code = "RocketLauncher";	Text = "Rocket Launcher";			break;
	CASE id_PlasmaRifle: 		Code = "PlasmaRifle";		Text = "Plasma Rifle";				break;
	CASE id_BFG9000: 			Code = "BFG9000";			Text = "BFG 9000";					break;
	CASE id_Clip: 				Code = "Clip";				Text = "Clip";						break;
	CASE id_ClipBox: 			Code = "ClipBox";			Text = "Box of Bullets";			break;
	CASE id_Shell: 				Code = "Shell";				Text = "Shotgun Shells";			break;
	CASE id_ShellBox: 			Code = "ShellBox";			Text = "Box of Shotgun Shells";		break;
	CASE id_RocketAmmo: 		Code = "RocketAmmo";		Text = "Rocket";					break;
	CASE id_RocketBox: 			Code = "RocketBox";			Text = "Box of Rockets";			break;
	CASE id_Cell: 				Code = "Cell";				Text = "Energy Cell";				break;
	CASE id_CellPack: 			Code = "CellPack";			Text = "Energy Cell Pack";			break;
	CASE id_Backpack: 			Code = "Backpack";			Text = "Backpack full of ammo";		break;
//	CASE id_Backpack:										Text = "Backpack full of ammo";
//	if (GetPort() == ZDaemon)	Code = "Backpack";
//	else						Code = "";														break;
	CASE id_Stimpack: 			Code = "Stimpack";			Text = "Stimpack";					break;
	CASE id_Medkit: 			Code = "Medikit";			Text = "Medikit";					break;
	CASE id_Soulsphere:			Code = "Soulsphere";		Text = "Soul Sphere";				break;
	CASE id_ArmorBonus: 		Code = "ArmorBonus";		Text = "Armor Bonus";				break;
	CASE id_GreenArmor: 		Code = "GreenArmor";		Text = "Armor";						break;
	CASE id_BlueArmor: 			Code = "BlueArmor";			Text = "Mega Armor";				break;
	CASE id_SmallCoin: 			Code = Money;		Text = "Small Coin";				break;
	CASE id_BigCoin: 			Code = "BlasterHefty";		Text = "Big Coin";					break;
	CASE id_AllMap: 			Code = "AllMap";			Text = "Computer Area Map";			break;

	CASE id_GenCam:											Text = "Playground Overview";		Info = StrParam(s:"Allows to view playground from different angles.");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						{Code = "";														}
	break;

	CASE id_SourceCode:										Text = "Source Code link";			Info = StrParam(s:"A link to the source code of this mod.\n",
																												s:"Spend ", i:SourceCodeTime/60/60, s:" hours playing it.\n",
																												s:"Not available at the moment.");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						{Code = "";														Info = StrParam(s:Info, s:"\n\nNOT AVAILABLE IN ZDAEMON!");}
	break;

	CASE id_ChaseCam:										Text = "Third Person Camera";		Info = StrParam(s:"Allows to see behind the player.");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						{Code = "";														Info = StrParam(s:Info, s:"\n\nNOT AVAILABLE IN ZDAEMON, USE CHASECAM INSTEAD!");}
	break;

	CASE id_DroneCam:										Text = "Spy Drone";					Info = StrParam(s:"Turns on the top-down view.\n",
																												s:"Able to inspect the map with this thing.");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						{Code = "";														Info = StrParam(s:Info, s:"\n\nNOT AVAILABLE IN ZDAEMON!");}
	break;

	CASE id_MoneyTransfer:									Text = "Money Transfer";			Info = StrParam(s:"Able to transfer various ammounts of money\n",
																												s:"to any logged in player. Commision is ", i:MoneyTransferFee, s:"%");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						Code = "";														//Info = StrParam(s:Info, s:"\n\nNOT AVAILABLE IN ZDAEMON!");}
	break;


	CASE id_Advertisement:									Text = "Advertisement Notice";		Info = StrParam(s:"Promote something or just write anything for everybody to see!\n",
																												s:"Before you buy, make sure to set your board in your Zandronum.ini\n",
																												s:"config file. Find template lines   '", s:AdvertisementCvar, s:"01 - ", s:AdvertisementCvar, i:MaxAddCharsY, s:"', edit\n",
																												s:"and save it as you like. That's it! Advertisement's resolution\n",
																												s:"is ", i:MaxAddCharsX, s:"x", i:MaxAddCharsY, s:" chars. Each time Advertisement is bought - this slot\n",
																												s:"will increase in price by $", i:AdvertisementCost, s:"!");
																								if (GetPort() >= Zandronum)
																								Info = StrParam(s:Info, s:"\nGo to Mod settings -> ", s:" -> 'Your Advert' option to see how it looks ingame");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						{Code = "";														Info = StrParam(s:"Promote something or just write anything for everybody to see\n",
																												s:"in the hub centre! First, type in console SET ADVERT ", s:"\"", s:"YOUR MEMO HERE", s:"\"", s: "\n",
																												s:"(Your message must not be longer than ", i:MaxMemoOwnerMSGChars, s:" chars)", s:"\n",
																												s:"Then, buy this feature, enter the teleport press \n",
																												k:"+use", s:" for it to become active!\n");
																												}
	break;


	CASE id_EnemyLocator:									Text = "Enemy Locator";				Info = StrParam(s:"Able to locate the remaining enemies.\n",
																												s:"Each use lasts for ", f:tic2sec(EnemyLocatorTime), s:" seconds and costs $", i:GetEnemyLocatorCost(), s:".\n",
																												s:"You have to be logged in to use this item.\n",
																												s:"Cannot use it on boss enemies.");
	if (GetPort() > ZDaemon)	Code = Ability;
	else						{Code = "";														Info = StrParam(s:Info, s:"\n\nDOES NOT WORK CORRECTLY IN ZDAEMON!");}
	break;


	CASE id_Zombieman: 			Code = "ZombieMan";			break;
	CASE id_Imp: 				Code = "DoomImp";			break;
	CASE id_ShotgunGuy: 		Code = "ShotgunGuy";		break;
	CASE id_Demon: 				Code = "Demon";				break;
	CASE id_HeavyWeaponDude: 	Code = "ChaingunGuy";		break;
	CASE id_Spectre: 			Code = "Spectre";			break;
	CASE id_LostSoul: 			Code = "LostSoul";			break;
	CASE id_Cacodemon: 			Code = "Cacodemon";			break;
	CASE id_HellKnight: 		Code = "HellKnight";		break;
	CASE id_Archvile: 			Code = "Archvile";			break;
	CASE id_Mancubus: 			Code = "Fatso";				break;
	CASE id_BaronOfHell: 		Code = "BaronOfHell";		break;
	CASE id_Arachnotron: 		Code = "Arachnotron";		break;
	CASE id_SpiderMastermind: 	Code = "SpiderMastermind";	break;
	CASE id_PainElemental: 		Code = "PainElemental";		break;
	CASE id_Cyberdemon: 		Code = "Cyberdemon";		break;
	CASE id_Railgunner: 		Code = "WolfensteinSS";		break;

	CASE id_ImpBall: 			Code = "DoomImpBall";		break;
	CASE id_BaronBall: 			Code = "BaronBall";			break;
	CASE id_ArachnotronShot: 	Code = "ArachnotronPlasma";	break;
	CASE id_PlasmaBall: 		Code = "PlasmaBall";		break;
	CASE id_CacoBall: 			Code = "CacodemonBall";		break;
	CASE id_RevenantBall: 		Code = "RevenantTracer";	break;
	CASE id_MancubusShot: 		Code = "FatShot";			break;
	CASE id_Rocket: 			Code = "Rocket";			break;
	CASE id_BFGBall: 			Code = "BFGBall";			break;

	CASE id_MarinePlasma: 		Code = "MarinePlasma";		break;
	CASE id_MarineBerserk: 		Code = "MarineBerserk";		break;
	CASE id_MarineChaingun: 	Code = "MarineChaingun";	break;
	CASE id_MarineRocket: 		Code = "MarineRocket";		break;
	CASE id_MarineBFG: 			Code = "MarineBFG";			break;
	CASE id_MarineShotgun: 		Code = "MarineShotgun";		break;
	CASE id_MarineRailgun: 		Code = "MarineRailgun";		break;
	CASE id_MarineSSG: 			Code = "MarineSSG";			break;

	}

Switch(PrintAs)
	{
	CASE as_CODE:	Result = Code;			break;
	CASE as_TEXT:	Result = Text;			break;
	CASE as_INFO:	Result = Info;			break;
	}
return Result;
}


function int GetEnemyLocatorCost (void)
{
int Result;
Switch (GetPort())
{
case ZDaemon:	Result = 5;	break;
case Zandronum:
case GZDoom:	Result = 5;	break;
}
return Result;
}





function int SetRoundWeapon (int Difficulty)
{
int Weapon;
		if 		((Difficulty >=   0) && (Difficulty <  10))		Weapon = id_Pistol;
else 	if 		((Difficulty >=  10) && (Difficulty <  20))		Weapon = RNG(id_Pistol, id_Shotgun);
else 	if 		((Difficulty >=  20) && (Difficulty <  30))		Weapon = id_Shotgun;
else 	if 		((Difficulty >=  30) && (Difficulty <  40))		Weapon = RNG(id_Shotgun, id_Chaingun);
else 	if 		((Difficulty >=  40) && (Difficulty <  50))		Weapon = id_Chaingun;
else 	if 		((Difficulty >=  50) && (Difficulty <  60))		Weapon = RNG(id_Chaingun, id_SuperShotgun);
else 	if 		((Difficulty >=  60) && (Difficulty <  85))		Weapon = id_SuperShotgun;
else 	if 		((Difficulty >=  85) && (Difficulty <  95))		Weapon = id_RailGun;
else 	if 		((Difficulty >=  95) && (Difficulty <=100))		Weapon = RNG(id_RocketLauncher, id_PlasmaRifle);
//log (s:"DIFFICULTY IS ", i:Difficulty, s:", WEAPON id is ", i:Weapon);
return Weapon;
}

#libdefine 	si_SECTOR 	0
#libdefine	si_ACTOR 	1
#libdefine	si_DELAY 	2
#libdefine	si_TIMER 	3


#libdefine	item_RANDOM 	-1


#libdefine SectorItemSlots 512		#libdefine SectorItemParams 4
int SectorItem [SectorItemSlots][SectorItemParams];
int Projectila[ProjectilaSlots][ProjectilaParams];

#libdefine WormParam_COUNT				0
#libdefine WormParam_X 					1
#libdefine WormParam_Y 					2
#libdefine WormParam_DELAY				3
#libdefine WormParam_TIMER				4
#libdefine WormParam_BLOCKCOUNTER		5

#libdefine WormParams					6
#libdefine WormSlots					MaxObstacles*PlaygroundBlocks
int Worm[WormSlots][WormParams];


#libdefine SoilParam_COUNT				0
#libdefine SoilParam_BLOCKCOUNTER		1
#libdefine SoilParam_TYPE				2

#libdefine SoilParams					3
#libdefine SoilSlots					PlaygroundBlocks
int Soil[SoilSlots][SoilParams];





function int SetItem (int BlockCounter, int Direction, int Tag, int idNum)
{
RoundInfo[SectorItemCounter]++;

int Deelay = 1;
	//SET A SECTOR OF RESPAWN-------------------------------------------------------------------------------------------------------------------------------------
	SectorItem [RoundInfo[SectorItemCounter]][si_SECTOR]	=	TagAt (BlockCounter, Direction, Tag);




	//SET AN ACTOR ITSELF-------------------------------------------------------------------------------------------------------------------------------------
if (idNum == item_RANDOM)
	{

			if (RoundInfo[HealthSpawnerCounter] 	== 0)			{	IdNum	=	GetHealthType();		RoundInfo[HealthSpawnerCounter]		= RoundInfo[HealthSpawnerQueue];	}
	else	if (RoundInfo[MoneySpawnerCounter]		== 0)			{	IdNum	=	GetMoneyType();			RoundInfo[MoneySpawnerCounter] 		= RoundInfo[MoneySpawnerQueue];		}
	else	if (RoundInfo[WeaponSpawnerCounter] 	== 0)			{	IdNum	=	GetWeaponType();		RoundInfo[WeaponSpawnerCounter] 	= RoundInfo[WeaponSpawnerQueue];	}
	else	if (RoundInfo[AmmoSpawnerCounter] 		== 0)			{	IdNum	=	GetAmmoType();			RoundInfo[AmmoSpawnerCounter] 		= RoundInfo[AmmoSpawnerQueue];		}
	else	if (RoundInfo[ArmorSpawnerCounter] 		== 0)			{	IdNum	=	GetArmorTipe();			RoundInfo[ArmorSpawnerCounter] 		= RoundInfo[ArmorSpawnerQueue];		}
	else															{
																		IdNum	=	id_None;
																		RoundInfo[HealthSpawnerCounter]--;
																		RoundInfo[MoneySpawnerCounter]--;
																		RoundInfo[WeaponSpawnerCounter]--;
																		RoundInfo[AmmoSpawnerCounter]--;
																		RoundInfo[ArmorSpawnerCounter]--;
																	}
	}


	SectorItem [RoundInfo[SectorItemCounter]][si_ACTOR]		=	idNum;


	//SET A RESPAWN DELAY-------------------------------------------------------------------------------------------------------------------------------------
						// Num is AMMO
						if ((idNum >= id_minAMMO)		&& 	(idNum <= id_maxAMMO))				SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*25 + (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]*3);
						// Num is WEAPON
				else 	if ((idNum >= id_minWEAPON)		&& 	(idNum <= id_maxWEAPON))			SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*240;
						// Num is HEALTH
				else 	if ((idNum >= id_minHEALTH)		&& 	(idNum <= id_maxHEALTH))			SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*35 + (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]*3);
						// Num is Money
				else 	if ((idNum >= id_minMoney)		&& 	(idNum <= id_maxMoney))				SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*ImpossibleNum;
						// Num is Armor
				else 	if ((idNum >= id_minArmor)		&& 	(idNum <= id_maxArmor))				SectorItem [RoundInfo[SectorItemCounter]][si_DELAY]	=	Sec*240;

	//SET TIMER-------------------------------------------------------------------------------------------------------------------------------------
//						SectorItem [RoundInfo[SectorItemCounter]][si_TIMER]	=	SectorItem [RoundInfo[SectorItemCounter]][si_DELAY];





return Deelay;
}

////////////////////////////////////////////////////////////////////////////////////////////////

function int GetWeaponType (void)
{
int Result;
int odds = RNG(1, 100);

Result = RNG(id_SuperShotgun, id_PlasmaRifle);
if (odds > 96)	Result = id_BFG9000;

return Result;
}


////////////////////////////////////////////////////////////////////////////////////////////////





Script "MSG_NewWeapon" (int WeaponType) CLIENTSIDE
{
str Got = "You've got a ";


//SetWeapon(int2str_WEAPON(WeaponType));	doesnt work
if (weaponType > id_Pistol)
		{
		AmbientSound("misc/w_pkup", 127);
		DrawNotification(For_ActivatorOnly, StrParam(s:Got, s:ActorString(WeaponType, as_TEXT), s:"!"), 		notepose_BOT, notepara_ALIGN, ICON_Weapon, StrParam(c:ICON_Weapon), "j", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
		}


}

////////////////////////////////////////////////////////////////////////////////////////////////



function int GetAmmoType (void)
{
int Ammo, i;
int odds = RNG(1, 100);
Switch(AdventureInfo[RNG(1, RoundInfo[CurrentRound])][adv_WEAPON])
		{
		CASE id_Pistol:				Ammo = id_Clip;										break;
		CASE id_Shotgun:			Ammo = RNG(id_Shell, 		id_ShellBox);			break;
		CASE id_Chaingun:			Ammo = RNG(id_Clip, 		id_ClipBox);			break;
		CASE id_SuperShotgun:		Ammo = RNG(id_Shell, 		id_ShellBox);			break;
		CASE id_Railgun:			Ammo = RNG(id_Cell, 		id_CellPack);			break;
		CASE id_RocketLauncher:		Ammo = RNG(id_RocketAmmo, 	id_RocketBox);			break;
		CASE id_PlasmaRifle:		Ammo = RNG(id_Cell, 		id_Cell);				break;
		CASE id_BFG9000:			Ammo = RNG(id_Cell, 		id_CellPack);			break;
		}
if (odds > 97)	Ammo = 	id_Backpack;

return Ammo;
}






function int GetHealthType (void)
{
int Result =	RNG(id_Stimpack, id_Medkit);
//int odds =		RNG(1, 100);


//if (odds > 96)	Result = id_Soulsphere;

return Result;
}


function int GetArmorTipe (void)
{
int Result	=	id_ArmorBonus;
int odds 	=	RNG(1, 100);


if (odds > 90)
	if (odds > 97)	Result = id_BlueArmor;
	else			Result = id_GreenArmor;

return Result;
}



function int GetMoneyType (void)
{
int Result;
int odds = RNG(1, 100);


if (odds > 75)	Result = id_BigCoin;
else			Result = id_SmallCoin;

return Result;
}






Script "Items" (void)
{
int counter;

while(TRUE)
	{
	counter = 0;
	while( counter <= RoundInfo[SectorItemCounter])
		{
		if (IsTIDUsed(ACTORTID_DynamicTid + SectorItem [counter][si_SECTOR]) == FALSE)	//if item was picked or never spawned yet

			if ((SectorItem [counter][si_ACTOR] != id_None)	&&	(SectorItem [counter][si_SECTOR] != 0))
						{
						if (SectorItem [counter][si_TIMER] == 0)	//if it's time to spawn an item
								{


								RefreshSpotHeight(refreshspot_ITEM, counter);
								SpawnSpotForced(ActorString(SectorItem [counter][si_ACTOR], as_CODE), SectorItem [counter][si_SECTOR], ACTORTID_DynamicTid + SectorItem [counter][si_SECTOR], RNG(0,255));
								SpawnSpotForced("ItemFog", 									SectorItem [counter][si_SECTOR], 0, 0);	//visual
								SectorItem [counter][si_TIMER] = SectorItem [counter][si_DELAY];	//Refresh timer for this projectile
								}

						else	SectorItem [counter][si_TIMER]--;
						}
		counter++;
		}

	delay(1);
	}
}







function int SetSubstanceSpeed (void)
{
int Result;
		if  (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 20 )																			Result = 		2;
else	if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 20 )	&&	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 40 ))	Result = RNG(1,2);
else	if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 40 )	&&	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 60 ))	Result = 		1;
else	if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 60 )	&&	(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	<= 80 ))	Result = RNG(0,1);
else	if  (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]	 > 80 )																			Result = 		0;

return Result;
}




/*
  _      ____   _____       _______ _____ ____  _   _                _   _ _____         _____ _  ____     ______   ______   __
 | |    / __ \ / ____|   /\|__   __|_   _/ __ \| \ | |         /\   | \ | |  __ \       / ____| |/ /\ \   / /  _ \ / __ \ \ / /
 | |   | |  | | |       /  \  | |    | || |  | |  \| |        /  \  |  \| | |  | |     | (___ | ' /  \ \_/ /| |_) | |  | \ V /
 | |   | |  | | |      / /\ \ | |    | || |  | | . ` |       / /\ \ | . ` | |  | |      \___ \|  <    \   / |  _ <| |  | |> <
 | |___| |__| | |____ / ____ \| |   _| || |__| | |\  |      / ____ \| |\  | |__| |      ____) | . \    | |  | |_) | |__| / . \
 |______\____/ \_____/_/    \_\_|  |_____\____/|_| \_|     /_/    \_\_| \_|_____/      |_____/|_|\_\   |_|  |____/ \____/_/ \_\


*/



function void SetPlaygroundColor (void)
{
int a, b;
Switch(GetSectorLightLevel(TIDRAM_Mood)*10 + GetSectorLightLevel(TIDRAM_Location))
		{

//EARTH
		CASE 11:											RoundInfo[sct_RED] 		= RNG(224, 255);				RoundInfo[sct_GREEN] 	= RNG(208, 224);			RoundInfo[sct_BLUE]	= RNG(192, 208);			RoundInfo[sct_DESATURATE] = RNG(  0,   0);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 12:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_BLUE]	= RNG(208, 224);			RoundInfo[sct_DESATURATE] = RNG(104, 128);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 13:	b = RNG(216, 224);						RoundInfo[sct_RED] 		= b;							RoundInfo[sct_GREEN] 	= RNG(224, 255);			RoundInfo[sct_BLUE]	= b;						RoundInfo[sct_DESATURATE] = RNG(148, 172);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 14:											RoundInfo[sct_RED] 		= RNG(245, 255);				RoundInfo[sct_GREEN] 	= RNG(245, 255);			RoundInfo[sct_BLUE]	= RNG(245, 255);			RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 15:	b = RNG(180, 208);						RoundInfo[sct_RED] 		= RNG(245, 255);				RoundInfo[sct_GREEN] 	= b;						RoundInfo[sct_BLUE]	= b;						RoundInfo[sct_DESATURATE] = RNG(16, 32);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 16:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_BLUE]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 17:											RoundInfo[sct_RED] 		= RNG(245, 255);				RoundInfo[sct_GREEN] 	= RNG(245, 255);			RoundInfo[sct_BLUE]	= RNG(245, 255);			RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(156, 172);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 18:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE]	= a;						RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 19:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 60;					RoundInfo[sct_DESATURATE] = RNG(16, 32);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 4.0;	break;
//COLONY
		CASE 21:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 60;					RoundInfo[sct_BLUE]	= a - 120;					RoundInfo[sct_DESATURATE] = RNG(16, 32);		RoundInfo[sct_BRIGHTNESS] = RNG(156, 172);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 22:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 120;					RoundInfo[sct_BLUE]	= a - 120;					RoundInfo[sct_DESATURATE] = RNG(16, 48);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 23:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 40;					RoundInfo[sct_BLUE]	= a - 110;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 24:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 50;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(1, 16);			RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 25:	b = RNG(200, 216);						RoundInfo[sct_RED] 		= b;							RoundInfo[sct_GREEN] 	= RNG(224, 255);			RoundInfo[sct_BLUE]	= b;						RoundInfo[sct_DESATURATE] = RNG(32, 64);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 26:	b = RNG(216, 235);						RoundInfo[sct_RED] 		= b;							RoundInfo[sct_GREEN] 	= b;						RoundInfo[sct_BLUE]	= RNG(245, 255);			RoundInfo[sct_DESATURATE] = RNG(64, 128);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 27:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 40;					RoundInfo[sct_BLUE]	= a - 80;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(200, 224);	RoundInfo[sct_FADEDIV] = 2.0;	break;
		CASE 28:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 29:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE]	= a - 30;					RoundInfo[sct_DESATURATE] = RNG(32, 72);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 2.0;	break;
//SPACE
		CASE 31:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 60;					RoundInfo[sct_BLUE]	= a - 110;					RoundInfo[sct_DESATURATE] = RNG(48, 80);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 32:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 33:	a = RNG(224, 255);						RoundInfo[sct_BLUE] 	= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_RED]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 34:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE] = a;						RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 35:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 36:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a - 20;					RoundInfo[sct_BLUE]	= a - 40;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 37:	a = RNG(224, 255);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE] = a;						RoundInfo[sct_DESATURATE] = RNG(72,  128);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 0;		break;
		CASE 38:	a = RNG(216, 235);						RoundInfo[sct_RED] 		= a;							RoundInfo[sct_GREEN] 	= a;						RoundInfo[sct_BLUE] = a - 30;					RoundInfo[sct_DESATURATE] = RNG(72,  128);		RoundInfo[sct_BRIGHTNESS] = RNG(224, 255);	RoundInfo[sct_FADEDIV] = 4.0;	break;
		CASE 39:	a = RNG(224, 255);						RoundInfo[sct_BLUE] 	= a;							RoundInfo[sct_GREEN] 	= a - 10;					RoundInfo[sct_RED]	= a - 20;					RoundInfo[sct_DESATURATE] = RNG(128, 192);		RoundInfo[sct_BRIGHTNESS] = RNG(180, 200);	RoundInfo[sct_FADEDIV] = 0;		break;
		}
}


function void SetSectorVisual (int Tag)
{
//SetFade should be first in Zdaemon, otherwise desaturation wont work;

if (RoundInfo[sct_FADEDIV] > 0)	Sector_SetFade		(Tag, FixedDiv(int2fix(RoundInfo[sct_RED]), RoundInfo[sct_FADEDIV])>>16, FixedDiv(int2fix(RoundInfo[sct_GREEN]), RoundInfo[sct_FADEDIV])>>16, FixedDiv(int2fix(RoundInfo[sct_BLUE]), RoundInfo[sct_FADEDIV])>>16);
								Light_ChangeToValue	(Tag, RoundInfo[sct_BRIGHTNESS]);
								Sector_SetColor		(Tag, RoundInfo[sct_RED], RoundInfo[sct_GREEN], RoundInfo[sct_BLUE], RoundInfo[sct_DESATURATE]);
//log(i:tag);
}



Script "DrawSky" (int Turn, int SkyType) CLIENTSIDE
{
int i;
str sky = "";

Switch(Turn)
		{
		CASE ON:	sky = StrParam(i:SkyType);			break;
		CASE OFF:	sky = "00";							break;
		}




for (i = 1; i <= 64;  i++)			ChangeFloor		(SECTORTAG_Skybox + i,								StrParam(s:"SK", s:sky, s:"FL", i:i));
for (i = 1; i <= 64;  i++)			ChangeCeiling	(SECTORTAG_Skybox + i, 								StrParam(s:"SK", s:sky, s:"CE", i:i));
for (i = 1; i <=  4;  i++)			SetLineTexture	(SECTORTAG_Skybox + i, SIDE_FRONT, TEXTURE_MIDDLE,	StrParam(s:"SK", s:sky, s:"WA", i:i));



i = GetSectorLightLevel(TIDRAM_SkyboxVolume);
Switch(Turn)
		{
		CASE ON:	TranslucentLine(LINETAG_VolumetricD_up, 0, 1);					TranslucentLine(LINETAG_VolumetricD_dn, 0, 1);		break;
		CASE OFF:	TranslucentLine(LINETAG_VolumetricD_up, i, 1);					TranslucentLine(LINETAG_VolumetricD_dn, i, 1);		break;
		}


}


function str FailTextureName (void)
{
str Result = "";
Switch(GetSectorLightLevel(TIDRAM_Mood))
		{
		CASE mood_EARTH: 	Result = "LAVA";	break;
		CASE mood_COLONY:
		CASE mood_SPACE: 	Result = "SLIME";	break;
		}
return Result;
}



function str CreateLocationName (void)
{
int RootCount = RNG(25, 100);
int counter;
int Inter = RNG(0, 60);

str Name = "";	int MoodNameAt = RNG(ON,OFF);	//ON - at the start, OFF - at the end
//---------------------------------------------------------------------------------------------
if (MoodNameAt == ON)		Name = StrParam(s:Name, s:strMood(ON));
//---------------------------------------------------------------------------------------------


if (RootCount > 50)	RootCount = 1;
else RootCount = 0;

counter = 0;
while(counter <= RootCount)
	{
	Name = StrParam(s:Name, s:strLocationRoot());

	if (counter < RootCount)
		if (Inter > 50)
				{
				Name = StrParam(s:Name, s:strLocationInter());
				}
	counter++;
	}
//---------------------------------------------------------

Switch(RNG(false, true))
		{
		CASE true:	Name = StrParam(s:Name, s:strLocationEnding());		break;
		}
//---------------------------------------------------------
if (MoodNameAt == OFF)		Name = StrParam(s:Name, s:strMood(OFF));

return Name;
}







function str  strMood (int Part)
{
str Result = "";	str Start = ""; str End = "";
Switch(GetSectorLightLevel(TIDRAM_Mood)*10 + RNG(1, 3))
	{
	CASE 11:	Start = "State of "; 		End = "'s State";				break;
	CASE 12:	Start = "Country of "; 		End = "'s Country";				break;
	CASE 13:	Start = "The Land of "; 	End = "'s Land";				break;
	CASE 21:	Start = "Colony of "; 		End = " Colony";				break;
	CASE 22:	Start = "Satelite in "; 	End = "'s Satelite";			break;
	CASE 23:	Start = "A Star of "; 		End = " Star";					break;
	CASE 31:	Start = "Galaxy of "; 		End = " Galaxy";				break;
	CASE 32:	Start = "Universe of "; 	End = "'s Universe";			break;
	CASE 33:	Start = "Station of "; 		End = "'s Space Station";		break;
	}
Switch(Part)
		{
		CASE ON:	Result = Start;		break;
		CASE OFF:	Result = End;		break;
		}


return Result;
}






function str  strLocationRoot (void)
{
int Vari = RNG(1, 15);
int A;
Switch(RNG(65,68))
	{
	CASE 65:	//A
	Switch(Vari)
		{
		CASE 1: A = "amin"; 	break;				CASE 2: A = "ashi"; 	break;			CASE 3: A = "aegon"; 	break;				CASE 4: A = "ar"; 	break;					CASE 5: A = "ajith"; 	break;
		CASE 6: A = "axil"; 	break;				CASE 7: A = "aworth"; 	break;			CASE 8: A = "api"; 		break;				CASE 9: A = "abas"; 	break;				CASE 10: A = "Aphir"; 	break;
		CASE 11: A = "azi"; 	break;				CASE 12: A = "aldo"; 	break;			CASE 13: A = "avo"; 	break;				CASE 14: A = "aken"; 	break;				CASE 15: A = "asho"; 	break;
		}
	break;

	CASE 66:	//B
	Switch(Vari)
		{
		CASE 1: A = "bori"; 	break;				CASE 2: A = "becki"; 	break;			CASE 3: A = "bith"; 	break;				CASE 4: A = "bolp"; 	break;				CASE 5: A = "beert"; 	break;
		CASE 6: A = "benshi"; 	break;				CASE 7: A = "bagh"; 	break;			CASE 8: A = "beesh"; 	break;				CASE 9: A = "balin"; 	break;				CASE 10: A = "barc"; 	break;
		CASE 11: A = "bosch"; 	break;				CASE 12: A = "binli"; 	break;			CASE 13: A = "bio"; 	break;				CASE 14: A = "boja"; 	break;				CASE 15: A = "beel"; 	break;
		}
	break;

	CASE 67:	//C
	Switch(Vari)
		{
		CASE 1: A = "cosc"; 	break;				CASE 2: A = "coort"; 	break;			CASE 3: A = "chash"; 	break;				CASE 4: A = "circ"; 	break;				CASE 5: A = "clea"; 	break;
		CASE 6: A = "confo"; 	break;				CASE 7: A = "cath"; 	break;			CASE 8: A = "corth"; 	break;				CASE 9: A = "corgh"; 	break;				CASE 10: A = "coed"; 	break;
		CASE 11: A = "cenz"; 	break;				CASE 12: A = "coam"; 	break;			CASE 13: A = "chort"; 	break;				CASE 14: A = "ciph"; 	break;				CASE 15: A = "choep"; 	break;
		}
	break;

	CASE 68:	//D
	Switch(Vari)
		{
		CASE 1: A = "deesh"; 	break;				CASE 2: A = "dozh"; 	break;			CASE 3: A = "deit"; 	break;				CASE 4: A = "doom"; 	break;				CASE 5: A = "doon"; 	break;
		CASE 6: A = "daek"; 	break;				CASE 7: A = "dorth"; 	break;			CASE 8: A = "dyna"; 	break;				CASE 9: A = "dimo"; 	break;				CASE 10: A = "dzhan"; 	break;
		CASE 11: A = "dzhoy"; 	break;				CASE 12: A = "doris"; 	break;			CASE 13: A = "dari"; 	break;				CASE 14: A = "dokh"; 	break;				CASE 15: A = "dost"; 	break;
		}
	break;
	}

return A;
}

function str strLocationInter (void)
{
int A;
Switch(RNG(1,10))
	{
	CASE 1: A = "-or-"; 	break;				CASE 2: A = "-dit-"; 	break;			CASE 3: A = "-aq-"; 	break;				CASE 4: A = "-nes-"; 	break;				CASE 5: A = "-la-"; 	break;
	CASE 6: A = "-tez-"; 	break;				CASE 7: A = "ton-"; 	break;			CASE 8: A = "-qi-"; 	break;				CASE 9: A = "-mar-"; 	break;				CASE 10: A = "-ken-"; 	break;
	}
return A;
}



function str strLocationEnding (void)
{
int A;
Switch(RNG(1,25))
	{
	CASE 1: A = "adia"; 	break;				CASE 2: A = "ia"; 	break;			CASE 3: A = "ria"; 	break;				CASE 4: A = "cain"; 	break;				CASE 5: A = "la"; 		break;
	CASE 6: A = "via"; 	break;					CASE 7: A = "que"; 	break;			CASE 8: A = "rra"; 	break;				CASE 9: A = "ius"; 	break;					CASE 10: A = "dos"; 	break;
	CASE 11: A = "ros"; 	break;				CASE 12: A = "tos"; break;		CASE 13: A = "roon"; 	break;				CASE 14: A = "an"; 	break;					CASE 15: A = "and"; 	break;
	CASE 16: A = "rica"; 	break;				CASE 17: A = "nes"; break;		CASE 18: A = "dor"; 	break;				CASE 19: A = "nia"; 	break;				CASE 20: A = "gia"; 	break;
	CASE 21: A = "any"; 	break;				CASE 22: A = "ity"; break;		CASE 23: A = "ver"; 	break;				CASE 24: A = "key"; 	break;				CASE 25: A = "see"; 	break;
	}
return A;
}






/*
  _____  _____   ____       _ ______ _____ _______ _____ _      ______  _____
 |  __ \|  __ \ / __ \     | |  ____/ ____|__   __|_   _| |    |  ____|/ ____|
 | |__) | |__) | |  | |    | | |__ | |       | |    | | | |    | |__  | (___
 |  ___/|  _  /| |  | |_   | |  __|| |       | |    | | | |    |  __|  \___ \
 | |    | | \ \| |__| | |__| | |___| |____   | |   _| |_| |____| |____ ____) |
 |_|    |_|  \_\\____/ \____/|______\_____|  |_|  |_____|______|______|_____/


*/










function int SetProjectile (int ProjPart, int ProjRole, int BlockCounter, int Direction, int EmitTag, int DevourTag, int Angle, int AddHeight, int Difficulty)
{
//return 1;
int exc, Delaay, IsAtException, TagHeight, ExceptionHeight, Tag, ArrayRole, LineTag;
bool DontMoveGeometry;
Difficulty 		= WithinHundred(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] + Difficulty);

Switch(ProjRole)
		{
		CASE ProjRole_EMIT: 	ArrayRole = ProjParam_EMITSPOT; 	Tag = EmitTag; 		break;
		CASE ProjRole_DEVOUR: 	ArrayRole = ProjParam_DEVOURSPOT; 	Tag = DevourTag;	break;
		}


if (ProjPart != area_Preparation)
		{

		while(exc <= RoundInfo[BorderExceptionCounter])
									{




		// CHANGE HEIGHTS
		//for (exc = 0; exc <= RoundInfo[BorderExceptionCounter]; exc++)				// if 			SPOT IS AT ALREADY USED (Emitter Spot)												SPOT IS AT ALREADY USED (Devour Spot)
																					if ((TagAt (BlockCounter, Direction, Tag) == Projectila[exc][ProjParam_EMITSPOT])	||	(TagAt (BlockCounter, Direction, Tag) == Projectila[exc][ProjParam_DEVOURSPOT]))
																						{
																									if (TagAt (BlockCounter, Direction, Tag) == Projectila[exc][ProjParam_EMITSPOT]) 	IsAtException = ProjParam_EMITSPOT;
																							else	if (TagAt (BlockCounter, Direction, Tag) == Projectila[exc][ProjParam_DEVOURSPOT]) 	IsAtException = ProjParam_DEVOURSPOT;

																							//log(s:"\ctException is at ", i:TagAt (BlockCounter, Direction, Tag));
																							Switch(ProjPart)
																									{
																									CASE area_FLOOR:
																														TagHeight		= RoundInfo[CurrFloorHeight]		+	ProjHoleHeight	+	AddHeight;
																														ExceptionHeight = Projectila[exc][IsAtException]	+	ProjHoleHeight	+	AddHeight;

																															if (TagHeight  >=   ExceptionHeight)
																																	{
																																	DontMoveGeometry = true;
																																	Delaay = 0;
																																	}
																									break;

																									//--------------------------------------------------------------------------------------------------------

																									CASE area_CEILING:
																														TagHeight		= RoundInfo[CurrFloorHeight]		+	ProjHoleHeight	+	AddHeight	+	ProjHoleSize;
																														ExceptionHeight = Projectila[exc][IsAtException]	+	ProjHoleHeight	+	AddHeight	+	ProjHoleSize;

																															if (TagHeight  <=   ExceptionHeight)
																																	{
																																	DontMoveGeometry = true;
																																	Delaay = 0;
																																	}
																									break;
																									}

																						if (DontMoveGeometry) break;


																						}
									exc++;
									}

				if (DontMoveGeometry == FALSE)
							{

							Delaay = Gendel_Height;		// do delay only after floors, because delaying switching emit ceiling to devour floor is pointless

							Switch(ProjPart)
										{
										CASE area_FLOOR:
															TagHeight = RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight;
															Floor_MoveToValue	(TagAt (BlockCounter, Direction, Tag), 			MoveInstantly, TagHeight);
															ChangeFloor			(TagAt (BlockCounter, Direction, Tag),  		TextureIs(FlatEDGEtx));
										break;


										CASE area_CEILING:
															TagHeight = RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight	+	ProjHoleSize;
															Ceiling_MoveToValue	(TagAt (BlockCounter, Direction, Tag), 			MoveInstantly, TagHeight);
															ChangeCeiling		(TagAt (BlockCounter, Direction, Tag),  		TextureIs(FlatEDGEtx));
										break;

										}

							}
/*
				else if (DontMoveGeometry == TRUE)
						{
							Switch(ProjRole)
								{
								//CASE ProjRole_EMIT: 	ArrayRole = ProjParam_EMITSPOT; 	Tag = EmitTag; 		break;

								CASE ProjRole_DEVOUR:
												if (ProjPart == area_FLOOR)
														if (TagHeight   >=   GetSectorFloorZ(TagAt (BlockCounter, Direction, EmitTag)>> 16, 0, 0))
														Floor_MoveToValue	(TagAt (BlockCounter, Direction, Tag), 			MoveInstantly, GetSectorFloorZ(TagAt (BlockCounter, Direction, EmitTag)>> 16, 0, 0));
												if (ProjPart == area_CEILING)
														if (TagHeight   <=   GetSectorCeilingZ(TagAt (BlockCounter, Direction, EmitTag)>> 16, 0, 0));
														Ceiling_MoveToValue	(TagAt (BlockCounter, Direction, Tag), 			MoveInstantly, GetSectorCeilingZ(TagAt (BlockCounter, Direction, EmitTag)>> 16, 0, 0));
								break;
								}
						}
*/
				// SET LINES
				if (ProjPart == area_CEILING)	//Set Textures once we move the ceiling
					{

											// F R O N T L I N E
															LineTag = LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	Tag));
															Switch(ProjRole)
															{
															CASE ProjRole_EMIT:																	break;
															CASE ProjRole_DEVOUR:
															SetLineSpecial(		LineTag, 	ACS_ExecuteAlways, SCRIPT_DestroyProjectile);		break;
															}
															Line_SetBlocking(	LineTag,	false, 			BLOCKF_EVERYTHING);
															Line_SetBlocking(	LineTag,	false, 			BLOCKF_PROJECTILES);
															Line_SetBlocking(	LineTag,	BLOCKF_SIGHT, 		false);
															Line_SetBlocking(	LineTag,	BLOCKF_CREATURES, 	false);
															SetLineTexture(		LineTag,	SIDE_FRONT,	TEXTURE_MIDDLE, "BLACKWAL");
															SetLineTexture(		LineTag,	SIDE_BACK,	TEXTURE_MIDDLE, "BLACKWAL");

											// B A C K L I N E		(if that's a new block in the exceptions, then also fill the backline)
											if (!IsAtException)
															{
															LineTag = LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	Tag));
															Line_SetBlocking(	LineTag,	BLOCKF_EVERYTHING, 	false);
															Line_SetBlocking(	LineTag,	BLOCKF_SIGHT, 		false);
															SetLineTexture(		LineTag,	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
															SetLineTexture(		LineTag,	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
																	// S I D E L I N E 		(if this block is located at the entrance)
																	//if (AssignLine (SIDE_SIDEY, 	Tag) != 0)		//if (!AssignLine (SIDE_SIDEY, 	Tag))
																	if (!AssignLine (SIDE_SIDEY, 	Tag))
																	//if (ProjRole == ProjRole_DEVOUR)
																	{
																	LineTag = LineAt (BlockCounter, Direction, AssignLine (SIDE_SIDEY, 	Tag));
																	Line_SetBlocking(	LineTag,	BLOCKF_EVERYTHING, 	false);
																	Line_SetBlocking(	LineTag,	BLOCKF_SIGHT, 		false);
																	SetLineTexture(		LineTag,	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
																	SetLineTexture(		LineTag,	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
																	}
															}

					}

		}







if (ProjPart == area_PREPARATION)
		{

		//ASSIGNING A BORDER EXCEPTION
		RoundInfo[BorderExceptionCounter]++;


				if 		((Difficulty <=   0) && (Difficulty <  10))		{	ProjRole = RNG(id_None, 				id_ImpBall			);		ArrayRole = 95;					Tag = 95;				}
		else 	if 		((Difficulty >=  10) && (Difficulty <  20))		{	ProjRole = RNG(id_ImpBall, 				id_BaronBall		);		ArrayRole = 100;				Tag = 90;				}
		else 	if 		((Difficulty >=  20) && (Difficulty <  30))		{	ProjRole = RNG(id_Rocket, 				id_ArachnotronShot	);		ArrayRole = 105;				Tag = 85;				}
		else 	if 		((Difficulty >=  30) && (Difficulty <  40))		{	ProjRole = RNG(id_Rocket, 				id_PlasmaBall		);		ArrayRole = 110 + 5*RNG(1,3);	Tag = 80;				}
		else 	if 		((Difficulty >=  40) && (Difficulty <  50))		{	ProjRole = RNG(id_Rocket,				id_CacoBall			);		ArrayRole = 115 + 5*RNG(1,3);	Tag = 75;				}
		else 	if 		((Difficulty >=  50) && (Difficulty <  60))		{	ProjRole = RNG(id_Rocket,				id_MancubusShot		);		ArrayRole = 120 + 5*RNG(1,4);	Tag = 70;				}
		else 	if 		((Difficulty >=  60) && (Difficulty <  70))		{	ProjRole = RNG(id_Rocket,				id_Rocket			);		ArrayRole = 125 + 5*RNG(1,4);	Tag = 65;				}
		else 	if 		((Difficulty >=  70) && (Difficulty <  80))		{	ProjRole = RNG(id_Rocket,				id_Rocket	 		);		ArrayRole = 130 + 5*RNG(1,5);	Tag = 60;				}
		else 	if 		((Difficulty >=  80) && (Difficulty <  90))		{	ProjRole = RNG(id_Rocket,				id_BFGBall 			);		ArrayRole = 135 + 5*RNG(1,5);	Tag = 55 + 5*RNG(1,2);	}
		else 	if 		((Difficulty >=  90) && (Difficulty < 100))		{	ProjRole = RNG(id_Rocket,				id_BFGBall			);		ArrayRole = 140 + 5*RNG(1,6);	Tag = 40 + RNG(0,10);	}
		else 	if 		(Difficulty	 >= 100)							{	ProjRole = RNG(id_BFGBall,				id_BFGBall			);		ArrayRole = 145 + 5*RNG(1,10);	Tag = 35 + RNG(0,10);	}




		//Assigning a projectile actor
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_EMITSPOT]	= TagAt (BlockCounter, Direction, EmitTag);
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_DEVOURSPOT]	= TagAt (BlockCounter, Direction, DevourTag);
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_TYPE] 		= ProjRole;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_SPEED]		= ArrayRole;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_ANGLE]		= ActorAngle(Angle, Direction, BYTE);
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_DELAY]		= Tag;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_HEIGHT]		= RoundInfo[CurrFloorHeight]	+	ProjHoleHeight	+	AddHeight;
		Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_TIMER]		= Projectila[RoundInfo[BorderExceptionCounter]][ProjParam_DELAY];

		}

/*
log(
i:RoundInfo[BorderExceptionCounter],
s:".   Exception is at ", i:IsAtException, s:",   Dont move Geometry ", i:DontMoveGeometry,
s:".   \ciEMIT Tag ",		i:TagAt (BlockCounter, Direction, EmitTag),
s:".   EMIT Floor ",	i:GetSectorFloorZ(TagAt (BlockCounter, Direction, EmitTag), 0, 0) >>16,
s:".   EMIT CEIL ",		i:GetSectorCeilingZ(TagAt (BlockCounter, Direction, EmitTag), 0, 0) >>16,
s:".   \ckDEVOUR Tag ",	i:TagAt (BlockCounter, Direction, DevourTag),
s:".   DEVOUR Floor ",	i:GetSectorFloorZ(TagAt (BlockCounter, Direction, DevourTag), 0, 0) >>16,
s:".   DEVOUR CEIL ", 	i:GetSectorCeilingZ(TagAt (BlockCounter, Direction, DevourTag), 0, 0) >>16
);
*/
return Delaay;

}





Script "Projectiles" (void)
{
int counter, fixHeight;

//GIMMICK FIX
while( counter <= RoundInfo[BorderExceptionCounter])
	{
	//EMIT
	fixHeight = GetSectorFloorZ(Projectila[counter][ProjParam_EMITSPOT], 0, 0) >> 16;
	if (fixHeight + ProjHoleSize > GetSectorCeilingZ(Projectila[counter][ProjParam_EMITSPOT], 0, 0) >> 16)
			{
			Floor_MoveToValue	(Projectila[counter][ProjParam_EMITSPOT], 			MoveInstantly, RoundInfo[GlobalFloorHeight]);
			Ceiling_MoveToValue	(Projectila[counter][ProjParam_EMITSPOT], 			MoveInstantly, RoundInfo[GlobalCeilingHeight]);
			}
	//DEVOUR
	fixHeight = GetSectorFloorZ(Projectila[counter][ProjParam_DEVOURSPOT], 0, 0) >> 16;
	if (fixHeight + ProjHoleSize > GetSectorCeilingZ(Projectila[counter][ProjParam_DEVOURSPOT], 0, 0) >> 16)
			{
			Floor_MoveToValue	(Projectila[counter][ProjParam_DEVOURSPOT], 			MoveInstantly, RoundInfo[GlobalFloorHeight]);
			Ceiling_MoveToValue	(Projectila[counter][ProjParam_DEVOURSPOT], 			MoveInstantly, RoundInfo[GlobalCeilingHeight]);
			}
	counter++;
	}

counter = 0;
while(TRUE)
	{
	counter = 0;
	while( counter <= RoundInfo[BorderExceptionCounter])
		{
		if (Projectila[counter][ProjParam_EMITSPOT] != 0)
					{
					if (Projectila[counter][ProjParam_TIMER] == 0)	//if it's time to fire a projectile
							{
							/*
								//EMIT
								fixHeight = GetSectorFloorZ(Projectila[counter][ProjParam_EMITSPOT], 0, 0) >> 16;
								if (fixHeight == GetSectorCeilingZ(Projectila[counter][ProjParam_EMITSPOT], 0, 0) >> 16)
										{
										//Floor_MoveToValue	(Projectila[counter][ProjParam_EMITSPOT], 			MoveInstantly, fixHeight - 64);
										Ceiling_MoveToValue	(Projectila[counter][ProjParam_EMITSPOT], 			MoveInstantly, fixHeight +	ProjHoleSize);
										}
								//DEVOUR
								if ((GetSectorFloorZ(Projectila[counter][ProjParam_EMITSPOT], 0, 0) >> 16) > fixHeight)
										{
										Floor_MoveToValue	(Projectila[counter][ProjParam_EMITSPOT], 			MoveInstantly, fixHeight);
										delay(GenDel_Height);
										}



								if ((GetSectorCeilingZ(Projectila[counter][ProjParam_EMITSPOT], 0, 0) >> 16) < fixHeight +	ProjHoleSize)
										{
										Ceiling_MoveToValue	(Projectila[counter][ProjParam_EMITSPOT], 			MoveInstantly, fixHeight +	ProjHoleSize);
										delay(GenDel_Height);
										}

							*/



							RefreshSpotHeight(refreshspot_PROJECTILE, counter);
							SpawnProjectile(Projectila[counter][ProjParam_EMITSPOT], ActorString(Projectila[counter][ProjParam_TYPE], as_CODE), Projectila[counter][ProjParam_ANGLE], Projectila[counter][ProjParam_SPEED], 0, 0, ACTORTID_Projectile);
							Projectila[counter][ProjParam_TIMER] = Projectila[counter][ProjParam_DELAY];	//Refresh timer for this projectile
							}

					else	Projectila[counter][ProjParam_TIMER]--;
					}
		counter++;
		}

	delay(1);
	}
}




Script SCRIPT_DestroyProjectile (void)
{
if ((ClassifyActor(0) & ACTOR_PLAYER) | (ClassifyActor(0) & ACTOR_MONSTER)) Terminate;
if (LineSide() == LINE_FRONT)	Thing_Remove(0);
}


Script SCRIPT_FadeProjectile (void)
{
if ((ClassifyActor(0) & ACTOR_PLAYER) | (ClassifyActor(0) & ACTOR_MONSTER)) Terminate;
if ((GetActorProperty(0, APROP_RenderStyle) != STYLE_Translucent) && (GetActorProperty(0, APROP_RenderStyle) != STYLE_Add))		SetActorProperty(0, APROP_RenderStyle, STYLE_Translucent);

SetActorProperty(0, APROP_Alpha, 	GetActorProperty(0, APROP_Alpha) - 0.1);
}




function int SetWorm 	(int BlockCounter, int Direction, int Tag)
{
int Deelay = 1;
int counter;

Worm[None][WormParam_COUNT]++;
counter = Worm[None][WormParam_COUNT];

Worm[counter][WormParam_Y]				=		MiniBlockAtAXIS(AxisY, Tag);
Worm[counter][WormParam_X]				=		MiniBlockAtAXIS(AxisX, Tag);
Worm[counter][WormParam_DELAY]			=		60 - AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]/2;
Worm[counter][WormParam_BLOCKCOUNTER]	=		BlockCounter;

return Deelay;
}



Script "Worms" (void)
{
int Direction, counter, X, Y, i;


while(TRUE)
	{
	counter = 0;
	while( counter < Worm[None][WormParam_COUNT])
		{
		counter++;
					if (RoundInfo[WormsRestart])
						{
							for(i = 0; i < 64; i++)
								{
								if (CheckActorFloorTexture	(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, i), TextureIs(FlatBASEtx)))
												ChangeFloor	(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, i), TextureIs(FlatWATEtx));
								}
						ChangeFloor(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[Worm[counter][WormParam_Y]][Worm[counter][WormParam_X]]), 	 	TextureIs(FlatWORMtx));
						delay(5);
						}

					if (!Worm[counter][WormParam_TIMER])
							{
							Direction = RNG(1,4);

							Switch(Direction)
								{
								CASE ToRIGHT:	X = 1;		Y = 0;		break;
								CASE ToDOWN:	X = 0;		Y = 1;		break;
								CASE ToLEFT:	X = -1;		Y = 0;		break;
								CASE ToUP:		X = 0;		Y = -1;		break;
								}


							if (	CheckActorFloorTexture	(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y] + Y]		[Worm[counter][WormParam_X] + X]	), 				TextureIs(FlatWATEtx)))
							if (!	CheckActorFloorTexture	(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y] + Y]		[Worm[counter][WormParam_X] + X]	), 				TextureIs(FlatWORMtx)))	//another worm
									if (GetSectorFloorZ	(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y] + Y]		[Worm[counter][WormParam_X] + X]	), 0, 0) 	== 	GetSectorFloorZ(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y]]		[Worm[counter][WormParam_X]]	), 0, 0))
											{

											//First change the current floor
											ChangeFloor(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y]]		[Worm[counter][WormParam_X]]	), 		TextureIs(FlatWATEtx));
											Worm[counter][WormParam_Y] = Worm[counter][WormParam_Y] + Y;
											Worm[counter][WormParam_X] = Worm[counter][WormParam_X] + X;

											//Then set the new floor
											ChangeFloor(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y]]		[Worm[counter][WormParam_X]]	), 	TextureIs(FlatWORMtx));
											ThingSound(TagAt (Worm[counter][WormParam_BLOCKCOUNTER], ToRIGHT, 	MiniBlockAt[	Worm[counter][WormParam_Y]]		[Worm[counter][WormParam_X]]	), 	"SFXWORM", RNG(24, 64));
											}


							Worm[counter][WormParam_TIMER] = Worm[counter][WormParam_DELAY];
							}

					else	Worm[counter][WormParam_TIMER]--;

		}
	RoundInfo[WormsRestart] = FALSE;
	delay(1);
	}
}



function int SetSoil 	(int BlockCounter, int Direction)
{
int Deelay = 1;
int counter;
int Type;

Soil[None][SoilParam_COUNT]++;
counter = Soil[None][SoilParam_COUNT];
Soil[counter][SoilParam_BLOCKCOUNTER]	=		BlockCounter;

if (RNG(1, 100) > 66)		Type = SoilICE;
else						Type = SoilMUD;
Soil[counter][SoilParam_TYPE]			=		Type;

return Deelay;
}




Script "Soil" (void)
{
int Direction, counter, i, tx;




while(TRUE)
	{
	counter = 0;
	while( counter < Soil[None][SoilParam_COUNT])
		{
		counter++;
					if (RoundInfo[SoilRestart])
						{

						Switch(Soil[counter][SoilParam_TYPE])
							{
							case SoilICE:	tx = FlatICEYtx;		break;
							case SoilMUD:	tx = FlatMUDDtx;		break;
							}



							for(i = 0; i < 64; i++)
								{
								if (CheckActorFloorTexture	(TagAt (Soil[counter][SoilParam_BLOCKCOUNTER], ToRIGHT, i), TextureIs(FlatBASEtx)))
												ChangeFloor	(TagAt (Soil[counter][SoilParam_BLOCKCOUNTER], ToRIGHT, i), TextureIs(tx));
								}
						delay(5);
						}


		}
	RoundInfo[SoilRestart] = FALSE;
	delay(1);
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////



function int BlockAtAXIS (int Which, int Num)
{
int Result, Y, X;
Switch (Num)
	{
	CASE  1:Y = 0; X = 0;break;CASE  2:Y = 0; X = 1;break;CASE  3:Y = 0; X = 2;break;CASE  4:Y = 0; X = 3;break;CASE  5:Y = 0; X = 4;break;
	CASE  6:Y = 1; X = 0;break;CASE  7:Y = 1; X = 1;break;CASE  8:Y = 1; X = 2;break;CASE  9:Y = 1; X = 3;break;CASE 10:Y = 1; X = 4;break;
	CASE 11:Y = 2; X = 0;break;CASE 12:Y = 2; X = 1;break;CASE 13:Y = 2; X = 2;break;CASE 14:Y = 2; X = 3;break;CASE 15:Y = 2; X = 4;break;
	CASE 16:Y = 3; X = 0;break;CASE 17:Y = 3; X = 1;break;CASE 18:Y = 3; X = 2;break;CASE 19:Y = 3; X = 3;break;CASE 20:Y = 3; X = 4;break;
	CASE 21:Y = 4; X = 0;break;CASE 22:Y = 4; X = 1;break;CASE 23:Y = 4; X = 2;break;CASE 24:Y = 4; X = 3;break;CASE 25:Y = 4; X = 4;break;
	}


Switch(Which)
	{
	CASE AxisY: Result = Y; break;
	CASE AxisX: Result = X; break;
	}

return Result;
}


function int MiniBlockAtAXIS (int Which, int Num)
{
int Result, Y, X;
Switch (Num)
	{
	CASE 90:Y = 0; X = 0;break;		CASE 91:Y = 0; X = 1;break;		CASE 92:Y = 0; X = 2;break;		CASE 93:Y = 0; X = 3;break;		CASE 94:Y = 0; X = 4;break;		CASE 95:Y = 0; X = 5;break;		CASE 96:Y = 0; X = 6;break;		CASE 97:Y = 0; X = 7;break;		CASE 98:Y = 0; X = 8;break;		CASE 99:Y = 0; X = 9;break;
	CASE 89:Y = 1; X = 0;break;		CASE  0:Y = 1; X = 1;break;		CASE  1:Y = 1; X = 2;break;		CASE  2:Y = 1; X = 3;break;		CASE  3:Y = 1; X = 4;break;		CASE  4:Y = 1; X = 5;break;		CASE  5:Y = 1; X = 6;break;		CASE  6:Y = 1; X = 7;break;		CASE  7:Y = 1; X = 8;break;		CASE 64:Y = 1; X = 9;break;
	CASE 88:Y = 2; X = 0;break;		CASE  8:Y = 2; X = 1;break;		CASE  9:Y = 2; X = 2;break;		CASE 10:Y = 2; X = 3;break;		CASE 11:Y = 2; X = 4;break;		CASE 12:Y = 2; X = 5;break;		CASE 13:Y = 2; X = 6;break;		CASE 14:Y = 2; X = 7;break;		CASE 15:Y = 2; X = 8;break;		CASE 65:Y = 2; X = 9;break;
	CASE 87:Y = 3; X = 0;break;		CASE 16:Y = 3; X = 1;break;		CASE 17:Y = 3; X = 2;break;		CASE 18:Y = 3; X = 3;break;		CASE 19:Y = 3; X = 4;break;		CASE 20:Y = 3; X = 5;break;		CASE 21:Y = 3; X = 6;break;		CASE 22:Y = 3; X = 7;break;		CASE 23:Y = 3; X = 8;break;		CASE 66:Y = 3; X = 9;break;
	CASE 86:Y = 4; X = 0;break;		CASE 24:Y = 4; X = 1;break;		CASE 25:Y = 4; X = 2;break;		CASE 26:Y = 4; X = 3;break;		CASE 27:Y = 4; X = 4;break;		CASE 28:Y = 4; X = 5;break;		CASE 29:Y = 4; X = 6;break;		CASE 30:Y = 4; X = 7;break;		CASE 31:Y = 4; X = 8;break;		CASE 67:Y = 4; X = 9;break;
	CASE 85:Y = 5; X = 0;break;		CASE 32:Y = 5; X = 1;break;		CASE 33:Y = 5; X = 2;break;		CASE 34:Y = 5; X = 3;break;		CASE 35:Y = 5; X = 4;break;		CASE 36:Y = 5; X = 5;break;		CASE 37:Y = 5; X = 6;break;		CASE 38:Y = 5; X = 7;break;		CASE 39:Y = 5; X = 8;break;		CASE 68:Y = 5; X = 9;break;
	CASE 84:Y = 6; X = 0;break;		CASE 40:Y = 6; X = 1;break;		CASE 41:Y = 6; X = 2;break;		CASE 42:Y = 6; X = 3;break;		CASE 43:Y = 6; X = 4;break;		CASE 44:Y = 6; X = 5;break;		CASE 45:Y = 6; X = 6;break;		CASE 46:Y = 6; X = 7;break;		CASE 47:Y = 6; X = 8;break;		CASE 69:Y = 6; X = 9;break;
	CASE 83:Y = 7; X = 0;break;		CASE 48:Y = 7; X = 1;break;		CASE 49:Y = 7; X = 2;break;		CASE 50:Y = 7; X = 3;break;		CASE 51:Y = 7; X = 4;break;		CASE 52:Y = 7; X = 5;break;		CASE 53:Y = 7; X = 6;break;		CASE 54:Y = 7; X = 7;break;		CASE 55:Y = 7; X = 8;break;		CASE 70:Y = 7; X = 9;break;
	CASE 82:Y = 8; X = 0;break;		CASE 56:Y = 8; X = 1;break;		CASE 57:Y = 8; X = 2;break;		CASE 58:Y = 8; X = 3;break;		CASE 59:Y = 8; X = 4;break;		CASE 60:Y = 8; X = 5;break;		CASE 61:Y = 8; X = 6;break;		CASE 62:Y = 8; X = 7;break;		CASE 63:Y = 8; X = 8;break;		CASE 71:Y = 8; X = 9;break;
	CASE 81:Y = 9; X = 0;break;		CASE 80:Y = 9; X = 1;break;		CASE 79:Y = 9; X = 2;break;		CASE 78:Y = 9; X = 3;break;		CASE 77:Y = 9; X = 4;break;		CASE 76:Y = 9; X = 5;break;		CASE 75:Y = 9; X = 6;break;		CASE 74:Y = 9; X = 7;break;		CASE 73:Y = 9; X = 8;break;		CASE 72:Y = 9; X = 9;break;
	}


Switch(Which)
	{
	CASE AxisY: Result = Y; break;
	CASE AxisX: Result = X; break;
	}

return Result;
}






function str BlockAtBC (int Num)
{
str Result = "";
Switch (Num)
	{
	CASE  1:Result=BlockAt[0][0];break;CASE  2:Result=BlockAt[0][1];break;CASE  3:Result=BlockAt[0][2];break;CASE  4:Result=BlockAt[0][3];break;CASE  5:Result=BlockAt[0][4];break;CASE  6:Result=BlockAt[0][5];break;CASE  7:Result=BlockAt[0][6];break;
	CASE  8:Result=BlockAt[1][0];break;CASE  9:Result=BlockAt[1][1];break;CASE 10:Result=BlockAt[1][2];break;CASE 11:Result=BlockAt[1][3];break;CASE 12:Result=BlockAt[1][4];break;CASE 13:Result=BlockAt[1][5];break;CASE 14:Result=BlockAt[1][6];break;
	CASE 15:Result=BlockAt[2][0];break;CASE 16:Result=BlockAt[2][1];break;CASE 17:Result=BlockAt[2][2];break;CASE 18:Result=BlockAt[2][3];break;CASE 19:Result=BlockAt[2][4];break;CASE 20:Result=BlockAt[2][5];break;CASE 21:Result=BlockAt[2][6];break;
	CASE 22:Result=BlockAt[3][0];break;CASE 23:Result=BlockAt[3][1];break;CASE 24:Result=BlockAt[3][2];break;CASE 25:Result=BlockAt[3][3];break;CASE 26:Result=BlockAt[3][4];break;CASE 27:Result=BlockAt[3][5];break;CASE 28:Result=BlockAt[3][6];break;
	CASE 29:Result=BlockAt[4][0];break;CASE 30:Result=BlockAt[4][1];break;CASE 31:Result=BlockAt[4][2];break;CASE 32:Result=BlockAt[4][3];break;CASE 33:Result=BlockAt[4][4];break;CASE 34:Result=BlockAt[4][5];break;CASE 35:Result=BlockAt[4][6];break;
	CASE 36:Result=BlockAt[5][0];break;CASE 37:Result=BlockAt[5][1];break;CASE 38:Result=BlockAt[5][2];break;CASE 39:Result=BlockAt[5][3];break;CASE 40:Result=BlockAt[5][4];break;CASE 41:Result=BlockAt[5][5];break;CASE 42:Result=BlockAt[5][6];break;
	CASE 43:Result=BlockAt[6][0];break;CASE 44:Result=BlockAt[6][1];break;CASE 45:Result=BlockAt[6][2];break;CASE 46:Result=BlockAt[6][3];break;CASE 47:Result=BlockAt[6][4];break;CASE 48:Result=BlockAt[6][5];break;CASE 49:Result=BlockAt[6][6];break;
	}
return Result;
}




function bool CheckArea(int ContainerType, int Direction, int RowNum, int ColumnNum)
{
bool Result; int FreeBlocks;
for (int y = RowNum; 	y < RowNum		+ ContainerMass(AxisY, ContainerType, Direction); y++) {
for (int x = ColumnNum; x < ColumnNum 	+ ContainerMass(AxisX, ContainerType, Direction); x++) {

	if 	(
		(StrLen(BlockAt	[Y]	[X]) <= 1)  &&
			(
			( ColumnNum 	+ ContainerMass(AxisX, ContainerType, Direction)	<=	sqrt(PlaygroundBlocks))	&&
			( RowNum		+ ContainerMass(AxisY, ContainerType, Direction)	<=	sqrt(PlaygroundBlocks))
			)
		)
	FreeBlocks++;




}}

	if (FreeBlocks == ContainerType) 	Result = true;
	else Result = false;



Return Result;
}


function void FillArea(int WhatToDo, int ContainerType, int Direction, int RowNum, int ColumnNum, int VecIn, int VecOut, int Zpecial)
{
int x, y;
str StrDir = "";	str StrVecIn = "";	str StrVecOut = "";	str StrZpe = "";


Switch(WhatToDo)
{
CASE 0:

for (y = 0; y < sqrt(PlaygroundBlocks); y++) {
for (x = 0; x < sqrt(PlaygroundBlocks); x++) {

BlockAt[Y][X] = "X";


}}


break;

CASE 1:

//debug
int color  = RNG(97, 122);
if (color == 108) color = 99;
str Dir = "";



Switch(Direction)
	{
	CASE NONE:			StrDir = "*";	break;
	CASE ToRight:		StrDir = ">";	break;
	CASE ToDown:		StrDir = "v";	break;
	CASE ToLeft:		StrDir = "<";	break;
	CASE ToUp:			StrDir = "^";	break;
	}


Switch(VecIn)
	{
	CASE NONE:			StrVecIn = "*";	break;
	CASE ToRight:		StrVecIn = ">";	break;
	CASE ToDown:		StrVecIn = "v";	break;
	CASE ToLeft:		StrVecIn = "<";	break;
	CASE ToUp:			StrVecIn = "^";	break;
	}

Switch(VecOut)
	{
	CASE NONE:			StrVecOut = "*";break;
	CASE ToRight:		StrVecOut = ">";break;
	CASE ToDown:		StrVecOut = "v";break;
	CASE ToLeft:		StrVecOut = "<";break;
	CASE ToUp:			StrVecOut = "^";break;
	}

Switch(Zpecial)
	{
	CASE NONE:						StrZpe = "--";	break;
	CASE Stairs_NORMAL:				StrZpe = "SN";	break;
	CASE Stairs_DIAGONAL_right:		StrZpe = "dR";	break;
	CASE Stairs_DIAGONAL_left:		StrZpe = "dL";	break;
	CASE StartBlock:				StrZpe = "$$";	break;
	CASE FinishBlock:				StrZpe = "XX";	break;
	}

for (y = RowNum; 	y < RowNum		+ ContainerMass(AxisY, ContainerType, Direction); y++) {
for (x = ColumnNum; x < ColumnNum 	+ ContainerMass(AxisX, ContainerType, Direction); x++) {


	Switch(GetPort())
	{
	Case ZDaemon:
		BlockAt[Y][X] = ContainerStr(ContainerType, Direction);
		//BlockAt[Y][X] = StrParam(i:ContainerType, i:Direction);
		break;
	Case Zandronum: Case GZDoom:
		BlockAt[Y][X] = StrParam(s:"\c", c:color, s:StrDir, i:ContainerType, s:StrZpe, s:StrVecIn, s:StrVecOut, s:"\cl");
		break;
	}


}}

break;
}


}









function bool BlockCounterAtTheEdge (int Side, int BlockCounter)
{
int i;
bool Result;

Switch(SIDE)
	{
	CASE ToRIGHT:
	for (i = 1; i <= sqrt(PlaygroundBlocks); i++)
	if 		(BlockCounter == (sqrt(PlaygroundBlocks)*i))							Result = TRUE;
	break;


	CASE ToDOWN:
	if 		(BlockCounter > (PlaygroundBlocks - sqrt(PlaygroundBlocks))) 			Result = TRUE;
	break;


	CASE ToLEFT:
	for (i = 0; i < sqrt(PlaygroundBlocks); i++)
	if 		(BlockCounter == (sqrt(PlaygroundBlocks)*i + 1))						Result = TRUE;
	break;


	CASE ToUP:
	if 		((BlockCounter > 0) && (BlockCounter <= sqrt(PlaygroundBlocks)))		Result = TRUE;
	break;
	}



return Result;
}





function int LineAt (int BlockCounter, int Direction, int Line)		//BlockCounter is only needed to check if its the edge of the map
{
int Result, A;
if (Line == ImpossibleNum)	A = ImpossibleNum;
else
Switch(Direction)
	{
	Case ToRIGHT:

	Switch(Line)
			{
			Case  0: A = ImpossibleNum;												break;		//BASIC INSIDE
			Case  1: A = B2S(BlockCounter) +  1;									break;		//INNER RIGHT
			Case  2: A = B2S(BlockCounter) +  2;									break;		//INNER DOWN
			Case  3: A = B2S(BlockCounter) +  1 -	B2S(1);							break;		//INNER LEFT
			Case  4: A = B2S(BlockCounter) +  2 -	B2S(sqrt(PlaygroundBlocks));	break;		//INNER UP
			Case 99: A = B2S(BlockCounter) +  0;									break;		//BASIC BORDER

	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) + 21;	break;										Case 22: A = B2S(BlockCounter) + 22;	break;										Case 23: A = B2S(BlockCounter) + 23;	break;
			Case 24: A = B2S(BlockCounter) + 24;	break;										Case 25: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) + 26;	break;										Case 27: A = B2S(BlockCounter) + 27;	break;										Case 28: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) + 31;	break;										Case 32: A = B2S(BlockCounter) + 32;	break;										Case 33: A = B2S(BlockCounter) + 33;	break;
			Case 34: A = B2S(BlockCounter) + 34;	break;										Case 35: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) + 36;	break;										Case 37: A = B2S(BlockCounter) + 37;	break;										Case 38: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) + 20;	break;										Case 30: A = B2S(BlockCounter) + 30;	break;										Case 29: A = B2S(BlockCounter) + 29;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) + 41;	break;										Case 42: A = B2S(BlockCounter) + 42;	break;										Case 43: A = B2S(BlockCounter) + 43;	break;
			Case 44: A = B2S(BlockCounter) + 44;	break;										Case 45: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) + 46;	break;										Case 47: A = B2S(BlockCounter) + 47;	break;										Case 48: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) + 51;	break;										Case 52: A = B2S(BlockCounter) + 52;	break;										Case 53: A = B2S(BlockCounter) + 53;	break;
			Case 54: A = B2S(BlockCounter) + 54;	break;										Case 55: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) + 56;	break;										Case 57: A = B2S(BlockCounter) + 57;	break;										Case 58: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) + 40;	break;										Case 50: A = B2S(BlockCounter) + 50;	break;										Case 49: A = B2S(BlockCounter) + 49;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) - 62;	break;										Case 62: A = B2S(BlockCounter) - 63;	break;										Case 63: A = B2S(BlockCounter) - 64;	break;
			Case 64: A = B2S(BlockCounter) - 65;	break;										Case 65: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) - 67;	break;										Case 67: A = B2S(BlockCounter) - 68;	break;										Case 68: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) - 72;	break;										Case 72: A = B2S(BlockCounter) - 73;	break;										Case 73: A = B2S(BlockCounter) - 74;	break;
			Case 74: A = B2S(BlockCounter) - 75;	break;										Case 75: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) - 77;	break;										Case 77: A = B2S(BlockCounter) - 78;	break;										Case 78: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) - 70;	break;										Case 70: A = B2S(BlockCounter) - 80;	break;										Case 69: A = B2S(BlockCounter) - 71;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 82: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 83: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 84: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 85: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 87: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 88: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 92: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 93: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 94: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 95: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 97: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 98: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 90: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 89: A = B2S(BlockCounter) + 49;	break;
			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;

	Case ToDOWN:

	Switch(Line)
			{
			Case  0: A = ImpossibleNum;												break;		//BASIC INSIDE
			Case  1: A = B2S(BlockCounter) +  2 -	B2S(sqrt(PlaygroundBlocks));	break;		//INNER UP
			Case  2: A = B2S(BlockCounter) +  1;									break;		//INNER RIGHT
			Case  3: A = B2S(BlockCounter) +  2;									break;		//INNER DOWN
			Case  4: A = B2S(BlockCounter) +  1 -	B2S(1);							break;		//INNER LEFT
			Case 99: A = B2S(BlockCounter) +  0;									break;		//BASIC BORDER

	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) + 41;	break;										Case 22: A = B2S(BlockCounter) + 42;	break;										Case 23: A = B2S(BlockCounter) + 43;	break;
			Case 24: A = B2S(BlockCounter) + 44;	break;										Case 25: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) + 46;	break;										Case 27: A = B2S(BlockCounter) + 47;	break;										Case 28: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) + 51;	break;										Case 32: A = B2S(BlockCounter) + 52;	break;										Case 33: A = B2S(BlockCounter) + 53;	break;
			Case 34: A = B2S(BlockCounter) + 54;	break;										Case 35: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) + 56;	break;										Case 37: A = B2S(BlockCounter) + 57;	break;										Case 38: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) + 40;	break;										Case 30: A = B2S(BlockCounter) + 50;	break;										Case 29: A = B2S(BlockCounter) + 49;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) - 62;	break;										Case 42: A = B2S(BlockCounter) - 63;	break;										Case 43: A = B2S(BlockCounter) - 64;	break;
			Case 44: A = B2S(BlockCounter) - 65;	break;										Case 45: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) - 67;	break;										Case 47: A = B2S(BlockCounter) - 68;	break;										Case 48: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) - 72;	break;										Case 52: A = B2S(BlockCounter) - 73;	break;										Case 53: A = B2S(BlockCounter) - 74;	break;
			Case 54: A = B2S(BlockCounter) - 75;	break;										Case 55: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) - 77;	break;										Case 57: A = B2S(BlockCounter) - 78;	break;										Case 58: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) - 70;	break;										Case 50: A = B2S(BlockCounter) - 80;	break;										Case 49: A = B2S(BlockCounter) - 71;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 62: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 63: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 64: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 65: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 67: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 68: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 72: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 73: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 74: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 75: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 77: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 78: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 70: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 69: A = B2S(BlockCounter) + 49;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) + 21;	break;										Case 82: A = B2S(BlockCounter) + 22;	break;										Case 83: A = B2S(BlockCounter) + 23;	break;
			Case 84: A = B2S(BlockCounter) + 24;	break;										Case 85: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) + 26;	break;										Case 87: A = B2S(BlockCounter) + 27;	break;										Case 88: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 31;	break;										Case 92: A = B2S(BlockCounter) + 32;	break;										Case 93: A = B2S(BlockCounter) + 33;	break;
			Case 94: A = B2S(BlockCounter) + 34;	break;										Case 95: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) + 36;	break;										Case 97: A = B2S(BlockCounter) + 37;	break;										Case 98: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) + 20;	break;										Case 90: A = B2S(BlockCounter) + 30;	break;										Case 89: A = B2S(BlockCounter) + 29;	break;

			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;

	Case ToLEFT:

	Switch(Line)
			{
			Case  0: A = ImpossibleNum;												break;		//BASIC INSIDE
			Case  1: A = B2S(BlockCounter) +  1 -	B2S(1);							break;		//INNER LEFT
			Case  2: A = B2S(BlockCounter) +  2 -	B2S(sqrt(PlaygroundBlocks));	break;		//INNER UP
			Case  3: A = B2S(BlockCounter) +  1;									break;		//INNER RIGHT
			Case  4: A = B2S(BlockCounter) +  2;									break;		//INNER DOWN
			Case 99: A = B2S(BlockCounter) +  0;									break;		//BASIC BORDER


	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) - 62;	break;										Case 22: A = B2S(BlockCounter) - 63;	break;										Case 23: A = B2S(BlockCounter) - 64;	break;
			Case 24: A = B2S(BlockCounter) - 65;	break;										Case 25: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) - 67;	break;										Case 27: A = B2S(BlockCounter) - 68;	break;										Case 28: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) - 72;	break;										Case 32: A = B2S(BlockCounter) - 73;	break;										Case 33: A = B2S(BlockCounter) - 74;	break;
			Case 34: A = B2S(BlockCounter) - 75;	break;										Case 35: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) - 77;	break;										Case 37: A = B2S(BlockCounter) - 78;	break;										Case 38: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) - 70;	break;										Case 30: A = B2S(BlockCounter) - 80;	break;										Case 29: A = B2S(BlockCounter) - 71;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 42: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 43: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 44: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 45: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 47: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 48: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 52: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 53: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 54: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 55: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 57: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 58: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 50: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 49: A = B2S(BlockCounter) + 49;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) + 21;	break;										Case 62: A = B2S(BlockCounter) + 22;	break;										Case 63: A = B2S(BlockCounter) + 23;	break;
			Case 64: A = B2S(BlockCounter) + 24;	break;										Case 65: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) + 26;	break;										Case 67: A = B2S(BlockCounter) + 27;	break;										Case 68: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) + 31;	break;										Case 72: A = B2S(BlockCounter) + 32;	break;										Case 73: A = B2S(BlockCounter) + 33;	break;
			Case 74: A = B2S(BlockCounter) + 34;	break;										Case 75: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) + 36;	break;										Case 77: A = B2S(BlockCounter) + 37;	break;										Case 78: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) + 20;	break;										Case 70: A = B2S(BlockCounter) + 30;	break;										Case 69: A = B2S(BlockCounter) + 29;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) + 41;	break;										Case 82: A = B2S(BlockCounter) + 42;	break;										Case 83: A = B2S(BlockCounter) + 43;	break;
			Case 84: A = B2S(BlockCounter) + 44;	break;										Case 85: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) + 46;	break;										Case 87: A = B2S(BlockCounter) + 47;	break;										Case 88: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 51;	break;										Case 92: A = B2S(BlockCounter) + 52;	break;										Case 93: A = B2S(BlockCounter) + 53;	break;
			Case 94: A = B2S(BlockCounter) + 54;	break;										Case 95: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) + 56;	break;										Case 97: A = B2S(BlockCounter) + 57;	break;										Case 98: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) + 40;	break;										Case 90: A = B2S(BlockCounter) + 50;	break;										Case 89: A = B2S(BlockCounter) + 49;	break;
			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;

	Case ToUP:

	Switch(Line)
			{
			Case  0: A = ImpossibleNum;												break;		//BASIC INSIDE
			Case  1: A = B2S(BlockCounter) +  2;									break;		//INNER DOWN
			Case  2: A = B2S(BlockCounter) +  1 -	B2S(1);							break;		//INNER LEFT
			Case  3: A = B2S(BlockCounter) +  2 -	B2S(sqrt(PlaygroundBlocks));	break;		//INNER UP
			Case  4: A = B2S(BlockCounter) +  1;									break;		//INNER RIGHT
			Case 99: A = B2S(BlockCounter) +  0;									break;		//BASIC BORDER



	//Right Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 21: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 58;	break;			Case 22: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 57;	break;			Case 23: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 56;	break;
			Case 24: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 55;	break;			Case 25: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 54;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 26: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 53;	break;			Case 27: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 52;	break;			Case 28: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 51;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 31: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 48;	break;			Case 32: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 47;	break;			Case 33: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 46;	break;
			Case 34: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 45;	break;			Case 35: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 44;	break;			//   < - - -  E N T R A N C E   T A G S   ---
			Case 36: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 43;	break;			Case 37: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 42;	break;			Case 38: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 41;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 20: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 50;	break;			Case 30: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 40;	break;			Case 29: A = B2S(BlockCounter) + 49;	break;

	//Down Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 41: A = B2S(BlockCounter) + 21;	break;										Case 42: A = B2S(BlockCounter) + 22;	break;										Case 43: A = B2S(BlockCounter) + 23;	break;
			Case 44: A = B2S(BlockCounter) + 24;	break;										Case 45: A = B2S(BlockCounter) + 25;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 46: A = B2S(BlockCounter) + 26;	break;										Case 47: A = B2S(BlockCounter) + 27;	break;										Case 48: A = B2S(BlockCounter) + 28;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 51: A = B2S(BlockCounter) + 31;	break;										Case 52: A = B2S(BlockCounter) + 32;	break;										Case 53: A = B2S(BlockCounter) + 33;	break;
			Case 54: A = B2S(BlockCounter) + 34;	break;										Case 55: A = B2S(BlockCounter) + 35;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 56: A = B2S(BlockCounter) + 36;	break;										Case 57: A = B2S(BlockCounter) + 37;	break;										Case 58: A = B2S(BlockCounter) + 38;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 40: A = B2S(BlockCounter) + 20;	break;										Case 50: A = B2S(BlockCounter) + 30;	break;										Case 49: A = B2S(BlockCounter) + 29;	break;

	//Left Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 61: A = B2S(BlockCounter) + 41;	break;										Case 62: A = B2S(BlockCounter) + 42;	break;										Case 63: A = B2S(BlockCounter) + 43;	break;
			Case 64: A = B2S(BlockCounter) + 44;	break;										Case 65: A = B2S(BlockCounter) + 45;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 66: A = B2S(BlockCounter) + 46;	break;										Case 67: A = B2S(BlockCounter) + 47;	break;										Case 68: A = B2S(BlockCounter) + 48;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 71: A = B2S(BlockCounter) + 51;	break;										Case 72: A = B2S(BlockCounter) + 52;	break;										Case 73: A = B2S(BlockCounter) + 53;	break;
			Case 74: A = B2S(BlockCounter) + 54;	break;										Case 75: A = B2S(BlockCounter) + 55;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 76: A = B2S(BlockCounter) + 56;	break;										Case 77: A = B2S(BlockCounter) + 57;	break;										Case 78: A = B2S(BlockCounter) + 58;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 60: A = B2S(BlockCounter) + 40;	break;										Case 70: A = B2S(BlockCounter) + 50;	break;										Case 69: A = B2S(BlockCounter) + 49;	break;

	//Up Side
			// INNER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: A = B2S(BlockCounter) - 62;	break;										Case 82: A = B2S(BlockCounter) - 63;	break;										Case 83: A = B2S(BlockCounter) - 64;	break;
			Case 84: A = B2S(BlockCounter) - 65;	break;										Case 85: A = B2S(BlockCounter) - 66;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 86: A = B2S(BlockCounter) - 67;	break;										Case 87: A = B2S(BlockCounter) - 68;	break;										Case 88: A = B2S(BlockCounter) - 69;	break;
			// OUTER--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - 72;	break;										Case 92: A = B2S(BlockCounter) - 73;	break;										Case 93: A = B2S(BlockCounter) - 74;	break;
			Case 94: A = B2S(BlockCounter) - 75;	break;										Case 95: A = B2S(BlockCounter) - 76;	break;										//   < - - -  E N T R A N C E   T A G S   ---
			Case 96: A = B2S(BlockCounter) - 77;	break;										Case 97: A = B2S(BlockCounter) - 78;	break;										Case 98: A = B2S(BlockCounter) - 79;	break;
			// ENTRY JAMBS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 80: A = B2S(BlockCounter) - 70;	break;										Case 90: A = B2S(BlockCounter) - 80;	break;										Case 89: A = B2S(BlockCounter) - 71;	break;
			}
//----------------  LINE IS IN BLIND AREA
						if 	(
							((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Line >= 21) && (Line <= 38))	||	// R
							((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Line >= 41) && (Line <= 58))	||	// D
							((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Line >= 61) && (Line <= 78))	||	// L
							((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Line >= 81) && (Line <= 98))		// U
							)

							A = ImpossibleNum;
			break;
	}
Result = A;
if ((Result >= 0)		&& 		(Result <= PlaygroundBlocks))			Result = ImpossibleNum;

return Result;
}














function int TagAt (int BlockCounter, int Direction, int Tag)		//BlockCounter is only needed to check if its the edge of the map
{
int Result;
int A;



Switch(Direction)
	{
	Case ToRIGHT:

	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) +  0;	break;														Case  1: A = B2S(BlockCounter) +  1;	break;														Case  2: A = B2S(BlockCounter) +  2;	break;														Case  3: A = B2S(BlockCounter) +  3;	break;
			Case  4: A = B2S(BlockCounter) +  4;	break;														Case  5: A = B2S(BlockCounter) +  5;	break;														Case  6: A = B2S(BlockCounter) +  6;	break;														Case  7: A = B2S(BlockCounter) +  7;	break;
			Case  8: A = B2S(BlockCounter) +  8;	break;														Case  9: A = B2S(BlockCounter) +  9;	break;														Case 10: A = B2S(BlockCounter) + 10;	break;														Case 11: A = B2S(BlockCounter) + 11;	break;
			Case 12: A = B2S(BlockCounter) + 12;	break;														Case 13: A = B2S(BlockCounter) + 13;	break;														Case 14: A = B2S(BlockCounter) + 14;	break;														Case 15: A = B2S(BlockCounter) + 15;	break;
			Case 16: A = B2S(BlockCounter) + 16;	break;														Case 17: A = B2S(BlockCounter) + 17;	break;														Case 18: A = B2S(BlockCounter) + 18;	break;														Case 19: A = B2S(BlockCounter) + 19;	break;
			Case 20: A = B2S(BlockCounter) + 20;	break;														Case 21: A = B2S(BlockCounter) + 21;	break;														Case 22: A = B2S(BlockCounter) + 22;	break;														Case 23: A = B2S(BlockCounter) + 23;	break;
			Case 24: A = B2S(BlockCounter) + 24;	break;														Case 25: A = B2S(BlockCounter) + 25;	break;														Case 26: A = B2S(BlockCounter) + 26;	break;														Case 27: A = B2S(BlockCounter) + 27;	break;
			Case 28: A = B2S(BlockCounter) + 28;	break;														Case 29: A = B2S(BlockCounter) + 29;	break;														Case 30: A = B2S(BlockCounter) + 30;	break;														Case 31: A = B2S(BlockCounter) + 31;	break;
			Case 32: A = B2S(BlockCounter) + 32;	break;														Case 33: A = B2S(BlockCounter) + 33;	break;														Case 34: A = B2S(BlockCounter) + 34;	break;														Case 35: A = B2S(BlockCounter) + 35;	break;
			Case 36: A = B2S(BlockCounter) + 36;	break;														Case 37: A = B2S(BlockCounter) + 37;	break;														Case 38: A = B2S(BlockCounter) + 38;	break;														Case 39: A = B2S(BlockCounter) + 39;	break;
			Case 40: A = B2S(BlockCounter) + 40;	break;														Case 41: A = B2S(BlockCounter) + 41;	break;														Case 42: A = B2S(BlockCounter) + 42;	break;														Case 43: A = B2S(BlockCounter) + 43;	break;
			Case 44: A = B2S(BlockCounter) + 44;	break;														Case 45: A = B2S(BlockCounter) + 45;	break;														Case 46: A = B2S(BlockCounter) + 46;	break;														Case 47: A = B2S(BlockCounter) + 47;	break;
			Case 48: A = B2S(BlockCounter) + 48;	break;														Case 49: A = B2S(BlockCounter) + 49;	break;														Case 50: A = B2S(BlockCounter) + 50;	break;														Case 51: A = B2S(BlockCounter) + 51;	break;
			Case 52: A = B2S(BlockCounter) + 52;	break;														Case 53: A = B2S(BlockCounter) + 53;	break;														Case 54: A = B2S(BlockCounter) + 54;	break;														Case 55: A = B2S(BlockCounter) + 55;	break;
			Case 56: A = B2S(BlockCounter) + 56;	break;														Case 57: A = B2S(BlockCounter) + 57;	break;														Case 58: A = B2S(BlockCounter) + 58;	break;														Case 59: A = B2S(BlockCounter) + 59;	break;
			Case 60: A = B2S(BlockCounter) + 60;	break;														Case 61: A = B2S(BlockCounter) + 61;	break;														Case 62: A = B2S(BlockCounter) + 62;	break;														Case 63: A = B2S(BlockCounter) + 63;	break;
//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) + 64;	break;														Case 65: A = B2S(BlockCounter) + 65;	break;														Case 66: A = B2S(BlockCounter) + 66;	break;
			Case 67: A = B2S(BlockCounter) + 67;	break;														Case 68: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) + 69;	break;														Case 70: A = B2S(BlockCounter) + 70;	break;														Case 71: A = B2S(BlockCounter) + 71;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) + 73;	break;														Case 74: A = B2S(BlockCounter) + 74;	break;														Case 75: A = B2S(BlockCounter) + 75;	break;
			Case 76: A = B2S(BlockCounter) + 76;	break;														Case 77: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) + 78;	break;														Case 79: A = B2S(BlockCounter) + 79;	break;														Case 80: A = B2S(BlockCounter) + 80;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) - 29;	break;														Case 83: A = B2S(BlockCounter) - 30;	break;														Case 84: A = B2S(BlockCounter) - 31;	break;
			Case 85: A = B2S(BlockCounter) - 32;	break;														Case 86: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) - 34;	break;														Case 88: A = B2S(BlockCounter) - 35;	break;														Case 89: A = B2S(BlockCounter) - 36;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 92: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 93: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 94: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 95: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 97: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 98: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) 	||	// D
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	||	// L
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;


	Case ToDOWN:
	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) +  7;	break;														Case  1: A = B2S(BlockCounter) + 15;	break;														Case  2: A = B2S(BlockCounter) + 23;	break;														Case  3: A = B2S(BlockCounter) + 31;	break;
			Case  4: A = B2S(BlockCounter) + 39;	break;														Case  5: A = B2S(BlockCounter) + 47;	break;														Case  6: A = B2S(BlockCounter) + 55;	break;														Case  7: A = B2S(BlockCounter) + 63;	break;
			Case  8: A = B2S(BlockCounter) +  6;	break;														Case  9: A = B2S(BlockCounter) + 14;	break;														Case 10: A = B2S(BlockCounter) + 22;	break;														Case 11: A = B2S(BlockCounter) + 30;	break;
			Case 12: A = B2S(BlockCounter) + 38;	break;														Case 13: A = B2S(BlockCounter) + 46;	break;														Case 14: A = B2S(BlockCounter) + 54;	break;														Case 15: A = B2S(BlockCounter) + 62;	break;
			Case 16: A = B2S(BlockCounter) +  5;	break;														Case 17: A = B2S(BlockCounter) + 13;	break;														Case 18: A = B2S(BlockCounter) + 21;	break;														Case 19: A = B2S(BlockCounter) + 29;	break;
			Case 20: A = B2S(BlockCounter) + 37;	break;														Case 21: A = B2S(BlockCounter) + 45;	break;														Case 22: A = B2S(BlockCounter) + 53;	break;														Case 23: A = B2S(BlockCounter) + 61;	break;
			Case 24: A = B2S(BlockCounter) +  4;	break;														Case 25: A = B2S(BlockCounter) + 12;	break;														Case 26: A = B2S(BlockCounter) + 20;	break;														Case 27: A = B2S(BlockCounter) + 28;	break;
			Case 28: A = B2S(BlockCounter) + 36;	break;														Case 29: A = B2S(BlockCounter) + 44;	break;														Case 30: A = B2S(BlockCounter) + 52;	break;														Case 31: A = B2S(BlockCounter) + 60;	break;
			Case 32: A = B2S(BlockCounter) +  3;	break;														Case 33: A = B2S(BlockCounter) + 11;	break;														Case 34: A = B2S(BlockCounter) + 19;	break;														Case 35: A = B2S(BlockCounter) + 27;	break;
			Case 36: A = B2S(BlockCounter) + 35;	break;														Case 37: A = B2S(BlockCounter) + 43;	break;														Case 38: A = B2S(BlockCounter) + 51;	break;														Case 39: A = B2S(BlockCounter) + 59;	break;
			Case 40: A = B2S(BlockCounter) +  2;	break;														Case 41: A = B2S(BlockCounter) + 10;	break;														Case 42: A = B2S(BlockCounter) + 18;	break;														Case 43: A = B2S(BlockCounter) + 26;	break;
			Case 44: A = B2S(BlockCounter) + 34;	break;														Case 45: A = B2S(BlockCounter) + 42;	break;														Case 46: A = B2S(BlockCounter) + 50;	break;														Case 47: A = B2S(BlockCounter) + 58;	break;
			Case 48: A = B2S(BlockCounter) +  1;	break;														Case 49: A = B2S(BlockCounter) +  9;	break;														Case 50: A = B2S(BlockCounter) + 17;	break;														Case 51: A = B2S(BlockCounter) + 25;	break;
			Case 52: A = B2S(BlockCounter) + 33;	break;														Case 53: A = B2S(BlockCounter) + 41;	break;														Case 54: A = B2S(BlockCounter) + 49;	break;														Case 55: A = B2S(BlockCounter) + 57;	break;
			Case 56: A = B2S(BlockCounter) +  0;	break;														Case 57: A = B2S(BlockCounter) +  8;	break;														Case 58: A = B2S(BlockCounter) + 16;	break;														Case 59: A = B2S(BlockCounter) + 24;	break;
			Case 60: A = B2S(BlockCounter) + 32;	break;														Case 61: A = B2S(BlockCounter) + 40;	break;														Case 62: A = B2S(BlockCounter) + 48;	break;														Case 63: A = B2S(BlockCounter) + 56;	break;
//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) + 73;	break;														Case 65: A = B2S(BlockCounter) + 74;	break;														Case 66: A = B2S(BlockCounter) + 75;	break;
			Case 67: A = B2S(BlockCounter) + 76;	break;														Case 68: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) + 78;	break;														Case 70: A = B2S(BlockCounter) + 79;	break;														Case 71: A = B2S(BlockCounter) + 80;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) - 29;	break;														Case 74: A = B2S(BlockCounter) - 30;	break;														Case 75: A = B2S(BlockCounter) - 31;	break;
			Case 76: A = B2S(BlockCounter) - 32;	break;														Case 77: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) - 34;	break;														Case 79: A = B2S(BlockCounter) - 35;	break;														Case 80: A = B2S(BlockCounter) - 36;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 83: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 84: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 85: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 86: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 88: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 89: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 64;	break;														Case 92: A = B2S(BlockCounter) + 65;	break;														Case 93: A = B2S(BlockCounter) + 66;	break;
			Case 94: A = B2S(BlockCounter) + 67;	break;														Case 95: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) + 69;	break;														Case 97: A = B2S(BlockCounter) + 70;	break;														Case 98: A = B2S(BlockCounter) + 71;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) 	||	// D
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	//||	// L
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;


	Case ToLEFT:
	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) + 63;	break;														Case  1: A = B2S(BlockCounter) + 62;	break;														Case  2: A = B2S(BlockCounter) + 61;	break;														Case  3: A = B2S(BlockCounter) + 60;	break;
			Case  4: A = B2S(BlockCounter) + 59;	break;														Case  5: A = B2S(BlockCounter) + 58;	break;														Case  6: A = B2S(BlockCounter) + 57;	break;														Case  7: A = B2S(BlockCounter) + 56;	break;
			Case  8: A = B2S(BlockCounter) + 55;	break;														Case  9: A = B2S(BlockCounter) + 54;	break;														Case 10: A = B2S(BlockCounter) + 53;	break;														Case 11: A = B2S(BlockCounter) + 52;	break;
			Case 12: A = B2S(BlockCounter) + 51;	break;														Case 13: A = B2S(BlockCounter) + 50;	break;														Case 14: A = B2S(BlockCounter) + 49;	break;														Case 15: A = B2S(BlockCounter) + 48;	break;
			Case 16: A = B2S(BlockCounter) + 47;	break;														Case 17: A = B2S(BlockCounter) + 46;	break;														Case 18: A = B2S(BlockCounter) + 45;	break;														Case 19: A = B2S(BlockCounter) + 44;	break;
			Case 20: A = B2S(BlockCounter) + 43;	break;														Case 21: A = B2S(BlockCounter) + 42;	break;														Case 22: A = B2S(BlockCounter) + 41;	break;														Case 23: A = B2S(BlockCounter) + 40;	break;
			Case 24: A = B2S(BlockCounter) + 39;	break;														Case 25: A = B2S(BlockCounter) + 38;	break;														Case 26: A = B2S(BlockCounter) + 37;	break;														Case 27: A = B2S(BlockCounter) + 36;	break;
			Case 28: A = B2S(BlockCounter) + 35;	break;														Case 29: A = B2S(BlockCounter) + 34;	break;														Case 30: A = B2S(BlockCounter) + 33;	break;														Case 31: A = B2S(BlockCounter) + 32;	break;
			Case 32: A = B2S(BlockCounter) + 31;	break;														Case 33: A = B2S(BlockCounter) + 30;	break;														Case 34: A = B2S(BlockCounter) + 29;	break;														Case 35: A = B2S(BlockCounter) + 28;	break;
			Case 36: A = B2S(BlockCounter) + 27;	break;														Case 37: A = B2S(BlockCounter) + 26;	break;														Case 38: A = B2S(BlockCounter) + 25;	break;														Case 39: A = B2S(BlockCounter) + 24;	break;
			Case 40: A = B2S(BlockCounter) + 23;	break;														Case 41: A = B2S(BlockCounter) + 22;	break;														Case 42: A = B2S(BlockCounter) + 21;	break;														Case 43: A = B2S(BlockCounter) + 20;	break;
			Case 44: A = B2S(BlockCounter) + 19;	break;														Case 45: A = B2S(BlockCounter) + 18;	break;														Case 46: A = B2S(BlockCounter) + 17;	break;														Case 47: A = B2S(BlockCounter) + 16;	break;
			Case 48: A = B2S(BlockCounter) + 15;	break;														Case 49: A = B2S(BlockCounter) + 14;	break;														Case 50: A = B2S(BlockCounter) + 13;	break;														Case 51: A = B2S(BlockCounter) + 12;	break;
			Case 52: A = B2S(BlockCounter) + 11;	break;														Case 53: A = B2S(BlockCounter) + 10;	break;														Case 54: A = B2S(BlockCounter) +  9;	break;														Case 55: A = B2S(BlockCounter) +  8;	break;
			Case 56: A = B2S(BlockCounter) +  7;	break;														Case 57: A = B2S(BlockCounter) +  6;	break;														Case 58: A = B2S(BlockCounter) +  5;	break;														Case 59: A = B2S(BlockCounter) +  4;	break;
			Case 60: A = B2S(BlockCounter) +  3;	break;														Case 61: A = B2S(BlockCounter) +  2;	break;														Case 62: A = B2S(BlockCounter) +  1;	break;														Case 63: A = B2S(BlockCounter) +  0;	break;
//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) - 29;	break;														Case 65: A = B2S(BlockCounter) - 30;	break;														Case 66: A = B2S(BlockCounter) - 31;	break;
			Case 67: A = B2S(BlockCounter) - 32;	break;														Case 68: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) - 34;	break;														Case 70: A = B2S(BlockCounter) - 35;	break;														Case 71: A = B2S(BlockCounter) - 36;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 74: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 75: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 76: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 77: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 79: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 80: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) + 64;	break;														Case 83: A = B2S(BlockCounter) + 65;	break;														Case 84: A = B2S(BlockCounter) + 66;	break;
			Case 85: A = B2S(BlockCounter) + 67;	break;														Case 86: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) + 69;	break;														Case 88: A = B2S(BlockCounter) + 70;	break;														Case 89: A = B2S(BlockCounter) + 71;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) + 73;	break;														Case 92: A = B2S(BlockCounter) + 74;	break;														Case 93: A = B2S(BlockCounter) + 75;	break;
			Case 94: A = B2S(BlockCounter) + 76;	break;														Case 95: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) + 78;	break;														Case 97: A = B2S(BlockCounter) + 79;	break;														Case 98: A = B2S(BlockCounter) + 80;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) //	||	// D
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	||	// L
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;



	Case ToUP:
	Switch(Tag)
			{
			Case  0: A = B2S(BlockCounter) + 56;	break;														Case  1: A = B2S(BlockCounter) + 48;	break;														Case  2: A = B2S(BlockCounter) + 40;	break;														Case  3: A = B2S(BlockCounter) + 32;	break;
			Case  4: A = B2S(BlockCounter) + 24;	break;														Case  5: A = B2S(BlockCounter) + 16;	break;														Case  6: A = B2S(BlockCounter) +  8;	break;														Case  7: A = B2S(BlockCounter) +  0;	break;
			Case  8: A = B2S(BlockCounter) + 57;	break;														Case  9: A = B2S(BlockCounter) + 49;	break;														Case 10: A = B2S(BlockCounter) + 41;	break;														Case 11: A = B2S(BlockCounter) + 33;	break;
			Case 12: A = B2S(BlockCounter) + 25;	break;														Case 13: A = B2S(BlockCounter) + 17;	break;														Case 14: A = B2S(BlockCounter) +  9;	break;														Case 15: A = B2S(BlockCounter) +  1;	break;
			Case 16: A = B2S(BlockCounter) + 58;	break;														Case 17: A = B2S(BlockCounter) + 50;	break;														Case 18: A = B2S(BlockCounter) + 42;	break;														Case 19: A = B2S(BlockCounter) + 34;	break;
			Case 20: A = B2S(BlockCounter) + 26;	break;														Case 21: A = B2S(BlockCounter) + 18;	break;														Case 22: A = B2S(BlockCounter) + 10;	break;														Case 23: A = B2S(BlockCounter) +  2;	break;
			Case 24: A = B2S(BlockCounter) + 59;	break;														Case 25: A = B2S(BlockCounter) + 51;	break;														Case 26: A = B2S(BlockCounter) + 43;	break;														Case 27: A = B2S(BlockCounter) + 35;	break;
			Case 28: A = B2S(BlockCounter) + 27;	break;														Case 29: A = B2S(BlockCounter) + 19;	break;														Case 30: A = B2S(BlockCounter) + 11;	break;														Case 31: A = B2S(BlockCounter) +  3;	break;
			Case 32: A = B2S(BlockCounter) + 60;	break;														Case 33: A = B2S(BlockCounter) + 52;	break;														Case 34: A = B2S(BlockCounter) + 44;	break;														Case 35: A = B2S(BlockCounter) + 36;	break;
			Case 36: A = B2S(BlockCounter) + 28;	break;														Case 37: A = B2S(BlockCounter) + 20;	break;														Case 38: A = B2S(BlockCounter) + 12;	break;														Case 39: A = B2S(BlockCounter) +  4;	break;
			Case 40: A = B2S(BlockCounter) + 61;	break;														Case 41: A = B2S(BlockCounter) + 53;	break;														Case 42: A = B2S(BlockCounter) + 45;	break;														Case 43: A = B2S(BlockCounter) + 37;	break;
			Case 44: A = B2S(BlockCounter) + 29;	break;														Case 45: A = B2S(BlockCounter) + 21;	break;														Case 46: A = B2S(BlockCounter) + 13;	break;														Case 47: A = B2S(BlockCounter) +  5;	break;
			Case 48: A = B2S(BlockCounter) + 62;	break;														Case 49: A = B2S(BlockCounter) + 54;	break;														Case 50: A = B2S(BlockCounter) + 46;	break;														Case 51: A = B2S(BlockCounter) + 38;	break;
			Case 52: A = B2S(BlockCounter) + 30;	break;														Case 53: A = B2S(BlockCounter) + 22;	break;														Case 54: A = B2S(BlockCounter) + 14;	break;														Case 55: A = B2S(BlockCounter) +  6;	break;
			Case 56: A = B2S(BlockCounter) + 63;	break;														Case 57: A = B2S(BlockCounter) + 55;	break;														Case 58: A = B2S(BlockCounter) + 47;	break;														Case 59: A = B2S(BlockCounter) + 39;	break;
			Case 60: A = B2S(BlockCounter) + 31;	break;														Case 61: A = B2S(BlockCounter) + 23;	break;														Case 62: A = B2S(BlockCounter) + 15;	break;														Case 63: A = B2S(BlockCounter) +  7;	break;

//----R-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 64: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 80;	break;							Case 65: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 79;	break;							Case 66: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 78;	break;
			Case 67: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 77;	break;							Case 68: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 76;	break;							//   < - - -  E N T R A N C E   T A G S   -----------
			Case 69: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 75;	break;							Case 70: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 74;	break;							Case 71: A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 73;	break;
//----D-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 73: A = B2S(BlockCounter) + 64;	break;														Case 74: A = B2S(BlockCounter) + 65;	break;														Case 75: A = B2S(BlockCounter) + 66;	break;
			Case 76: A = B2S(BlockCounter) + 67;	break;														Case 77: A = B2S(BlockCounter) + 68;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 78: A = B2S(BlockCounter) + 69;	break;														Case 79: A = B2S(BlockCounter) + 70;	break;														Case 80: A = B2S(BlockCounter) + 71;	break;
//----L-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 82: A = B2S(BlockCounter) + 73;	break;														Case 83: A = B2S(BlockCounter) + 74;	break;														Case 84: A = B2S(BlockCounter) + 75;	break;
			Case 85: A = B2S(BlockCounter) + 76;	break;														Case 86: A = B2S(BlockCounter) + 77;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 87: A = B2S(BlockCounter) + 78;	break;														Case 88: A = B2S(BlockCounter) + 79;	break;														Case 89: A = B2S(BlockCounter) + 80;	break;
//----U-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 91: A = B2S(BlockCounter) - 29;	break;														Case 92: A = B2S(BlockCounter) - 30;	break;														Case 93: A = B2S(BlockCounter) - 31;	break;
			Case 94: A = B2S(BlockCounter) - 32;	break;														Case 95: A = B2S(BlockCounter) - 33;	break;														//   < - - -  E N T R A N C E   T A G S   -----------
			Case 96: A = B2S(BlockCounter) - 34;	break;														Case 97: A = B2S(BlockCounter) - 35;	break;														Case 98: A = B2S(BlockCounter) - 36;	break;
//--Cross1----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 72: if ((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) + 72;	break;
			break;
//--Cross2----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 81: if ((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToDOWN, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) + 72;
			break;
//--Cross3----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 90: if ((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToLEFT, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - 28;
			break;
//--Cross4----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			Case 99: if ((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	|| 	(BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE))			A = ImpossibleNum;		else	A = B2S(BlockCounter) - B2S(sqrt(PlaygroundBlocks)) - 28;	break;
			break;
			}
//----------------  TAG IS IN BLIND AREA
					if 	((Tag != 72) && (Tag !=	81) && (Tag != 90) && (Tag != 99))
						if 	(
						((BlockCounterAtTheEdge(ToUP, 		BlockCounter) == TRUE)	&&	(Tag >= 64) && (Tag < 72))	||	// R
						//((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == TRUE)	&&	(Tag >= 73) && (Tag < 81)) 	||	// D
						//((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)	&&	(Tag >= 82) && (Tag < 90))	||	// L
						((BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE)	&&	(Tag >= 91) && (Tag < 99))		// U
							)

					A = ImpossibleNum;

			break;
	}



Result = A;
return Result;
}




function int AssignLine (int WhichSide,  int SectorTag)		//BlockCounter is only needed to check if its the edge of the map
{

int i, Result, SectorTagRoot, LineTagRoot, counter, SideTag, hor;

			if ((SectorTag >= 64) && (SectorTag < 72))		{	i = 1;	hor = 0;	}
	else	if ((SectorTag >= 73) && (SectorTag < 81))		{	i = 2;	hor = 1;	}
	else 	if ((SectorTag >= 82) && (SectorTag < 90))		{	i = 3;	hor = 0;	}
	else 	if ((SectorTag >= 91) && (SectorTag < 99))		{	i = 4;	hor = 1;	}

				SectorTagRoot	= 55 + i*9;
				LineTagRoot		=  1 + i*20;
				SideTag = ImpossibleNum;

				if (SectorTag == SectorTagRoot + 0)		SideTag = ImpossibleNum;	//SideTag = 1 + hor;
				if (SectorTag == SectorTagRoot + 1)		SideTag = ImpossibleNum;	//SideTag = 1 + hor;
				if (SectorTag == SectorTagRoot + 2)		SideTag = i*20 + 0;
				if (SectorTag == SectorTagRoot + 3)		SideTag = i*20 + 9;
				if (SectorTag == SectorTagRoot + 4)		SideTag = i*20 + 10;
				if (SectorTag == SectorTagRoot + 5)		SideTag = i*20 + 10;	//if (SectorTag == SectorTagRoot + 5)		SideTag = 1 + hor;
				if (SectorTag == SectorTagRoot + 6)		SideTag = ImpossibleNum;	//SideTag = 1 + hor;
				if (SectorTag == SectorTagRoot + 7)		SideTag = ImpossibleNum;	//SideTag = 1 + hor;  commented these lines because there is a bug i can't locate a source of


counter = SectorTag - SectorTagRoot;

Switch (WhichSide)
		{
						CASE SIDE_FRONT: 	Result = LineTagRoot + counter;			break;
						CASE SIDE_BACK: 	Result = LineTagRoot + counter + 10;	break;
						CASE SIDE_SIDEY: 	Result = SideTag;						break;
		}

//log(s: "Sector Tag ", i:SectorTag, s:"     Side Tag ", i:SideTag);
return Result;

}











function int ActorAngle		(int InitialAngle, int Direction, int Type)
{
int Result;

Switch(TYPE)
	{
	CASE BYTE:
				Switch(Direction)
					{
					CASE ToRIGHT:		Result = InitialAngle;			break;
					CASE ToDOWN:		Result = InitialAngle + 192;	break;
					CASE ToLEFT:		Result = InitialAngle + 128;	break;
					CASE ToUP:			Result = InitialAngle + 64;		break;
					}
	break;

	CASE FIXED:
				Switch(Direction)
					{
					CASE ToRIGHT:		Result = InitialAngle;			break;
					CASE ToDOWN:		Result = InitialAngle + 0.75;	break;
					CASE ToLEFT:		Result = InitialAngle + 0.5;	break;
					CASE ToUP:			Result = InitialAngle + 0.25;	break;
					}
	break;
	}


return Result;
}










 //Stupid fucking zdaemon can't fucking remember the motherfucking StrParam for more than one tic (this fucking shit is so fucking annoying, they used to masterban on this port for nothing rofl)
 //so im doing it this clunky way

function str ContainerStr (int ContainerType, int Direction)
{
str Result;
Switch(ContainerType)
	{
	CASE OneBlock:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">1";	break;
		CASE ToDown: 	Result = "V1";	break;
		CASE ToLEFT: 	Result = "<1";	break;
		CASE ToUP: 		Result = "^1";	break;
		}
	break;
	CASE TwoBlocks:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">2";	break;
		CASE ToDown: 	Result = "V2";	break;
		CASE ToLEFT: 	Result = "<2";	break;
		CASE ToUP: 		Result = "^2";	break;
		}
	break;
	CASE ThreeBlocks:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">3";	break;
		CASE ToDown: 	Result = "V3";	break;
		CASE ToLEFT: 	Result = "<3";	break;
		CASE ToUP: 		Result = "^3";	break;
		}
	break;
	CASE FourBlocks:
	Switch(Direction)
		{
		CASE ToRIGHT: 	Result = ">4";	break;
		CASE ToDown: 	Result = "V4";	break;
		CASE ToLEFT: 	Result = "<4";	break;
		CASE ToUP: 		Result = "^4";	break;
		}
	break;
	}
return Result;
}




function int GetRoundsCount (void)
{
int Result;
Switch(ServerInfo[STAGE])
	{
	CASE 0:		Result = GAMEINFO[RoundsCount];		break;

	CASE 1:		Result = 2;		break;
	CASE 2:		Result = 2;		break;
	CASE 3:		Result = 2;		break;
	CASE 4:		Result = 3;		break;
	CASE 5:		Result = 2;		break;
	CASE 6:		Result = 3;		break;
	CASE 7:		Result = 3;		break;
	CASE 8:		Result = 3;		break;
	CASE 9:		Result = 3;		break;
	CASE 10:	Result = 3;		break;
	CASE 11:	Result = 3;		break;
	CASE 12:	Result = 3;		break;
	CASE 13:	Result = 3;		break;
	CASE 14:	Result = 3;		break;
	CASE 15:	Result = 3;		break;
	CASE 16:	Result = 3;		break;
	CASE 17:	Result = 4;		break;
	CASE 18:	Result = 3;		break;
	CASE 19:	Result = 4;		break;
	CASE 20:	Result = 4;		break;
	CASE 21:	Result = 4;		break;
	CASE 22:	Result = 4;		break;
	CASE 23:	Result = 5;		break;
	CASE 24:	Result = 4;		break;
	CASE 25:	Result = 5;		break;
	}
return Result;
}





function int StrNumToInt (str Char)
{
int Result;
Switch(Char)
	{
	CASE "0": Result = 0; break;
	CASE "1": Result = 1; break;
	CASE "2": Result = 2; break;
	CASE "3": Result = 3; break;
	CASE "4": Result = 4; break;
	CASE "5": Result = 5; break;
	CASE "6": Result = 6; break;
	CASE "7": Result = 7; break;
	CASE "8": Result = 8; break;
	CASE "9": Result = 9; break;
	}



return Result;
}








function str VolumetricTextureSize (int Type, int Num)
{
str Result = "";	str Size = "";	str Vector = "";
Switch(Num)
	{
	CASE LINETAG_VolumetricA: 		Size = "SMA";		Vector = "U";	break;
	CASE LINETAG_VolumetricB: 		Size = "MED";		Vector = "U";	break;
	CASE LINETAG_VolumetricC: 		Size = "BIG";		Vector = "U";	break;
	CASE LINETAG_VolumetricD_up: 	Size = "MED";		Vector = "U";	break;
	CASE LINETAG_VolumetricD_dn: 	Size = "BIG";		Vector = "D";	break;
	}

Switch(Type)
	{
	CASE 1: Result = Size; break;
	CASE 2: Result = Vector; break;
	}

return Result;
}






function void PortalVisuals (int Turn)
{
Switch (Turn)
	{
	CASE ON:
	if(GetPort() >= Zandronum)		{ReplaceTextures("SPAW1Z0", "SPAW1N1");	ReplaceTextures("SPAW2Z0", "SPAW2N1");	ReplaceTextures("SPAW3Z0", "SPAW3N1");	ReplaceTextures("SPAW4Z0", "SPAW4N1");}
									TranslucentLine(LINETAG_VolumetricPortal, 192, TRUE);
	break;

	CASE OFF:
	if(GetPort() >= Zandronum)		{ReplaceTextures("SPAW1N1", "SPAW1Z0");	ReplaceTextures("SPAW2N1", "SPAW2Z0");	ReplaceTextures("SPAW3N1", "SPAW3Z0");	ReplaceTextures("SPAW4N1", "SPAW4Z0");}
									TranslucentLine(LINETAG_VolumetricPortal, 0, TRUE);
	break;
	}
}



function void MapPreset (int Num)
{
int i;



Switch(Num)
	{
	CASE 1:
			int counter; int counterB = RNG(0,6); int counterC = RandomNoZero(-2, 2); int counterD = RNG(128, 160);	Light_ChangeToValue(TIDRAM_SkyboxVolume, counterD);

			for (i = SECTORTAG_HubMIN; i <= SECTORTAG_HubMAX;  i++)	Sector_SetColor	(i, 					255, 255, 255, 255);
			for (i = 1; i <= 64;  i++)								Sector_SetColor	(SECTORTAG_Skybox + i,	255, 255, 255, 255);
			for (i = 1; i <= 64;  i++)								ChangeFloor		(SECTORTAG_Skybox + i,								StrParam(s:"SK", s:"00", s:"FL", i:i));
			for (i = 1; i <= 64;  i++)								ChangeCeiling	(SECTORTAG_Skybox + i, 								StrParam(s:"SK", s:"00", s:"CE", i:i));
			for (i = 1; i <=  4;  i++)								SetLineTexture	(SECTORTAG_Skybox + i, SIDE_FRONT, TEXTURE_MIDDLE,	StrParam(s:"SK", s:"00", s:"WA", i:i));


			PortalVisuals(OFF);
			if (GetPort() == Zandronum)
				{
					Light_ChangeToValue(TIDRAM_SystemDay, StrToNum(StrParam(s: Strftime (SystemTime(), "%d", true))));
					if (StrLen(StrParam(s:GetCvarString("databasefile"))))	Light_ChangeToValue(TIDRAM_Database, TRUE);
				}


			counter = LINETAG_VolumetricA;
			while(counter <= LINETAG_VolumetricC)
				{
				SetLineTexture(counter, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"LIT", s:VolumetricTextureSize(1, counter), s:VolumetricTextureSize(2, counter), i:RNG(0, 6)));
				TranslucentLine(counter, RNG(32, 128), 1);
				Scroll_Wall(counter, int2fix(RNG(-4, 4)), 0, SIDE_FRONT, 2);
				//Scroll_Wall(counter, FixedDiv( int2fix(RNG(-4, 4)), 	int2fix(GetChar(StrNumToInt(VolumetricTextureSize(3, counter)), 0))), 0, SIDE_FRONT, 2);
				counter++;
				}




			counter = LINETAG_VolumetricD_up;
			while(counter <= LINETAG_VolumetricD_dn)
				{
				SetLineTexture(counter, SIDE_FRONT, TEXTURE_MIDDLE, StrParam(s:"LIT", s:VolumetricTextureSize(1, counter), s:VolumetricTextureSize(2, counter), i:counterB));
				TranslucentLine(counter, counterD, 1);
				Scroll_Wall(counter, int2fix(counterC), 0, SIDE_FRONT, 2);
				//Scroll_Wall(counter, FixedDiv( int2fix(RNG(-4, 4)), 	int2fix(GetChar(StrNumToInt(VolumetricTextureSize(3, counter)), 0))), 0, SIDE_FRONT, 2);
				counter++;
				}

			GAMEINFO[MinigameWinPlayaPTS] 	= -1;
			GAMEINFO[MinigameWinPlayaNUM] 	= -1;






		BREAK;


		CASE 2:
				for (i = SECTORTAG_HubMIN; i <= SECTORTAG_HubMAX;  i++)	Sector_SetColor	(i, 					255, 255, 255, 0);
				for (i = 1; i <= 64;  i++)								Sector_SetColor	(SECTORTAG_Skybox + i,	255, 255, 255, 0);

				if(!RNG(0,2))	SpawnSpotForced(Money, RNG(ACTORTID_HubCoin, ACTORTID_HubCoin + 3) , 0, 0);

				if(!RNG(0,4))	SpawnSpotForced("BlasterHefty", RNG(ACTORTID_HubBigCoin, ACTORTID_HubBigCoin + 2) , 0, 0);

				GAMEINFO[RoundsCount] = RNG(2,4);

				if (RNG(false, true))		SpawnSpotForced("Chainsaw", 12025, 0, 0);
				if (GetPort() > ZDaemon)	SpawnSpotForced("ShopSequence", ACTORTID_ShopCamera, 0, 0);

				CreateTranslation (tc_GREY, 	112:127		=	96:111);
				CreateTranslation (tc_WHITE, 	112:127		=	80:95);
				CreateTranslation (tc_BROWN, 	112:127		=	64:79);
				CreateTranslation (tc_PEACH, 	112:127		=	48:63);
				CreateTranslation (tc_RED, 		112:127		=	32:47);
				CreateTranslation (tc_PINK, 	112:127		=	16:31);
				CreateTranslation (tc_YELLOW, 	112:127		=	227:231);
				CreateTranslation (tc_BLUE, 	112:127		=	198:207);
				CreateTranslation (tc_GREEN, 	112:127		=	112:127);


				//Changelog in ZDaemon
				if (GetPort() == ZDaemon)
					{
					SetLineTexture(LINETAG_ChangelogTX,		SIDE_FRONT, 	TEXTURE_BOTTOM, 	"CLOGBUTT");
					SetLineSpecial(LINETAG_ChangelogTX,		ACS_Execute,	SCRIPT_Changelog);
					SetLineTexture(LINETAG_ChangelogSTR,	SIDE_FRONT, 	TEXTURE_MIDDLE, 	"ALPHABET");

					for (i = SECTORTAG_HubMIN; i <= SECTORTAG_HubMAX;  i++)	Sector_SetColor	(i, 					255, 255, 255, 0);

					for (i = 0; i < MaxPortNameCharsZDA;  i++)		Light_ChangeToValue(TIDRAM_MemoOwner + i, MemoOwner[i]);
																	Light_ChangeToValue(TIDRAM_MemoOwnerType, MemoOwner[MemoOwnerType]);
					if (MemoOwnerMSG[0])
							{
							SetMemoOwnerTexture();
							SetLineTexture(LINETAG_MemoOwnerVolume, SIDE_FRONT,	TEXTURE_MIDDLE, "LITSMAZ0");
							SetLineTexture(LINETAG_MemoOwnerVolume, SIDE_BACK,		TEXTURE_MIDDLE, "LITSMAZ0");
							TranslucentLine(LINETAG_MemoOwnerVolume, 128, TRUE);
							}

					}

			if (!SERVERINFO[AdvertQueue])					SERVERINFO[AdvertQueue] = RNG(0, MaxAdds - 1);
			if (SERVERINFO[AdvertQueue] < MaxAdds)			SERVERINFO[AdvertQueue]++;
			else											SERVERINFO[AdvertQueue] = 1;
			Light_ChangeToValue(TIDRAM_AdvertisementSlot, 	SERVERINFO[AdvertQueue]);

			SetLineSpecial(LINETAG_Outside, ACS_ExecuteAlways, SCRIPT_FadeProjectile);
			for (i = 0; i < MaxPlayers;  i++) 	PlayerToasty[i] = RNG(0, 20);

		BREAK;
	}




}





// CLIENTSIDED TEXTURE OFFSET, because ZDAemon goes boom


function void	SetClientSubstanceOffset	(void)
{
str StringA = StrParam(i:RoundInfo[SubstanceLineOffset]);
if (GetChar(StringA, 0) == '-')		Light_ChangeToValue(TIDRAM_SubstanceLineOffset + 0,  TRUE);		//negative
else								Light_ChangeToValue(TIDRAM_SubstanceLineOffset + 0,  FALSE);	//positive


StringA = LeadingZeros(abs(RoundInfo[SubstanceLineOffset]), 4);	//0000

Light_ChangeToValue(TIDRAM_SubstanceLineOffset + 1,  GetChar(StringA, 0)	-48);
Light_ChangeToValue(TIDRAM_SubstanceLineOffset + 2,  GetChar(StringA, 1)	-48);
Light_ChangeToValue(TIDRAM_SubstanceLineOffset + 3,  GetChar(StringA, 2)	-48);
Light_ChangeToValue(TIDRAM_SubstanceLineOffset + 4,  GetChar(StringA, 3)	-48);

}



function void DrawClientSubstanceOffset (void)
{
int Value = (
			(GetSectorLightLevel(TIDRAM_SubstanceLineOffset + 1)*1000)	+
			(GetSectorLightLevel(TIDRAM_SubstanceLineOffset + 2)*100)	+
			(GetSectorLightLevel(TIDRAM_SubstanceLineOffset + 3)*10)	+
			(GetSectorLightLevel(TIDRAM_SubstanceLineOffset + 4))
			)	* -GetSectorLightLevel(TIDRAM_SubstanceLineOffset + 0);

for (int a = 1; a <= PlaygroundBlocks;  a++)
	{
	Line_SetTextureOffset(a, NO_CHANGE, int2fix(Value), SIDE_FRONT, TEXFLAG_MIDDLE);
	Line_SetTextureOffset(a, NO_CHANGE, int2fix(Value), SIDE_BACK,	TEXFLAG_MIDDLE);
	}

	Line_SetTextureOffset(LINETAG_Outside, NO_CHANGE, int2fix(Value), SIDE_FRONT,	TEXFLAG_MIDDLE);
	Line_SetTextureOffset(LINETAG_Outside, NO_CHANGE, int2fix(Value), SIDE_BACK,	TEXFLAG_MIDDLE);

}


















function void DrawNotification (int Who, str srcString, int Position, int Paragraph, int IconInt, str IconStr, int Color, str MainFont, int LogIt, int Capped, int FadeIn, int Hold, int FadeOut)
{
int counter, Yoffset, HUDidmsg, HUDidicon;
str tempStr = "";
Str IconName = "";
Str LogColor = "";
SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
Switch(Position)
	{
	CASE notepose_EDGETOP:	Yoffset = int2fix(Y_EDGETOP);			HUDidmsg = HUDid_NoteEDGETOPmsg;	HUDidicon = HUDid_NoteEDGETOPicon;		break;
	CASE notepose_SPECIAL:	Yoffset = int2fix(Y_MONEY);				HUDidmsg = HUDid_NoteSPECIALmsg;	HUDidicon = HUDid_NoteSPECIALicon;		break;
	CASE notepose_TOP:		Yoffset = int2fix(Y_TOP_ICON);			HUDidmsg = HUDid_NoteTOPmsg;		HUDidicon = HUDid_NoteTOPicon;			break;
	CASE notepose_MID:		Yoffset = int2fix(Y_MIDDLE_ICON);		HUDidmsg = HUDid_NoteMIDmsg;		HUDidicon = HUDid_NoteMIDicon;			break;
	CASE notepose_BOT:		Yoffset = int2fix(Y_BOTTOM_ICON);		HUDidmsg = HUDid_NoteBOTmsg;		HUDidicon = HUDid_NoteBOTicon;			break;
	CASE notepose_VBOT:		Yoffset = int2fix(Y_VBOTTOM_ICON);		HUDidmsg = HUDid_NoteVBOTmsg;		HUDidicon = HUDid_NoteVBOTicon;			break;
	}





if (Paragraph == notepara_ALIGN)
	{
				if (strLen(srcString) > MaxInfoChars)
						{
						counter = 0;	tempStr = "";
						while (counter < MaxInfoChars - 2)
							{
							tempStr = StrParam(s:tempStr, c:GetChar(srcString, counter));
							counter++;
							}
						tempStr = StrParam(s:tempStr, s:"..");

						}

		else	if (strLen(srcString) < MaxInfoChars)
						{
						tempStr = srcString;
						counter = StrLen(tempStr);
						while (counter < MaxInfoChars)
							{
							tempStr = StrParam(s:tempStr, s:" ");
							counter++;
							}
						}

	}

else 	tempStr = srcString;

if (Capped == ON) tempStr = StrToUpper(tempStr);
//---------------------------------------------
if (LogIt == ON)
	{
	Switch(IconInt)
			{
			CASE ICON_None: 			IconName = ""; 																																						break;
			CASE ICON_Exclamation:		if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, s:"WARNING"); 																	break;
			CASE ICON_Location:			if (GetPort() >= Zandronum)		LogColor = "\cf";	IconName = StrParam(s:LogColor, s:"LOCATION"); 																	break;
			CASE ICON_Checkmark:		if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount], s:" CLEARED");		break;
			CASE ICON_Clock:			if (GetPort() >= Zandronum)		LogColor = "\cx";	IconName = StrParam(s:LogColor, s:"TIME"); 																		break;
			CASE ICON_Exit:				if (GetPort() >= Zandronum)		LogColor = "\cx";	IconName = StrParam(s:LogColor, s:"EXIT"); 																		break;
			CASE ICON_Mission:			if (GetPort() >= Zandronum)		LogColor = "\ci";	IconName = StrParam(s:LogColor, s:"GOAL"); 																		break;
			CASE ICON_Weapon:			if (GetPort() >= Zandronum)		LogColor = "\cr";	IconName = StrParam(s:LogColor, s:"NEW WEAPON"); 																break;
			CASE ICON_Sad:				if (GetPort() >= Zandronum)		LogColor = "\ch";	IconName = StrParam(s:LogColor, s:"OOPS"); 																		break;
			CASE ICON_Sad:				if (GetPort() >= Zandronum)		LogColor = "\cq";	IconName = StrParam(s:LogColor, s:"PURCHASE"); 																	break;
			CASE ICON_HEADER_Clock:		if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, s:"COUNTDOWN"); 																break;
			CASE ICON_Round:			if (GetPort() >= Zandronum)		LogColor = "\cc";	IconName = StrParam(s:LogColor, s:"ROUND"); 																	break;
			CASE ICON_Boss:				if (GetPort() >= Zandronum)		LogColor = "\cg";	IconName = StrParam(s:LogColor, s:"BOSS"); 																		break;
			CASE ICON_Quiz:				if (GetPort() >= Zandronum)		LogColor = "\cv";	IconName = StrParam(s:LogColor, s:"QUIZ"); 																		break;
			}
	if (StrLen(IconName) > 0)			if (GetPort() >= Zandronum)		LogColor = "\cj";	IconName = StrParam(s:IconName, s:LogColor, s:":  ");
	if (Capped == ON) 																		IconName = StrToUpper(IconName);
	}



Switch(Who)
	{
	CASE For_ActivatorOnly:
	SetFont("ERICON");		HudMessage		(s:"\c",	s:color, s:IconStr; 	HUDMSG_FADEINOUT, 					HUDidicon,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2 - DN_IconOffset),		Yoffset, 	Hold, FadeIn, FadeOut);
	SetFont(MainFont);		HudMessage		(s:"\c",	s:color, s:tempStr; 	HUDMSG_FADEINOUT,					HUDidmsg,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),						Yoffset, 	Hold, FadeIn, FadeOut);

	if (LogIt == ON)		HudMessage		(		s:IconName,	s:tempStr; 		HUDMSG_FADEINOUT|HUDMSG_LOG|HUDMSG_ALPHA,		0,			CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),					Yoffset, 	0.001, 0.0, 0.0, 0.0);
	break;

	CASE For_Everyone:
	CASE For_ClientOnly:
	SetFont("ERICON");		HudMessageBold	(s:"\c",	s:color, s:IconStr; 	HUDMSG_FADEINOUT, 					HUDidicon,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2 - DN_IconOffset),		Yoffset, 	Hold, FadeIn, FadeOut);
	SetFont(MainFont);		HudMessageBold	(s:"\c",	s:color, s:tempStr; 	HUDMSG_FADEINOUT,					HUDidmsg,	CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),						Yoffset, 	Hold, FadeIn, FadeOut);

	if (LogIt == ON)		HudMessageBold	(		s:IconName,	s:tempStr; 		HUDMSG_FADEINOUT|HUDMSG_LOG|HUDMSG_ALPHA,		0,			CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2),					Yoffset, 	0.001, 0.0, 0.0, 0.0);
	break;
	}






}





Script "MSG_Hurry" (int AdventureType) CLIENTSIDE
{
str Hurr = ""; str to = "";

	Switch(RNG(0,1))
			{
			CASE 0:	Hurr = "HURRY UP! ";	break;			CASE 1:	Hurr = "HURRY, ";	break;
			}

	Switch (AdventureType)
			{
			CASE adventure_RAISE: 	to = "CLIMB TO THE ";		break;
			CASE adventure_LINEAR: 	to = "GET TO THE ";			break;
			CASE adventure_MAZE: 	to = "GET BACK TO THE ";	break;
			CASE adventure_FLOW: 	to = "FLOW BACK TO THE ";	break;
			}

DrawNotification(For_ActivatorOnly, StrParam(s:Hurr, s:To, s:"TELEPORT"), 		notepose_MID, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "c", "ERFONT",  ON, ON, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
}





function int AdventureCeilingHeight (void)
{
int Height;
	Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
			{
			CASE	adventure_BOSS:		Height = RNG(2,4); 	break;
			CASE	adventure_MAZE:		Height = RNG(2,4); 	break;
			CASE	adventure_LINEAR:	Height = 16; 		break;
			CASE	adventure_RAISE:	Height = 32; 		break;
			CASE	adventure_INVASION:	Height = RNG(1,2); 	break;
			CASE	adventure_FLOW	:	Height = RNG(2,3); 	break;
			}

Height = Height*128;

return Height;
}







function void RefreshSpotHeight (int Which, int ID)
{

Switch(Which)
		{
		CASE	refreshspot_ITEM:
		if (GetActorZ(SectorItem [ID][si_SECTOR]) != GetSectorFloorZ(SectorItem [ID][si_SECTOR], None, None))
		SetActorPosition(SectorItem [ID][si_SECTOR], GetActorX(SectorItem [ID][si_SECTOR]), GetActorY(SectorItem [ID][si_SECTOR]), GetSectorFloorZ(SectorItem [ID][si_SECTOR], None, None), false);
		break;

		CASE	refreshspot_PROJECTILE:
		if (GetActorZ(Projectila[ID][ProjParam_EMITSPOT]) != int2fix(Projectila[ID][ProjParam_HEIGHT]))
		SetActorPosition(Projectila[ID][ProjParam_EMITSPOT], GetActorX(Projectila[ID][ProjParam_EMITSPOT]), GetActorY(Projectila[ID][ProjParam_EMITSPOT]), int2fix(Projectila[ID][ProjParam_HEIGHT]), false);
		break;


		CASE	refreshspot_DEFAULT:
		if (GetActorZ(ID) != GetSectorFloorZ(ID, None, None))
		SetActorPosition(ID, GetActorX(ID), GetActorY(ID), GetSectorFloorZ(ID, None, None), false);
		break;
		}


}




/*

 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.      _______.                       _______.___________..______      .______          ___      .___  ___.
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |     /       |       _              /       |           ||   _  \     |   _  \        /   \     |   \/   |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |    |   (----`      (_)            |   (----`---|  |----`|  |_)  |    |  |_)  |      /  ^  \    |  \  /  |
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |     \   \                          \   \       |  |     |      /     |      /      /  /_\  \   |  |\/|  |
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   | .----)   |          _          .----)   |      |  |     |  |\  \----.|  |\  \----./  _____  \  |  |  |  |
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__| |_______/          (_)         |_______/       |__|     | _| `._____|| _| `._____/__/     \__\ |__|  |__|


ZDaemon is incapable to store any kind of Variable that has inhereted it's value from the GetCvarString or StrParam functions. It gets dumped the next tic.
For the cases when I need to store it for more than 1 cycle I store it in a 'RAM'. RAM are sectors light values at the bottom of the map. That's right, because of that issue
I have to store important stuff in map geometry rofl. I think in all cases I just store it in a RAM and immediatelly send it where I need to.



*/







function void SetRAM (int Which)
{
int counter, TIDRAM;		str DataStr = "";


Switch(Which)
	{

	CASE fromCvar_WINNERS:

	DataStr = 	MergedStringInfo ('#', SVDT_Winners,	GetCVarString("STATS"));
	TIDRAM	=	TIDRAM_WinnerNames;

	break;



	CASE fromArray_WinnerNames:

	While(counter < (MaxStages*GAMEINFO[MaxNameChars]))
		{
		//DataStr = StrParam(s:DataStr, c:Crypt(Decrypt, WinnerNames[counter]));
		DataStr = StrParam(s:DataStr, c:WinnerNames[counter]);
		counter++;
		}

	TIDRAM	=	TIDRAM_WinnerNames;

	break;



	CASE fromCvar_LEGENDS:

	DataStr = 	MergedStringInfo ('#', SVDT_Legends,	GetCVarString("STATS"));
	TIDRAM	=	TIDRAM_LegendNames;

	break;


	CASE fromArray_LegendNames:

	While(counter < (MaxLegends*GAMEINFO[MaxNameChars]))
		{
		//DataStr = StrParam(s:DataStr, c:Crypt(Decrypt, LegendNames[counter]));
		DataStr = StrParam(s:DataStr, c:LegendNames[counter]);
		counter++;
		}

	TIDRAM	=	TIDRAM_LegendNames;

	break;





	}







counter = 0;
//Convert
while(counter < StrLen(DataStr))
    {
    Light_ChangeToValue(TIDRAM + counter, GetChar(DataStr, counter));


	Switch(which)
		{
		CASE fromCvar_WINNERS: 				WinnerNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		CASE fromArray_WinnerNames: 		WinnerNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		CASE fromCvar_LEGENDS: 				LegendNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		CASE fromArray_LegendNames: 		LegendNames[counter] = GetSectorLightLevel(TIDRAM + counter);	break;
		}




    counter++;
    }
}








function void NewLegend (int CurrSEASON)
{


int counter, NewLegendNum, NewLegendScore, CmpA, CmpB, IncrementedScore, Iteration;
str CmpNameA, CmpNameB = "";


if (GetPort() == Zandronum)
		BeginDBTransaction();


/*
             _              ___              _
  __ _ _____(_)__ _ _ _    / __|_ __  _ __  /_\
 / _` (_-<_-< / _` | ' \  | (__| '  \| '_ \/ _ \
 \__,_/__/__/_\__, |_||_|  \___|_|_|_| .__/_/ \_\
              |___/                  |_|
*/


while(CmpA < MaxStages)
	{
	CmpA++;


	//Setting up a name of the Comparing
	counter = 0;	CmpNameA = "";	IncrementedScore = CmpA;	CmpB = 0;


	Switch(GetPort())
		{
		CASE ZDaemon:
							while(counter < GAMEINFO[MaxNameChars])
									{
									CmpNameA = 	StrParam(s:CmpNameA, c:WinnerNames[(CmpA - 1)*GAMEINFO[MaxNameChars] + counter]);
									counter++;
									}
		break;

		CASE Zandronum:
									if (GetChar(GetDBEntry(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:CmpA, s:"___StageWinner_ID")), 0) == 126)	CmpNameA = "";
									else
									CmpNameA = 	GetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:					GetDBEntry(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:CmpA, s:"___StageWinner_ID"))					, s:"___ACCOUNT"));
									//CmpNameA = 	GetDBEntryString(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:CmpA, s:"___StageWinner_ID"));
		break;
		}
/*
	while(counter < GAMEINFO[MaxNameChars])
			{
			CmpNameA = StrParam(s:CmpNameA, c:WinnerNames[(CmpA - 1)*GAMEINFO[MaxNameChars] + counter]);
			counter++;
			}

*/




/*
             _              ___            ___
  __ _ _____(_)__ _ _ _    / __|_ __  _ __| _ )
 / _` (_-<_-< / _` | ' \  | (__| '  \| '_ \ _ \
 \__,_/__/__/_\__, |_||_|  \___|_|_|_| .__/___/
              |___/                  |_|
*/



	while (CmpB < MaxStages)
		{
		CmpB++;

			counter = 0;	CmpNameB = "";

		Switch(GetPort())
			{
			CASE ZDaemon:
							while(counter < GAMEINFO[MaxNameChars])		//Setting up a name of the Comparable
									{
									CmpNameB = StrParam(s:CmpNameB, c:WinnerNames[(CmpB - 1)*GAMEINFO[MaxNameChars] + counter]);
									counter++;
									}
			break;

			CASE Zandronum:
									if (GetChar(GetDBEntry(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:CmpB, s:"___StageWinner_ID")), 0) == 126)	CmpNameB = "";
									else
									CmpNameB = 	GetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:					GetDBEntry(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:CmpB, s:"___StageWinner_ID"))					, s:"___ACCOUNT"));

									//CmpNameB = 	GetDBEntryString(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:CmpB, s:"___StageWinner_ID"));
			break;
			}



				if ((StrLen(CmpNameA)) && (StrLen(CmpNameB)))	//if both Names actually have symbols in it
					if ((!StrCmp(CmpNameA, CmpNameB)) && (CmpA != CmpB))			//If there was the same name and it was not the same stage, increment by his other stage win
						Switch(GetPort())
							{
							CASE ZDaemon:											IncrementedScore += CmpB;	break;
							CASE Zandronum:
																					IncrementedScore += CmpB;	break;

									//Do not increment if Stage's win wasn't by a logged player
							}

		}



		//Checking if the Comparing outbested all the comparables
		if (IncrementedScore > NewLegendScore)
				{
				NewLegendScore = IncrementedScore;
				NewLegendNum = CmpA;
				}



	//log(s:CmpNameA, s:" has ", i:IncrementedScore, s:" points");




	}




		//Moving the old legends back a bit

		//ONE
		Iteration = GAMEINFO[MaxNameChars];
		for (int a = Iteration; a < Iteration + GAMEINFO[MaxNameChars];  a++)
		LegendNames[a + GAMEINFO[MaxNameChars]] = LegendNames[a];

		//TWO
		Iteration = 0;
		for (a = Iteration; a < Iteration + GAMEINFO[MaxNameChars];  a++)
		LegendNames[a + GAMEINFO[MaxNameChars]] = LegendNames[a];


//---------------------------------------------------------------------
		counter = 0;	CmpNameA = "";
		While(counter < GAMEINFO[MaxNameChars])
			{
			Switch(GetPort())
				{
				CASE ZDaemon:		LegendNames[counter] = WinnerNames[GAMEINFO[MaxNameChars]*(NewLegendNum - 1) + counter];																				break;
				//CASE Zandronum:		LegendNames[counter] = GetChar(GetDBEntryString(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:NewLegendNum, s:"___StageWinner_DECORATIVE")), counter);			break;
				CASE Zandronum:		LegendNames[counter] =	GetChar(GetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:					GetDBEntry(StrParam(s:"Season", i:CurrSEASON), 		StrParam(i:NewLegendNum, s:"___StageWinner_ID"))					, s:"___MONUMENT")), counter);	break;
				}


			CmpNameA = StrParam(s:CmpNameA, c:LegendNames[counter]);
			counter++;
			}







if (GetPort() == Zandronum)
		{
		counter = 0;	CmpNameB = "";
		while(counter < (MaxLegends*GAMEINFO[MaxNameChars]))
				{
				CmpNameB = StrParam(s:CmpNameB, c:LegendNames[counter]);
				counter++;
				}

				SetDBEntryString("ServerInfo", "Legends", CmpNameB);

		EndDBTransaction();
		}



DrawNotification(For_Everyone, StrParam(s:CmpNameA, s:" IS THE SEASON WINNER!"), 	notepose_MID, 		notepara_CENTER, ICON_None, StrParam(c:ICON_None), 	"i", "ERFONT",  ON, ON, noteFadeIn_None, noteHold_Long, noteFadeOut_Long);
//PrintBold(s:CmpNameA, s:" outbested all the winners!  /", i:NewLegendNum);

}

/*
 _______  __    __  .__   __.   ______ .___________. __    ______   .__   __.      _______.            .______       _______     _______. _______ .___________.
|   ____||  |  |  | |  \ |  |  /      ||           ||  |  /  __  \  |  \ |  |     /       | _          |   _  \     |   ____|   /       ||   ____||           |
|  |__   |  |  |  | |   \|  | |  ,----'`---|  |----`|  | |  |  |  | |   \|  |    |   (----`(_)         |  |_)  |    |  |__     |   (----`|  |__   `---|  |----`
|   __|  |  |  |  | |  . `  | |  |         |  |     |  | |  |  |  | |  . `  |     \   \                |      /     |   __|     \   \    |   __|      |  |
|  |     |  `--'  | |  |\   | |  `----.    |  |     |  | |  `--'  | |  |\   | .----)   |    _          |  |\  \----.|  |____.----)   |   |  |____     |  |
|__|      \______/  |__| \__|  \______|    |__|     |__|  \______/  |__| \__| |_______/    (_)         | _| `._____||_______|_______/    |_______|    |__|

*/








function void ResetFloors (int Root)
{
for (int flr = 0; flr < 16; flr++)
	{
	Floor_MoveToValue(Root + flr, MoveInstantly, 0);
	ChangeFloor(Root + flr, DefaultFloorTexture);
	}
}










function void SetAtmosphere (int CurrRound)
{
int tx; str tex = "";
	Light_ChangeToValue(FlatBASEtx, RNG(1,3));
	Light_ChangeToValue(FlatSECOtx, RNG(1,1));
	Light_ChangeToValue(FlatEDGEtx, RNG(1,1));
	Light_ChangeToValue(FlatFAILtx, RNG(0,1));
	Light_ChangeToValue(FlatPORTtx, RNG(1,1));
	Light_ChangeToValue(FlatWATEtx, RNG(1,1));
	Light_ChangeToValue(FlatBOMBtx, 1);
	Light_ChangeToValue(FlatWORMtx, 1);
	Light_ChangeToValue(CeilBASEtx, RNG(0,3));
	Light_ChangeToValue(CeilSECOtx, RNG(1,1));
	Light_ChangeToValue(WallBASEtx, RNG(1,11));
	Light_ChangeToValue(WallSECOtx, RNG(1,11));
	Light_ChangeToValue(WallEDGEtx, RNG(1,11));
	Light_ChangeToValue(WallFENCtx, RNG(1,4));
	Light_ChangeToValue(WallRAIStx, 1);

//FIXES
Switch(AdventureInfo[CurrRound][adv_TYPE])
		{
		CASE adventure_INVASION:	Light_ChangeToValue(CeilBASEtx, 1);
		break;
		}

for (tx = 1; tx <= PlaygroundBlocks; tx++)
	{
	SetLineTexture(tx, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
	SetLineTexture(tx, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
	SetLineTexture(tx*100, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	SetLineTexture(tx*100, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	}
SetLineTexture(LINETAG_Outside	, SIDE_FRONT, TEXTURE_BOTTOM, 	"");
SetLineTexture(LINETAG_Outside	, SIDE_BACK, TEXTURE_BOTTOM, 	"");
ChangeFloor(SECTORTAG_SubstanceDeath, StrParam(i:GetSectorLightLevel(TIDRAM_Mood), s:"FLFA", i:1));
ChangeCeiling(SECTORTAG_SubstanceDeath, StrParam(i:GetSectorLightLevel(TIDRAM_Mood), s:"FLFA", i:1));


/*
for (tx = PlaygroundBlocks + 1; tx <= PlaygroundBlocks*2; tx++)
	{
	SetLineTexture(tx, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	SetLineTexture(tx, SIDE_BACK, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
	}
*/
	//SetLineTexture(LINETAG_PlaygroundFence, SIDE_FRONT, TEXTURE_MIDDLE, 	TextureIs(WallFENCtx));
	//Line_SetTextureOffset(LINETAG_PlaygroundFence, , , SIDE_FRONT);


	//if (CurrRound > 1)	ResetPlayground();

ChangeCeiling(SECTORTAG_ShaftCoreEdge,	TextureIs(FlatEDGEtx));
ChangeCeiling(SECTORTAG_ShaftSlope, 	TextureIs(FlatBASEtx));
ChangeCeiling(SECTORTAG_ShaftOuterEdge,	TextureIs(FlatEDGEtx));
SetLineTexture(LINETAG_ShaftEdge, SIDE_FRONT, TEXTURE_TOP, 	TextureIs(WallEDGEtx));			SetLineTexture(LINETAG_ShaftEdge, SIDE_BACK, TEXTURE_TOP, 	TextureIs(WallEDGEtx));
SetLineTexture(LINETAG_ShaftBase, SIDE_FRONT, TEXTURE_TOP, 	TextureIs(WallBASEtx));			SetLineTexture(LINETAG_ShaftBase, SIDE_BACK, TEXTURE_TOP, 	TextureIs(WallBASEtx));

	Switch(GetSectorLightLevel(TIDRAM_Mood))
			{
			CASE mood_EARTH:
			CASE mood_COLONY:
			tex = TextureIs(FlatBASEtx);
			for (tx = SECTORTAG_ShaftOuterPaling; tx <= SECTORTAG_ShaftCoreEdge; tx++)
					{
					ChangeFloor(tx, tex);
					//SetSectorVisual(tx);
					}
			//ChangeFloor(SECTORTAG_ShaftCore, tex);	ChangeFloor(SECTORTAG_ShaftCoreEdge, tex);	ChangeFloor(SECTORTAG_ShaftSlope, tex);	ChangeFloor(SECTORTAG_ShaftOuterEdge, tex);	ChangeFloor(SECTORTAG_SkyfallGround, tex);	ChangeFloor(SECTORTAG_ShaftOuterPaling, TextureIs(FlatSECOtx));
			ChangeFloor(SECTORTAG_ShaftCore, tex);
			ChangeFloor(SECTORTAG_ShaftOuterPaling, TextureIs(FlatSECOtx));
			Floor_MoveToValue(SECTORTAG_ShaftOuterPaling, MoveInstantly, (GetSectorFloorZ(SECTORTAG_ShaftCoreEdge, 0, 0) >>16) + 64);
			Ceiling_MoveToValue(SECTORTAG_ShaftCoreEdge, MoveInstantly, GetSectorFloorZ(SECTORTAG_ShaftCoreEdge, 0, 0) >>16);
			SetLineTexture(LINETAG_SkyfallPaling, SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			break;

			CASE mood_SPACE:
			tex = "F_SKY1";
			for (tx = SECTORTAG_ShaftOuterPaling; tx <= SECTORTAG_ShaftCoreEdge; tx++)
					{
					ChangeFloor(tx, tex);
					//SetSectorVisual(tx);
					}
			//ChangeFloor(SECTORTAG_ShaftCore, tex);	ChangeFloor(SECTORTAG_ShaftCoreEdge, tex);	ChangeFloor(SECTORTAG_ShaftSlope, tex);	ChangeFloor(SECTORTAG_ShaftOuterEdge, tex);	ChangeFloor(SECTORTAG_SkyfallGround, tex);	ChangeFloor(SECTORTAG_ShaftOuterPaling, tex);
			ChangeFloor(SECTORTAG_ShaftCore, tex);
			ChangeFloor(SECTORTAG_ShaftOuterPaling, tex);
			//Floor_MoveToValue(SECTORTAG_ShaftOuterPaling, MoveInstantly, GetSectorFloorZ(SECTORTAG_ShaftCoreEdge, 0, 0) >>16);
			Ceiling_MoveToValue(SECTORTAG_ShaftCoreEdge, MoveInstantly, -4096);
			SetLineTexture(LINETAG_SkyfallPaling, SIDE_FRONT, TEXTURE_BOTTOM, 	"-");
			break;
			}
}








function str TextureIs (int Type)			//Mood, Texture Axis, Type, Index		"1FLBS1"
{
str Result = "";		str PrefixType = "";



	Switch(Type)
		{
		CASE FlatBASEtx:	PrefixType = "FLBA";		break;
		CASE FlatSECOtx:	PrefixType = "FLSE";		break;
		CASE FlatEDGEtx:	PrefixType = "FLED";		break;
		CASE FlatFAILtx:	PrefixType = "FLFA";		break;
		CASE FlatPORTtx:	PrefixType = "FLPO";		break;
		CASE FlatWATEtx:	PrefixType = "WATE";		break;
		CASE FlatBOMBtx:	PrefixType = "BOMB";		break;
		CASE FlatWORMtx:	PrefixType = "WORM";		break;
		CASE CeilBASEtx:	PrefixType = "CEBA";		break;
		CASE CeilSECOtx:	PrefixType = "CESE";		break;
		CASE WallBASEtx:	PrefixType = "WALL";		break;
		CASE WallSECOtx:	PrefixType = "WALL";		break;
		CASE WallEDGEtx:	PrefixType = "WALL";		break;
		CASE WallFENCtx:	PrefixType = "WAFE";		break;
		CASE WallRAIStx:	PrefixType = "RAIS";		break;
		}


		if 	(Type == None)													Result = "-";
else	if 	(Type == FlatCOALtx)											Result = "FLTCOAL";
else	if 	(Type == FlatSCRLtx)											Result = "FLTSCRLL";
else	if 	(Type == FlatICEYtx)											Result = "FLTICEY";
else	if 	(Type == FlatICEDtx)											Result = "FLTICEYD";
else	if 	(Type == FlatMUDDtx)											Result = "FLTMUDDY";

else 	if 	((Type == CeilBASEtx) 	&& 	(!GetSectorLightLevel(CeilBASEtx)))		Result = "F_SKY1";
else 	if 	((Type == FlatFAILtx) 	&& 	(!GetSectorLightLevel(FlatFAILtx)))		Result = "FLTBLACK";

else																		Result = StrParam(i:GetSectorLightLevel(TIDRAM_Mood), s:PrefixType, i:GetSectorLightLevel(Type));



return Result;
}












function int ContainerMass (int WhatToReturn, int ContainerType, int Direction)
{
int Result, XXX, YYY;
	if ((Direction == ToRight)||(Direction == ToLeft))
		{
		Switch(ContainerType)
			{
			CASE OneBlock: 		XXX = 1; YYY = 1; break;
			CASE TwoBlocks: 	XXX = 2; YYY = 1; break;
			CASE ThreeBlocks: 	XXX = 3; YYY = 1; break;
			CASE FourBlocks: 	XXX = 2; YYY = 2; break;
			}
		}
	else if ((Direction == ToDown)||(Direction == ToUp))
		{
		Switch(ContainerType)
			{
			CASE OneBlock: 		XXX = 1; YYY = 1; break;
			CASE TwoBlocks: 	XXX = 1; YYY = 2; break;
			CASE ThreeBlocks: 	XXX = 1; YYY = 3; break;
			CASE FourBlocks: 	XXX = 2; YYY = 2; break;
			}
		}


Switch(WhatToReturn)
	{
	Case AxisX: Result = XXX; break;
	Case AxisY: Result = YYY; break;
	}
Return Result;
}



/*

																	BordersType


		  |    	             |    	             |    	             |    	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
               	             |    	                  	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
	      |    	             |    	             |    	             |    	             |    	             |
----  ----         ----------          ----------          ----  ----                                                  ----------             ----  ----

    1                   2                  3                     4               5                   6                      7                     8                    9


												|
												|
												|
												|
												c
												|
												|
												|
												|
											<---y---	ContainerEntryY
												|
												|
												|
												|
												|
												d
												|
												|
						^						|
						|						|
----------a-------------x---------------b--------
						|
						|

				ContainerEntryX





*/





int Order[5];
int BordersTypeOf_Order[5];


function int ContainerInfo (int InfoType, int ContainerType, int OrderNum, int BlockCounter, int Direction)
{
int Result, BlocksAmount, ContainerEntryX, ContainerEntryY;


Switch(ContainerType)
	{
	case OneBlock:		BlocksAmount = 1;
				Order[1] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 1;
				ContainerEntryX = BlockCounter + 0;
				ContainerEntryY = BlockCounter + 0;
	break;


	case TwoBlocks:		BlocksAmount = 2;

			if (Direction == ToRIGHT)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + 1;
				BordersTypeOf_Order[1] = 7;
				BordersTypeOf_Order[2] = 1;
				}
			if (Direction == ToDOWN)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				BordersTypeOf_Order[1] = 6;
				BordersTypeOf_Order[2] = 4;
				}
			if (Direction == ToLEFT)
				{
				Order[1] = 	BlockCounter + 1;
				Order[2] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 1;
				BordersTypeOf_Order[2] = 7;
				}
			if (Direction == ToUP)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[2] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 4;
				BordersTypeOf_Order[2] = 6;
				}


			if ((Direction == ToRIGHT)||(Direction == ToLEFT))
				{
				ContainerEntryX = BlockCounter + 0;
				ContainerEntryY = BlockCounter + 1;
				}
			if ((Direction == ToDOWN)||(Direction == ToUP))
				{
				ContainerEntryX = BlockCounter + sqrt(PlaygroundBlocks);
				ContainerEntryY = BlockCounter + 0;
				}
	break;



	case ThreeBlocks:		BlocksAmount = 3;

			if (Direction == ToRIGHT)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + 1;
				Order[3] = 	BlockCounter + 2;
				BordersTypeOf_Order[1] = 7;
				BordersTypeOf_Order[2] = 8;
				BordersTypeOf_Order[3] = 3;
				}
			if (Direction == ToDOWN)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[3] = 	BlockCounter + sqrt(PlaygroundBlocks)*2;
				BordersTypeOf_Order[1] = 5;
				BordersTypeOf_Order[2] = 6;
				BordersTypeOf_Order[3] = 4;
				}
			if (Direction == ToLEFT)
				{
				Order[1] = 	BlockCounter + 2;
				Order[2] = 	BlockCounter + 1;
				Order[3] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 3;
				BordersTypeOf_Order[2] = 8;
				BordersTypeOf_Order[3] = 7;
				}
			if (Direction == ToUP)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks)*2;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[3] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 4;
				BordersTypeOf_Order[2] = 6;
				BordersTypeOf_Order[3] = 5;
				}


			if ((Direction == ToRIGHT)||(Direction == ToLEFT))
				{
				ContainerEntryX = BlockCounter + 1;
				ContainerEntryY = BlockCounter + 2;
				}
			if ((Direction == ToDOWN)||(Direction == ToUP))
				{
				ContainerEntryX = BlockCounter + sqrt(PlaygroundBlocks)*2;
				ContainerEntryY = BlockCounter + sqrt(PlaygroundBlocks);
				}
	break;

	case FourBlocks:		BlocksAmount = 4;

			if (Direction == ToRIGHT)
				{
				Order[1] = 	BlockCounter + 0;
				Order[2] = 	BlockCounter + 1;
				Order[3] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				Order[4] = 	BlockCounter + sqrt(PlaygroundBlocks);
				BordersTypeOf_Order[1] = 9;
				BordersTypeOf_Order[2] = 6;
				BordersTypeOf_Order[3] = 4;
				BordersTypeOf_Order[4] = 7;
				}
			if (Direction == ToDOWN)
				{
				Order[1] = 	BlockCounter + 1;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				Order[3] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[4] = 	BlockCounter + 0;
				BordersTypeOf_Order[1] = 6;
				BordersTypeOf_Order[2] = 4;
				BordersTypeOf_Order[3] = 7;
				BordersTypeOf_Order[4] = 9;
				}
			if (Direction == ToLEFT)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				Order[2] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[3] = 	BlockCounter + 0;
				Order[4] = 	BlockCounter + 1;
				BordersTypeOf_Order[1] = 4;
				BordersTypeOf_Order[2] = 7;
				BordersTypeOf_Order[3] = 9;
				BordersTypeOf_Order[4] = 6;
				}
			if (Direction == ToUP)
				{
				Order[1] = 	BlockCounter + sqrt(PlaygroundBlocks);
				Order[2] = 	BlockCounter + 0;
				Order[3] = 	BlockCounter + 1;
				Order[4] = 	BlockCounter + sqrt(PlaygroundBlocks) + 1;
				BordersTypeOf_Order[1] = 7;
				BordersTypeOf_Order[2] = 9;
				BordersTypeOf_Order[3] = 6;
				BordersTypeOf_Order[4] = 4;
				}

				ContainerEntryX = BlockCounter + sqrt(PlaygroundBlocks) + 1;
				ContainerEntryY = BlockCounter + 1;
	break;
	}



Switch(InfoType)
	{
	CASE InfoType_ORDER:			Result = Order[OrderNum];					break;
	CASE InfoType_BORDERTYPE:		Result = BordersTypeOf_Order[OrderNum];		break;
	CASE InfoType_EntryX:			Result = ContainerEntryX;					break;
	CASE InfoType_EntryY:			Result = ContainerEntryY;					break;
	CASE InfoType_BLOCKSAMOUNT:		Result = BlocksAmount;						break;
	}



Return Result;
}




function int BorderTypeWNoEntrance (int BorderType)
{
int Result;
Switch(BorderType)
		{
		CASE 1: Result = 2;	break;
		CASE 2: Result = 2;	break;
		CASE 3: Result = 2;	break;
		CASE 4: Result = 2;	break;
		CASE 5: Result = 5;	break;
		CASE 6: Result = 5;	break;
		CASE 7: Result = 7;	break;
		CASE 8: Result = 7;	break;
		CASE 9: Result = 9;	break;
		}
return Result;
}





function int B2S (int BlockNum)	// BLOCK TO SECTOR
{
int Result = BlockNum*100;
return Result;
}

Script "XX2X" (int Num)
{
RegisterPlayer(Num, MaxMoney, DOESNT_MATTER);
}



#libdefine	StartA		1
#libdefine	EndA		2
#libdefine	StartB		3
#libdefine	EndB		4
#libdefine	StartC		5
#libdefine	EndC		6
#libdefine	StartD		7
#libdefine	EndD		8
#libdefine	EntryY		9
#libdefine	EntryX		10
#libdefine	BorderCross	11

function int BorderSegment(int Segment)
{
int Result;
Switch(Segment)
		{
		CASE StartA:		Result = 64;								break;
		CASE EndA:			Result = 66;								break;

		CASE EntryY:		Result = 67;								break;

		CASE StartB:		Result = 68 + RoundInfo[OptEntranceY];		break;
		CASE EndB:			Result = 71; 								break;
//----------------------------------------------------------------------------------
		CASE StartC:		Result = 73;								break;
		CASE EndC:			Result = 75; 								break;

		CASE EntryX:		Result = 76; 								break;

		CASE StartD:		Result = 77 + RoundInfo[OptEntranceX];		break;
		CASE EndD:			Result = 80; 								break;
//==================================================================================
		CASE BorderCross:	Result = 72; 								break;
		}
return Result;
}


/*

		  |    	             |    	             |    	             |    	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
               	             |    	                  	             |    	             |
          |    	             |    	             |    	             |    	             |    	             |
	      |    	             |    	             |    	             |    	             |    	             |
----  ----         ----------          ----------          ----  ----                                                  ----------             ----  ----

    1                   2                  3                     4               5                   6                      7                     8                    9

*/






/*				*/		#libdefine		BorderFill_None			0
/*	----------	*/		#libdefine		BorderFill_Full			1
/*	----  ----	*/		#libdefine		BorderFill_wEntrance	2


#libdefine		BorderSideX	0
#libdefine		BorderSideY	1






function void SetWarmupBlockLines (bool what)
{
int i, counter;
while (counter < 4) //Rotating directions
	{
	counter++;
	for (i = 24; 	i <= 25;  i++)
		{
		Switch(What)
			{
			CASE TRUE:
			SetLineTexture	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), SIDE_FRONT, TEXTURE_MIDDLE, "ANLAZA01");
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	BLOCKF_SIGHT, 		false);
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	BLOCKF_EVERYTHING, 	false);
			TranslucentLine	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), 255, TRUE);
			break;

			CASE FALSE:
			SetLineTexture	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), SIDE_FRONT, TEXTURE_MIDDLE, "-");
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	false, 		BLOCKF_SIGHT);
			Line_SetBlocking(LineAt (RoundInfo[StartpointTAG]/100, counter, i),	false, 		BLOCKF_EVERYTHING);
			TranslucentLine	(LineAt (RoundInfo[StartpointTAG]/100, counter, i), 255, FALSE);
			break;
			}
		}
	}
}







#libdefine dlt_MAIN			0
#libdefine dlt_EDGE			1
#libdefine dlt_EDGECAPE		2
#libdefine dlt_MAIN2EDGE	3

#libdefine dlt_DRAW			0
#libdefine dlt_CLEAR		1

function void ClearBlockTextures (int BlockCounter)
{
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToRIGHT,	64);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToRIGHT,	65);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToRIGHT,	66);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	67);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	68);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	69);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	70);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	71);
/*
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToDOWN,	64);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToDOWN,	65);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToDOWN,	66);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToDOWN, 	67);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToDOWN, 	68);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToDOWN, 	69);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToDOWN, 	70);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToDOWN, 	71);*/

DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToRIGHT,	73);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToRIGHT,	74);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE, 	BlockCounter, ToRIGHT,	75);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	76);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	77);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	78);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	79);
DrawLineTexture (dlt_CLEAR,  dlt_EDGE,	BlockCounter, ToRIGHT, 	80);

DrawLineTexture (dlt_CLEAR,  dlt_MAIN, 	BlockCounter, DOESNT_MATTER, DOESNT_MATTER);
}





function void DrawLineTexture (int WhatToDo, int Which, int BlockCounter, int Direction, int seg)
{
int LineTag;



if (WhatToDo == dlt_DRAW)
	{


			//MAIN
		if (Which == dlt_MAIN)
			{
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_BACK, 	TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(LineAt (BlockCounter, Direction, 0), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallSECOtx));
			}

			//MAIN TX but FILL THE BORDER
		if (Which == dlt_MAIN2EDGE)
			{
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_BACK,	TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_BACK,	TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_BACK,	TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallSECOtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_BACK,	TEXTURE_BOTTOM, 	TextureIs(WallBASEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallSECOtx));
			}


			//BORDER

		if (Which == dlt_EDGE)
			{
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_BACK, 	TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_BACK, 	TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_BACK, 	TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg), 	SIDE_BACK, 	TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			}


		if (Which == dlt_edgeCAPE)
			{
			SetLineTexture		(CapeHeader 		+ BlockCounter, 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(CapeHeader 		+ BlockCounter, 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			SetLineTexture		(CapeHeaderINNER 	+ BlockCounter, 	SIDE_FRONT, TEXTURE_TOP, 		TextureIs(WallEDGEtx));
			SetLineTexture		(CapeHeaderINNER 	+ BlockCounter, 	SIDE_FRONT, TEXTURE_BOTTOM, 	TextureIs(WallEDGEtx));
			}
	}



if (WhatToDo == dlt_CLEAR)
	{

			//MAIN MID
		if (Which == dlt_MAIN)
			{

			SetLineTexture		(BlockCounter, 	SIDE_FRONT, TEXTURE_MIDDLE, 	TextureIs(None));
			SetLineTexture		(BlockCounter, 	SIDE_BACK, 	TEXTURE_MIDDLE, 	TextureIs(None));
			Line_SetBlocking	(BlockCounter, 	false,  BLOCKF_EVERYTHING);
			Line_SetBlocking	(BlockCounter, 	false, BLOCKF_SIGHT);
			Line_SetBlocking 	(BlockCounter, 	false, BLOCKF_PROJECTILES);
			SetLineBlocking		(BlockCounter,	BLOCK_NOTHING);
			SetLineSpecial		(BlockCounter,  0, 0, 0, 0, 0, 0);
			}


			//BORDER
/*
		if (Which == dlt_EDGE)
			{
			//frontside
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)), 	false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)), 	false, BLOCKF_SIGHT);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),  false, BLOCKF_PROJECTILES);
			SetLineBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),	BLOCK_NOTHING);
			SetLineSpecial(		LineAt (BlockCounter, Direction, AssignLine (SIDE_FRONT, 	seg)),  0, 0, 0, 0, 0, 0);
			//backside
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)), 	false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)), 	false, BLOCKF_SIGHT);
			Line_SetBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),  false, BLOCKF_PROJECTILES);
			SetLineBlocking(	LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	BLOCK_NOTHING);
			SetLineSpecial(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),  0, 0, 0, 0, 0, 0);
			//sidey
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		LineAt (BlockCounter, Direction, AssignLine (SIDE_BACK, 	seg)),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			}
*/
		if (Which == dlt_EDGE)
			{
			//frontside
			SetLineTexture(		B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg), 	false, BLOCKF_SIGHT);
			Line_SetBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg),	false, BLOCKF_PROJECTILES);
			SetLineBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg),	BLOCK_NOTHING);
			SetLineSpecial(		B2S(BlockCounter)	+	AssignLine (SIDE_FRONT, 	seg),	0, 0, 0, 0, 0, 0);
			//backside
			SetLineTexture(		B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			Line_SetBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	false, BLOCKF_EVERYTHING);
			Line_SetBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	false, BLOCKF_SIGHT);
			Line_SetBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	false, BLOCKF_PROJECTILES);
			SetLineBlocking(	B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	BLOCK_NOTHING);
			SetLineSpecial(		B2S(BlockCounter)	+	AssignLine (SIDE_BACK, 		seg),	0, 0, 0, 0, 0, 0);
			//sidey
			SetLineTexture(		B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg),	SIDE_FRONT,	TEXTURE_MIDDLE, TextureIs(None));
			SetLineTexture(		B2S(BlockCounter)	+	AssignLine (SIDE_SIDEY, 	seg),	SIDE_BACK,	TEXTURE_MIDDLE, TextureIs(None));
			}


	}

}


/*

function void SetOutsideLines (int Which, int Turn, str Tex)
{
int Block, Unblock, Reblock;

		Switch(Which)
				{
				CASE LINETAG_PlaygroundFence:				Block = BLOCKF_EVERYTHING;		Unblock = None; 			Reblock = None;					break;
				CASE LINETAG_PlaygroundPerimeter:			Block = BLOCKF_PLAYERS;			Unblock = BLOCKF_MONSTERS;	Reblock = BLOCKF_MONSTERS;		break;
				}

Switch(Turn)
	{
	CASE ON:
	SetLineTexture(		Which, SIDE_FRONT, TEXTURE_MIDDLE, tex);
	Line_SetBlocking(	Which, Block, Unblock);
	break;

	CASE OFF:
	SetLineTexture(		Which, SIDE_FRONT, TEXTURE_MIDDLE, "-");
	Line_SetBlocking(	Which, None, BLOCKF_EVERYTHING);
	Line_SetBlocking(	Which, Reblock, None);
	break;
	}
}

*/






function void FillContainerBorders (int ContainerType, int BlockCounter, int Direction)
{

int counter, Xmethod, YMethod, clm, tempBC /*, START1, END1, START2, END2*/;
bool cross;

While (counter	<	ContainerInfo (InfoType_BLOCKSAMOUNT, ContainerType, DOESNT_MATTER, BlockCounter, Direction))
	{
	counter++;

	tempBC = ContainerInfo(InfoType_ORDER, ContainerType, counter, BlockCounter, Direction);



/*DEBUG*/ 	Switch(ContainerInfo(InfoType_BORDERTYPE, ContainerType, counter, BlockCounter, Direction))	//Switch(1)//
		{
		CASE 1:	Xmethod = 2;	YMethod = 2;	break;
		CASE 2:	Xmethod = 1;	YMethod = 1;	break;
		CASE 3:	Xmethod = 1;	YMethod = 2;	break;
		CASE 4:	Xmethod = 2;	YMethod = 1;	break;
		CASE 5:	Xmethod = 0;	YMethod = 1;	break;
		CASE 6:	Xmethod = 0;	YMethod = 2;	break;
		CASE 7:	Xmethod = 1;	YMethod = 0;	break;
		CASE 8:	Xmethod = 2;	YMethod = 0;	break;
		CASE 9:	Xmethod = 0;	YMethod = 0;	break;
		}


if (BlockCounterAtTheEdge(ToDOWN, 	tempBC) == FALSE)		//Don't do this in the last rows
SetBorderWall(BorderSideX, Xmethod, tempBC, Direction);


if (BlockCounterAtTheEdge(ToRIGHT, 	tempBC) == FALSE)		//Don't do this in the last columns
SetBorderWall(BorderSideY, Ymethod, tempBC, Direction);


	}

}


Script "ChangeCapeCeiling" (int BlockCounter)
{
delay(GenDel_Height);
Ceiling_MoveToValue		(CapeHeader + BlockCounter,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
ChangeCeiling			(CapeHeader + BlockCounter,   TextureIs(CeilBASEtx));
}



function void SetBorderWall (int Side, int Method, int BlockCounter, int Direction)
{

int seg, exc, Start1, End1, Start2, End2, AddBorderEntryHeight, Entry, OptEntry;
bool DontMoveSector;
int excA = 0;
int excB = RoundInfo[BorderExceptionCounter];




Switch(SIDE)
	{
	CASE BorderSideY:
	Start1 = StartA;	End1 = EndA;	Start2 = StartB;	End2 = EndB;	Entry = BorderSegment(EntryY);		OptEntry = RoundInfo[OptEntranceY];		AddBorderEntryHeight = RoundInfo[AddBorderEntryHeightY];
	break;

	CASE BorderSideX:
	Start1 = StartC;	End1 = EndC;	Start2 = StartD;	End2 = EndD;	Entry = BorderSegment(EntryX);		OptEntry = RoundInfo[OptEntranceX];		AddBorderEntryHeight = RoundInfo[AddBorderEntryHeightX];
	break;
	}



//wide open entrance if its a flow adventure
if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)
		if(Method == BorderFill_wEntrance)
					{
					AddBorderEntryHeight = 0;
					AddBorderEntryHeight = 0;
					Method = BorderFill_None;
					}




				if
				(
				(BlockCounterAtTheEdge(ToRIGHT, BlockCounter) == TRUE) ||
				(BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE) ||
				(BlockCounterAtTheEdge(ToLEFT, 	BlockCounter) == TRUE) ||
				(BlockCounterAtTheEdge(ToUP, 	BlockCounter) == TRUE)
				)
					{
					Floor_MoveToValue	(CapeHeader + BlockCounter,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
					ChangeFloor			(CapeHeader + BlockCounter,   TextureIs(FlatEDGEtx));
					ACS_NamedExecuteAlways("ChangeCapeCeiling", 0, BlockCounter);
					DrawLineTexture 	(dlt_DRAW, dlt_edgeCAPE,	BlockCounter, Direction, seg);
					}



//but it will do the same shit twice, idfcare meh
if (Method > BorderFill_None)

			Floor_MoveToValue(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + BorderSegment(BorderCross),	MoveInstantly, RoundInfo[GlobalCeilingHeight]);


	Switch(Method)
		{


//	-                       -
//  -                      -
		CASE BorderFill_None:

			if (((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideY)) ||
				((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideX)))
					{
					seg = BorderSegment(Start1);
					while(seg <= BorderSegment(End2))
						{
						exc = excA;	while(exc <= excB)	//for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								exc++;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[CurrFloorHeight] + AddBorderEntryHeight);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatBASEtx));
								}
						DrawLineTexture 	(dlt_DRAW, dlt_MAIN2EDGE,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}

					}


		break;

//	-------------------------
//  -------------------------
		CASE BorderFill_Full:


			if (((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideY)) ||
				((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideX)))
					{
					seg = BorderSegment(Start1);
					while(seg <= BorderSegment(End2))
						{
						exc = excA;	while(exc <= excB)	//for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								exc++;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatEDGEtx));

								}
						DrawLineTexture 	(dlt_DRAW, dlt_EDGE,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}

					}












		break;




//	---------|     |---------
//  ---------|     |---------
		CASE BorderFill_wEntrance:

			if (((BlockCounterAtTheEdge(ToRIGHT, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideY)) ||
				((BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == FALSE)		&&		(SIDE == BorderSideX)))
				{
					seg = BorderSegment(Start1);
					while(seg <= BorderSegment(End1))
						{
						exc = excA;	while(exc <= excB)	//for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								exc++;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatEDGEtx));


								}
						DrawLineTexture 	(dlt_DRAW, dlt_EDGE,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}





					seg = BorderSegment(Start2);
					while(seg <= BorderSegment(End2))
						{
						exc = excA;	while(exc <= excB)	//for (exc = excA; exc <= excB; exc++)
								{
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_EMITSPOT])		DontMoveSector = true;
								if ((B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg) == Projectila[exc][ProjParam_DEVOURSPOT])	DontMoveSector = true;
								exc++;
								}

						if (DontMoveSector == false)
								{
								Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   MoveInstantly, RoundInfo[GlobalCeilingHeight]);
								ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + seg,   TextureIs(FlatEDGEtx));
								}

						DrawLineTexture 	(dlt_DRAW, dlt_EDGE,	BlockCounter, Direction, seg);
						DontMoveSector = false;
						seg++;
						}
				}



				Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry,						MoveInstantly, RoundInfo[CurrFloorHeight] + AddBorderEntryHeight);
				ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry,   					TextureIs(FlatBASEtx));
				DrawLineTexture 	(dlt_DRAW, dlt_EDGE,	BlockCounter, Direction, Entry);


			if(OptEntry == TRUE)
				{
				Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry + OptEntry,			MoveInstantly, RoundInfo[CurrFloorHeight] + AddBorderEntryHeight);
				ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, Direction)) + Entry + OptEntry,   		TextureIs(FlatBASEtx));
				DrawLineTexture 	(dlt_DRAW, dlt_EDGE,	BlockCounter, Direction, Entry + OptEntry);
				}


		break;
		}



}












/*

 __________   ___  _______   ______  __    __  .___________. __    ______   .__   __.
|   ____\  \ /  / |   ____| /      ||  |  |  | |           ||  |  /  __  \  |  \ |  |
|  |__   \  V  /  |  |__   |  ,----'|  |  |  | `---|  |----`|  | |  |  |  | |   \|  |
|   __|   >   <   |   __|  |  |     |  |  |  |     |  |     |  | |  |  |  | |  . `  |
|  |____ /  .  \  |  |____ |  `----.|  `--'  |     |  |     |  | |  `--'  | |  |\   |
|_______/__/ \__\ |_______| \______| \______/      |__|     |__|  \______/  |__| \__|



*/


Script "PlayerENTER" 	ENTER			{
											if   (GetPort() > ZDaemon)
											if (((GetPort() == Zandronum) && (!IsNetworkGame())) || (GetPort() == GZDoom))
												ScreenFade(For_ActivatorOnly, 1.0, CR_BLACK, 0.0, 0.5, 1.5);
												delay(1);	SetPlayerStuff();

										}

Script "PlayerRESPAWN" 	RESPAWN			{DamageThing(InstantDeath, MOD_UNKNOWN);} //delay(1);	SetPlayerStuff();}
Script "PlayerDEATH" 	DEATH			{ChangeCamera(0, 0, 0);}



Script "OfficialServer" (void) NET CLIENTSIDE
	{
	Switch(GetPort())
		{
		CASE GZDoom:
		DemoMessage(1);
		break;

		CASE Zandronum:
		if (!IsNetworkGame())	ConsoleCommand(StrParam(s:"connect ", s:GetCvarString("ER_ServerAddress")));
		else					ConsoleCommand("Join");
		break;
		}
	}


Script "BOOT" OPEN
{
int i;
str StringA = "";
SetActivator(0, AAPTR_NULL);
//--------------------------------------------------------------------------------------------------C H E C K   P O R T
SpawnSpotForced("GZDoomSpot", 				ACTORTID_PortSpot, 	ACTORTID_GZDoomTag, 	0);			//GZDOOM
SpawnSpotForced("ZandronumSpot", 			ACTORTID_PortSpot, 	ACTORTID_ZandronumTag,	0);			//ZANDRONUM
																									//ZDAEMON
SetPort();
//------------------------------------------------------------------------------------------------------------------------------------------
ACS_NamedExecute("Debug_SERVER", 0);


//ForceSpec all players after map win
if (ServerInfo[ZANmapwin])
	{
	ServerInfo[ZANmapwin] = FALSE;
	for(i = 0; i < MaxPlayers; i++)		KickFromGame(i, "MAP RELOADED!");
	}

i = 0;
MapPreset(1);



Switch(GetPort())
		{
		CASE Zandronum:
		if (!GetCvar("Survival"))	ACS_NamedExecute("EXE", 0);
		break;

		CASE ZDaemon:
		CASE GZDoom:
		ACS_NamedExecute("EXE", 0);
		break;
		}







ACS_NamedExecute("MISC", 0);

}







Script "LOAD" (void)
{

/*
  __  __                         _   ____                _
 |  \/  | __ _ _ __  _   _  __ _| | |  _ \ ___  ___  ___| |_
 | |\/| |/ _` | '_ \| | | |/ _` | | | |_) / _ \/ __|/ _ \ __|
 | |  | | (_| | | | | |_| | (_| | | |  _ <  __/\__ \  __/ |_
 |_|  |_|\__,_|_| |_|\__,_|\__,_|_| |_| \_\___||___/\___|\__|

*/

//it comes to this point if an admin has changed/restored game status himself
ServerInfo[ServerStarted] = TRUE;
ManualStatsImport();
delay(SEC*5);
MapReset();

}








Script "EXE" (void)
{


// If server just booted with predefined STATS

if 		(!ServerInfo[ServerStarted])
if 		(	(StrToNum(MergedStringInfo ('#', SVDT_Season,	GetCVarString("STATS")))) 		||
			(StrToNum(MergedStringInfo ('#', SVDT_Stage,	GetCVarString("STATS"))))		||
			(StrToNum(MergedStringInfo ('#', SVDT_Try,		GetCVarString("STATS"))))		)

					{
						ServerInfo[ServerStarted] = TRUE;
						ManualStatsImport();
						delay(SEC*5);
						MapReset();
					}



ServerInfo[ServerStarted] = TRUE;


int counter, counterB, tempCounter, i, Iteration, tmp;
str tempStr, StringA = "";



Light_ChangeToValue(TIDRAM_GameSim, TRUE);





//TITLEMAP
if (GetPort() == Zandronum)
	if (!IsNetworkGame())	i = TRUE;
if (GetPort() == GZDoom) 	i = TRUE;

if (i)
	{
	Light_ChangeToValue(TIDRAM_Intro, TRUE);
	for(i = LINETAG_VolumetricD_up; i <= LINETAG_VolumetricD_dn; i++)		TranslucentLine(i, 0, TRUE);
	for(i = 8; i < MaxPlayers; i++)		Thing_Remove(ACTORTID_PlayerSpawner + i);
	ACS_NamedExecute("CUTSCENE", 0, 2);
	SpawnSpotForced("ShopSequence", ACTORTID_SkyboxCamera, ACTORTID_SkyChant, 0);
	Switch(GetPort())
		{
		CASE Zandronum:
			while(TRUE)
				{
				if (GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS))
					if (!((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & (BT_SHOWSCORES))))	break;
				delay(1);
				}
		break;
		CASE GZDoom:		while ((!GetActorVelX(PLAYER_TID)) && (!GetActorVelY(PLAYER_TID)) && (!GetActorVelZ(PLAYER_TID)))		delay(1);		break;
		}
	Light_ChangeToValue(TIDRAM_Intro, FALSE);
	Thing_Remove(ACTORTID_SkyChant);
	ACS_NamedTerminate("CUTSCENE", 0);
	ScreenFade(For_ActivatorOnly, 1.0, CR_WHITE, 0.0, 0.25, 1.0);
	ChangeCamera(0, 1, 0);
	}






//Change the Mood and Location
//GAMEINFO[Mood] 			= RNG(1, 3);		//3
//GAMEINFO[Location] 		= RNG(1, 9);		//9
Light_ChangeToValue(TIDRAM_Mood, 		RNG(1, 3));
Light_ChangeToValue(TIDRAM_Location,	RNG(1, 9));
Light_ChangeToValue(TIDRAM_SkyType, 	GetSectorLightLevel(TIDRAM_Mood)*10 + GetSectorLightLevel(TIDRAM_Location));


MapPreset(2);


/*
  _____ ___ ____  ____ _____   _        _   _   _ _   _  ____ _   _                _                           _            _
 |  ___|_ _|  _ \/ ___|_   _| | |      / \ | | | | \ | |/ ___| | | |  _   ___  ___| |_   ___ ___ _ __      ___| |_ __ _    | |_ _ __ _   _
 | |_   | || |_) \___ \ | |   | |     / _ \| | | |  \| | |   | |_| | (_) / __|/ _ \ __| / __/ __| '_ \    / __| __/ _` |   | __| '__| | | |
 |  _|  | ||  _ < ___) || |   | |___ / ___ \ |_| | |\  | |___|  _  |  _  \__ \  __/ |_  \__ \__ \ | | |_  \__ \ || (_| |_  | |_| |  | |_| |
 |_|   |___|_| \_\____/ |_|   |_____/_/   \_\___/|_| \_|\____|_| |_| (_) |___/\___|\__| |___/___/_| |_( ) |___/\__\__, ( )  \__|_|   \__, |
                                                                                                      |/          |___/|/            |___/

*/
	if (ServerInfo[STAGE])		if (!ServerInfo[SEASON])		{	ServerInfo[SEASON]		= 1;	ServerInfo[TRY]		= 1;	}
	if (ServerInfo[SEASON])		if (!ServerInfo[STAGE])			{	ServerInfo[STAGE]		= 1;	ServerInfo[TRY]		= 1;	}
	if (!ServerInfo[TRY])																			ServerInfo[TRY]		= 1;




if (ServerInfo[SEASON])
if (ServerInfo[SEASON] != 999)	{ServerInfo[SEASON] = 999;	log(s:"During alpha test SEASON is forced to 999");}


// Set Maximum letter limit in the name by the port.

Switch(GetPort())
	{
	Case ZDaemon:		GAMEINFO[MaxNameChars] = MaxNameCharsZDA;	break;
	Case Zandronum: 	GAMEINFO[MaxNameChars] = MaxNameCharsZDA;	break;	//ZAN : because there is map limits to make monument zan's counter will euqal zdaemon's
	}

/*

  _____ ___ ____  ____ _____   _        _   _   _ _   _  ____ _   _        __ _ _ _                              _                _ _   _       ____  ____   _    ____ _____        _
 |  ___|_ _|  _ \/ ___|_   _| | |      / \ | | | | \ | |/ ___| | | |  _   / _(_) | |  _ __ ___  ___ ___  _ __ __| |___  __      _(_) |_| |__   / ___||  _ \ / \  / ___| ____|   ___| |__   __ _ _ __
 | |_   | || |_) \___ \ | |   | |     / _ \| | | |  \| | |   | |_| | (_) | |_| | | | | '__/ _ \/ __/ _ \| '__/ _` / __| \ \ /\ / / | __| '_ \  \___ \| |_) / _ \| |   |  _|    / __| '_ \ / _` | '__|
 |  _|  | ||  _ < ___) || |   | |___ / ___ \ |_| | |\  | |___|  _  |  _  |  _| | | | | | |  __/ (_| (_) | | | (_| \__ \  \ V  V /| | |_| | | |  ___) |  __/ ___ \ |___| |___  | (__| | | | (_| | |
 |_|   |___|_| \_\____/ |_|   |_____/_/   \_\___/|_| \_|\____|_| |_| (_) |_| |_|_|_| |_|  \___|\___\___/|_|  \__,_|___/   \_/\_/ |_|\__|_| |_| |____/|_| /_/   \_\____|_____|  \___|_| |_|\__,_|_|

*/

if (!WinnerNames[0]) 	for (i = 0; i < GAMEINFO[MaxNameChars]*MaxStages; i++)	WinnerNames[i] = '-';
if (!LegendNames[0]) 	for (i = 0; i < GAMEINFO[MaxNameChars]*MaxLegends; i++)	LegendNames[i] = 32;





//otherwise
/*
  ___                            _    __        ___                             _          _                 _
 |_ _|_ __ ___  _ __   ___  _ __| |_  \ \      / (_)_ __  _ __   ___ _ __ ___  | |_ ___   | | ___   ___ __ _| |  _ __ ___   ___ _ __ ___   ___  _ __ _   _
  | || '_ ` _ \| '_ \ / _ \| '__| __|  \ \ /\ / /| | '_ \| '_ \ / _ \ '__/ __| | __/ _ \  | |/ _ \ / __/ _` | | | '_ ` _ \ / _ \ '_ ` _ \ / _ \| '__| | | |
  | || | | | | | |_) | (_) | |  | |_    \ V  V / | | | | | | | |  __/ |  \__ \ | || (_) | | | (_) | (_| (_| | | | | | | | |  __/ | | | | | (_) | |  | |_| |
 |___|_| |_| |_| .__/ \___/|_|   \__|    \_/\_/  |_|_| |_|_| |_|\___|_|  |___/  \__\___/  |_|\___/ \___\__,_|_| |_| |_| |_|\___|_| |_| |_|\___/|_|   \__, |
               |_|                                                                                                                                   |___/

*/


Switch(GetPort())
	{
	Case ZDaemon:
	SetRAM(fromArray_WinnerNames);
	SetRAM(fromArray_LegendNames);
	break;


	Case Zandronum:







			BeginDBTransaction();

			ServerInfo[SEASON] 	= GetDBEntry("ServerInfo", "SEASON");
			ServerInfo[STAGE] 	= GetDBEntry("ServerInfo", "STAGE");

			if (GetDBEntry("ServerInfo", "TRY"))
			ServerInfo[TRY]		= GetDBEntry("ServerInfo", "TRY");



			/*
			  ___ ___ _    _           _                            _                       ___ ___
			 | __|_ _| |  | |       __| |_ __ _ __ _ ___    __ __ _(_)_ _  _ _  ___ _ _    |_ _|   \ ___
			 | _| | || |__| |__    (_-<  _/ _` / _` / -_)   \ V  V / | ' \| ' \/ -_) '_|    | || |) (_-<
			 |_| |___|____|____|   /__/\__\__,_\__, \___|    \_/\_/|_|_||_|_||_\___|_|     |___|___//__/
											   |___/
			*/


			if (!StrLen(GetDBEntryString(StrParam(s:"Season", i:ServerInfo[SEASON]), "1___StageWinner_ID")))
				{
				counter = 0;
				while (counter < MaxStages)
					{
					counter++;
					SetDBEntry(StrParam(s:"Season", i:ServerInfo[SEASON]), StrParam(i:counter, s:"___StageWinner_ID"), -1);
					}
				}


			/*
			  _                            _               _                _   _                          _
			 (_)_ __ ___  _ __   ___  _ __| |_    __ _  __| |_   _____ _ __| |_(_)___ _ __ ___   ___ _ __ | |_
			 | | '_ ` _ \| '_ \ / _ \| '__| __|  / _` |/ _` \ \ / / _ \ '__| __| / __| '_ ` _ \ / _ \ '_ \| __|
			 | | | | | | | |_) | (_) | |  | |_  | (_| | (_| |\ V /  __/ |  | |_| \__ \ | | | | |  __/ | | | |_
			 |_|_| |_| |_| .__/ \___/|_|   \__|  \__,_|\__,_| \_/ \___|_|   \__|_|___/_| |_| |_|\___|_| |_|\__|
						 |_|
			*/


			//if blank import the default ones
			counter = 0;
			while(counter < MaxAdds)
				{
				counter++;
				if (!StrLen(GetDBEntryString("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Line", i:i))))
						{
						SetDBEntry("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Color"), DefaultAdvertisementColor(counter));	//set color
						SetDBEntry("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Cost "), AdvertisementCost);						//set cost
						i = 0;
						while (i < MaxAddCharsY)	//set lines
							{
							i++;
							SetDBEntryString("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Line", i:i), DefaultAdvertisement(counter, i));
							}

						}

				}

			//import adverts from DB to game
			counter = 0;
			while(counter < MaxAdds)
				{
				counter++;
				AdvertisementMisc[counter][adv_COLOR] =	GetDBEntry("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Color"));
				AdvertisementMisc[counter][adv_COST] = 	GetDBEntry("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Cost"));
				Light_ChangeToValue(TIDRAM_AdvertisementCost + counter, AdvertisementMisc[counter][adv_COST]);
						i = 0;
						while (i < MaxAddCharsY)	//set lines
							{
							i++;
							Advertisement[counter][i] = GetDBEntryString("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Line", i:i));		//SetDBEntryString("ServerInfo", StrParam(s:"Advertisement", i:counter, s:"Line", i:i), DefaultAdvertisement(counter, i));
							}

				}






			/*
			  _                     _     _                      _
			 (_)_ __  _ __  ___ _ _| |_  | |___ __ _ ___ _ _  __| |___
			 | | '  \| '_ \/ _ \ '_|  _| | / -_) _` / -_) ' \/ _` (_-<
			 |_|_|_|_| .__/\___/_|  \__| |_\___\__, \___|_||_\__,_/__/
					 |_|                       |___/
			*/
			counter = 0;
			while(counter < (MaxLegends*GAMEINFO[MaxNameChars]))
				{
				i = GetChar(GetDBEntryString("ServerInfo", "Legends"), counter);
				if (!i)	i = 32; //SPACE

				LegendNames[counter] = i;
				counter++;
				}




			/*
			  ___                     _     ___ _
			 |_ _|_ __  _ __  ___ _ _| |_  | _ \ |__ _ _  _ ___ _ _ ___
			  | || '  \| '_ \/ _ \ '_|  _| |  _/ / _` | || / -_) '_(_-<
			 |___|_|_|_| .__/\___/_|  \__| |_| |_\__,_|\_, \___|_| /__/
					   |_|                             |__/
			*/

			ServerInfo[RegisteredPlayers] = GetDBEntry("ServerInfo", "RegisteredPlayers");


				counter = 0;
				while(counter <= ServerInfo[RegisteredPlayers])
					{


							//ACCOUNT NAME
							i = 0;
							while (i < MaxPortNameCharsZAN)
								{
								MoneyNAME[counter * MaxPortNameCharsZAN + i] = GetChar(GetDBEntryString("PlayerInfo", StrParam(s:"id_", i:counter, s:"___ACCOUNT")), i);
								i++;
								}



							//FLAG
							i = 0;
							while(i <= MaxFlags + 1)
								{
										if (!StrCmp(GetDBEntryString("PlayerInfo", StrParam(s:"id_", i:counter, s:"___FLAG")),		 StripColors(FlagName(i))))
												{
												FlagInfo[counter] = i;
												break;
												}


										i++;


										if(i >= MaxFlags)
												{
												FlagInfo[counter] = 0;
												SetDBEntryString	("PlayerInfo", StrParam(s:"id_", i:counter, s:"___FLAG"),	"None");
												break;
												}
								}


							//ELSE
							FlagCost[counter]		= GetDBEntry("PlayerInfo", StrParam(s:"id_", i:counter, s:"___FLAG_cost"));
							MoneyInfo[counter]		= GetDBEntry("PlayerInfo", StrParam(s:"id_", i:counter, s:"___MONEY"));

					counter++;
					}





			/*
			   __ _                            _
			  / _| |__ _ __ _  __ _____ _ _ __(_)___ _ _
			 |  _| / _` / _` | \ V / -_) '_(_-< / _ \ ' \
			 |_| |_\__,_\__, |  \_/\___|_| /__/_\___/_||_|
						|___/
			*/

/*
			if (GetDBEntry("ServerInfo", "FlagVersion") != FlagVersion)
				{
				SetDBEntry("ServerInfo", "FlagVersion", FlagVersion);
				counter = 0;
				while(counter <= ServerInfo[RegisteredPlayers])
					{
					if (FlagInfo[counter]	>=	FlagVersionChangeFromIndex)
							{
							FlagInfo[counter] = 0;
							FlagCost[counter] = 0;
							}
					counter++;
					}
				}
*/
			EndDBTransaction();

			ClientAdd();



/*
  ___ ___  ___  ___ ___     ___  __  __ ___ _      _   ___ ___
 | __/ _ \| _ \/ __| __|   |   \|  \/  | __| |    /_\ / __/ __|
 | _| (_) |   / (__| _|    | |) | |\/| | _|| |__ / _ \ (_ \__ \
 |_| \___/|_|_\\___|___|   |___/|_|  |_|_| |____/_/ \_\___|___/ for Zandronum

*/


/*			ZDaemon
			sv_joinlimit 1


*/


			if (!GetCvar("sv_ForceSoftwarePitchLimits")) 						consolecommand("set sv_ForceSoftwarePitchLimits 1");
			if ( GetCvar("sv_AirControl") != 0) 								consolecommand("set sv_AirControl 0");
			if (!GetCvar("Compat_Limited_AirMovement")) 						consolecommand("set Compat_Limited_AirMovement 1");
			if (!GetCvar("sv_ShootThroughAllies"))								consolecommand("set sv_ShootThroughAllies 1");
			if (!GetCvar("sv_DontPushAllies"))									consolecommand("set sv_DontPushAllies 1");
			if ( GetCvar("sv_WeaponDrop"))										consolecommand("set sv_WeaponDrop 0");
			if (!GetCvar("sv_NoDrop"))											consolecommand("set sv_NoDrop 1");
			if (!GetCvar("sv_NoRocketJumping"))									consolecommand("set sv_NoRocketJumping 1");
			if (!GetCvar("sv_ForceVideoDefaults"))								consolecommand("set sv_ForceVideoDefaults 1");
			if (!GetCvar("sv_NoCrouch"))										consolecommand("set sv_NoCrouch 1");
			if (!GetCvar("sv_ForceVideoDefaults"))								consolecommand("set sv_ForceVideoDefaults 1");
			if (!GetCvar("sv_Coop_LoseInventory"))								consolecommand("set sv_Coop_LoseInventory 1");
			if (!GetCvar("sv_UnblockPlayers"))									consolecommand("set sv_UnblockPlayers 1");
			if ( GetCvar("sv_ChaseCam"))										consolecommand("set sv_ChaseCam 0");
			//if ( GetCvar("sv_survivalcountdowntime") != 3)						consolecommand("set sv_survivalcountdowntime 3");
			if (!GetCvar("sv_afk2spec"))										consolecommand("set sv_afk2spec 3");
//			if (!GetCvar("Compat_Dont_Stop_Player_Scripts_On_Disconnect"))		consolecommand("set Compat_Dont_Stop_Player_Scripts_On_Disconnect 1");
			if ( GetCvar("sv_maxclients") > MaxPlayers)							consolecommand(StrParam(s:"set sv_maxclients ", i:MaxPlayers));

			i = 1 + ClientCount()*2;		if (i > 10) i = 10;
			consolecommand(StrParam(s:"set sv_survivalcountdowntime ", i:i));

			//DOESN'T WORK
			//if ( GetCvar("sv_Cheats"))					consolecommand("set sv_Cheats 0");
			//if (!GetCvar("sv_randomcoopstarts"))			consolecommand("set sv_randomcoopstarts 1");

			SetCvar("ER_SERVERGreetPlayerNumber", -1);
			SetCvar("ER_SERVERGreetString", "");

			break;
	}


if (GetPort() != GZDoom)		RenderLegends();


GAMEINFO[RoundsCount] = GetRoundsCount();


	//------ROUNDS-------------------------------------------------------------------------------------------------------

counter = 0;
while(counter < GAMEINFO[RoundsCount])
		{
		counter++;	tempCounter = counter;

		if ((tempCounter == GAMEINFO[RoundsCount]) && (GAMEINFO[RoundsCount] > 2))	//BOSSES
				{
				//Main Boss
				AdventureInfo[tempCounter][adv_TYPE] 	= 	adventure_BOSS;
				AdventureInfo[tempCounter][adv_MUSIC] 	= 	AssignMusic(MusicType(AdventureInfo[tempCounter][adv_TYPE]));

				//Optional Boss
				if (GAMEINFO[RoundsCount] >= MaxRounds - 1)
						Switch(RNG(false, true))
								{
								CASE TRUE:
								tempCounter = RNG(2,GAMEINFO[RoundsCount] - 2);
								AdventureInfo[tempCounter][adv_TYPE] = adventure_BOSS;
								AdventureInfo[tempCounter][adv_MUSIC] = AssignMusic(MusicType(AdventureInfo[tempCounter][adv_TYPE]));
								break;
								}
				}

		else
				{


				//Decide Adventure Type
				AdventureInfo[tempCounter][adv_TYPE]  = RNG(0, 98);
				//AdventureInfo[tempCounter][adv_TYPE]  = 66;
						if  (AdventureInfo[tempCounter][adv_TYPE] <  30)													AdventureInfo[tempCounter][adv_TYPE]  = adventure_MAZE;
				else	if ((AdventureInfo[tempCounter][adv_TYPE] >= 30) && (AdventureInfo[tempCounter][adv_TYPE] <  60)) 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_LINEAR;
				else	if ((AdventureInfo[tempCounter][adv_TYPE] >= 60) && (AdventureInfo[tempCounter][adv_TYPE] <  75)) 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_INVASION;
				else	if ((AdventureInfo[tempCounter][adv_TYPE] >= 75) && (AdventureInfo[tempCounter][adv_TYPE] <  99))	AdventureInfo[tempCounter][adv_TYPE]  = adventure_RAISE;
				else																									 	AdventureInfo[tempCounter][adv_TYPE]  = adventure_FLOW;

						//Dont duplicate some adventure types
						for (i = 0; i < tempCounter; i++)
											{
											if (AdventureInfo[i][adv_TYPE] ==  adventure_INVASION)	AdventureInfo[tempCounter][adv_TYPE]  = RNG(adventure_MAZE, adventure_LINEAR);
											if (AdventureInfo[i][adv_TYPE] ==  adventure_RAISE)		AdventureInfo[tempCounter][adv_TYPE]  = RNG(adventure_MAZE, adventure_LINEAR);
											if (AdventureInfo[i][adv_TYPE] ==  adventure_FLOW)		AdventureInfo[tempCounter][adv_TYPE]  = RNG(adventure_MAZE, adventure_LINEAR);
											}


				//Decide the othermusic
				if (counterB == 0)	{		AdventureInfo[tempCounter][adv_MUSIC] = AssignMusic(MusicType(AdventureInfo[tempCounter][adv_TYPE]));	if (RNG(false, true))	counterB++;	}
				else 				{		AdventureInfo[tempCounter][adv_MUSIC] = AdventureInfo[tempCounter - 1][adv_MUSIC];													CounterB--;	}
				}

	tempCounter = counter;
	//------DIFFICULTY-------------------------------------------------------------------------------------------------------

	//Decide the average difficulty
	if(IsCompetitive())
								{
								tmp	=	(FixedMul(int2fix(tempCounter), 3.5) >> 16)		+	(FixedMul(int2fix(ServerInfo[STAGE]), 3.5) >> 16) ;


								// Adventure Correction
								Switch(AdventureInfo[tempCounter][adv_TYPE])
										{
										CASE adventure_BOSS:		tmp = tmp;		break;
										CASE adventure_MAZE:		tmp = tmp;		break;
										CASE adventure_LINEAR:		tmp = tmp;		break;
										CASE adventure_RAISE:		tmp = tmp - 50;	break;
										CASE adventure_INVASION:	tmp = tmp;		break;
										CASE adventure_FLOW	:		tmp = tmp;		break;
										}



								}

	else						tmp		=	RNG(0,100);

								//Final Correction
										if 	(tmp < 1)		tmp = 1;
								else 	if 	(tmp > 100)		tmp = 100;

								AdventureInfo[tempCounter][adv_DIFFICULTY] = tmp;

	//Decide the weapons	/////////////////////////////////////////////////////////////

								AdventureInfo[tempCounter][adv_WEAPON] = SetRoundWeapon(AdventureInfo[tempCounter][adv_DIFFICULTY]);


	//Decide the Boss max health	/////////////////////////////////////////////////////////////
							if (IsCompetitive()) 				AdventureInfo[tempCounter][adv_BOSSMAXHP] = 		1250 + ServerInfo[STAGE]*180;
							else								AdventureInfo[tempCounter][adv_BOSSMAXHP] = 		RNG(1250, 1000 + AdventureInfo[tempCounter][adv_DIFFICULTY]*44);


							if (AdventureInfo[tempCounter][adv_TYPE] == adventure_FLOW) 			AdventureInfo[tempCounter][adv_MINICHECKPOINTS] = 2;

	//Decide the random event	/////////////////////////////////////////////////////////////
																																		// 		event_BOMB			1
																																		// 		event_WORM			2
							tmp = RNG(0,100);	if (tmp > 80)
																{
																tmp		=	AdventureInfo[tempCounter][adv_DIFFICULTY] - RNG(15,25);


																//Final Correction
																		if 	(tmp < 1)		tmp = 1;
																else 	if 	(tmp > 100)		tmp = 100;

																AdventureInfo[tempCounter][adv_DIFFICULTY] = tmp;


																Switch(AdventureInfo[tempCounter][adv_TYPE])
																			{
																			CASE adventure_BOSS: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	RNG(1,1);		break;
																			CASE adventure_MAZE: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	RNG(1,1);		break;
																			CASE adventure_LINEAR: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	RNG(1,1);		break;
																			CASE adventure_RAISE: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	-1;				break;
																			CASE adventure_INVASION: 	AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	-1;				break;
																			CASE adventure_FLOW: 		AdventureInfo[tempCounter][adv_RANDOMEVENT]	=	-1;				break;
																			}


																}


		}



	//Reset weapons for boss rounds if that's a shit weapon
counter = 0;
while(counter < GAMEINFO[RoundsCount])
		{
		counter++;
		if (AdventureInfo[counter][adv_TYPE] == adventure_BOSS)
			if (AdventureInfo[counter][adv_WEAPON] < id_Shotgun)		AdventureInfo[counter][adv_WEAPON] = id_Shotgun;
		}












//SET FLOW SPEED
							if (IsCompetitive()) 				RoundInfo[FlowSpeed] = 640	+ ServerInfo[STAGE]*3;
							else								RoundInfo[FlowSpeed] = 640	+ RNG(1, 25)*3;




//ITEM SPAWNING LINEUP, default spawning item is the most usual, ammo
RoundInfo[HealthSpawnerQueue]	=	1 +	10 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);
RoundInfo[MoneySpawnerQueue]	=	1 +	/*1*/5 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);
RoundInfo[WeaponSpawnerQueue]	=	1 +	20 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);
RoundInfo[AmmoSpawnerQueue]		=	1 +	3 + (FixedMul(int2fix(ServerInfo[STAGE]), 0.5) >> 16);
RoundInfo[ArmorSpawnerQueue]	=	1 +	15 + (FixedMul(int2fix(ServerInfo[STAGE]), 1.5) >> 16);

RoundInfo[CurrentRound]	= 1;


//Set music for Spectators, Stage outro, credits
AdventureInfo[None][adv_MUSIC]	= AssignMusic(MusicType(mus_CALM));
SetMusic(StrParam(s:"D_MUS", i:AdventureInfo[None][adv_MUSIC]));
Light_ChangeToValue(TIDRAM_HubMusic, 	AdventureInfo[None][adv_MUSIC]);
Light_ChangeToValue(TIDRAM_RoundMusic,	AdventureInfo[None][adv_MUSIC]);

Light_ChangeToValue(TIDRAM_Season,	ServerInfo[SEASON]);
Light_ChangeToValue(TIDRAM_Stage,	ServerInfo[STAGE]);
Light_ChangeToValue(TIDRAM_Try,		ServerInfo[TRY]);


ACS_NamedExecute("INFOLOGIC", 		0);
ACS_NamedExecute("ALPHA_GiveAmmo", 0);



if (ServerINFO[CHEATED])
	{
	SetFont("ERFONT");
	StringA = StrParam(
		s:"An admin turned cheats on! This caused the reset of all stats and\n",
		s:"achievements! This is a competitive wad and cheating will not be \n",
		s:"tolerated in any form! Blame the admin of the server.\n"
		);

	//-------------------------------------------------------------------------------------------------------------------//MIDDLE MESSAGE
	SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
	HudMessageBold(		s:StringA			;HUDMSG_FADEOUT, None, CR_RED, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/5), 7.0, 1.0);
	//-------------------------------------------------------------------------------------------------------------------//BOTTOM MESSAGE
	}


}










function void ManualStatsImport (void)
{
int i;
str String = "";
		PrintBold(s:"Preparing competitive settings. Restarting map...");


		ServerInfo[SEASON]			= StrToNum(MergedStringInfo ('#', SVDT_Season,	GetCVarString("STATS")));
		ServerInfo[STAGE]			= StrToNum(MergedStringInfo ('#', SVDT_Stage,	GetCVarString("STATS")));
		ServerInfo[TRY]				= StrToNum(MergedStringInfo ('#', SVDT_Try,		GetCVarString("STATS")));


	if (ServerInfo[STAGE]	== 0) 	ServerInfo[STAGE] 	= 1;
	if (ServerInfo[TRY]		== 0) 	ServerInfo[TRY]		= 1;

	Switch(GetPort())
		{
		CASE ZDaemon:
			SetRAM(fromCvar_WINNERS);
			SetRAM(fromCvar_LEGENDS);

			// Memo Owner
			String = MergedStringInfo ('#', SVDT_MemoOwner,	GetCVarString("STATS"));
			for (i = 0; i < MaxPortNameCharsZDA;  i++)		MemoOwner[i] = None;
			for (i = 0; i < StrLen(String); i++)			MemoOwner[i] = Crypt(Decrypt, GetChar(String, i));

			// his message
			String = MergedStringInfo ('#', SVDT_MemoOwnerMSG,	GetCVarString("STATS"));
			for (i = 0; i < MaxMemoOwnerMSGChars;  i++)		MemoOwnerMSG[i] = None;
			for (i = 0; i < StrLen(String); i++)			MemoOwnerMSG[i] = Crypt(Decrypt, GetChar(String, i));

			MemoOwner[MemoOwnerType] = StrToNum(MergedStringInfo ('#', SVDT_MemoOwnerType,	GetCVarString("STATS")));

		break;


		CASE Zandronum:

			BeginDBTransaction();

			SetDBEntry("ServerInfo", "SEASON", 	ServerInfo[SEASON]);
			SetDBEntry("ServerInfo", "STAGE", 	ServerInfo[STAGE]);
			SetDBEntry("ServerInfo", "TRY", 	1);

			EndDBTransaction();

			ServerInfo[ZANmapwin] = TRUE;	//Kick players to specs

		break;
		}
}













function void RegisterPlayer(int PlayaNum, int Add, int Flag)
{
str StringA = GetPlayerName(TRUE, PlayaNum);
int counter, MaxChars, i;
int IsMatch = -1;
Light_ChangeToValue(TIDRAM_MoneyChar, FALSE);

Switch(GetPort())
		{
		CASE ZDaemon:
		CASE GZDoom:		MaxChars = MaxPortNameCharsZDA;		break;
		CASE Zandronum:		MaxChars = MaxPortNameCharsZAN;		break;
		}

if (StrLen(GetPlayerName(TRUE, PlayaNum)))	//PLAYERS EXIST AND LOGGED IN
		{
		if (ClientExist(PlayaNum))
			{
			i = StrLen(StringA);
			while (i < MaxChars)	// Add spaces.
				{
				StringA = (StrParam(s:StringA, c:32));
				i++;
				}


							while ( counter <= ServerInfo[RegisteredPlayers])
								{
								IsMatch = -1;
								i = 0;

											while (i < MaxChars)
												{
														if (GetChar(StringA, i) < 32) 										{IsMatch = -2; 		break;}	//if there is invalid character
												else	if (GetChar(StringA, i) == MoneyNAME[counter * MaxChars + i])	{if (IsMatch < 0) IsMatch = 0;		IsMatch++;}
												i++;
												}

										if (IsMatch == -2)															{IsMatch = FALSE; 			break;}
								else	if (IsMatch  < MaxChars)	{if ( counter >= ServerInfo[RegisteredPlayers])	{IsMatch = FALSE;			break;}		else 	counter++;}
																	//if at last counter - create new acc, if not - keep going

								else	if (IsMatch >= MaxChars)													{IsMatch = TRUE;			break;}


								}





					Switch(IsMatch)
						{



						CASE TRUE: 		// NAME ALREADY EXISTS

										if (MoneyInfo[counter] + Add 														!= 		 MoneyInfo[counter])	// -
												{
													MoneyInfo[counter] += Add;
												}

								else 	if (MoneyInfo[counter] + CheckActorInventory(PLAYER_TID + PlayaNum, Money) 		> 		 MoneyInfo[counter])	// +
												{
													MoneyInfo[counter] += CheckActorInventory(PLAYER_TID + PlayaNum, Money);
													TakeActorInventory(PLAYER_TID + PlayaNum, Money, MaxByte);
												}
								if (MoneyInfo[counter] < 0)			MoneyInfo[counter] = 0;
								if (MoneyInfo[counter] > MaxMoney)
												{
												ClientScript (PlayaNum, "MSG_MaxMoney", 0, 0, 0);
												MoneyInfo[counter] = MaxMoney;
												}

								//Change Flag
								if (Flag > DOESNT_MATTER)
								//	if (MoneyInfo[counter] >= FlagCost[counter])

															{
																if (Flag < 1)
																	{
																	DrawNotification(For_ActivatorOnly, StrParam(s:"Flag reset is for free!"), 	notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  ON, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
																	FlagInfo[counter] = Flag;
																	}
																else
																	{
																	if (MoneyInfo[counter] >= FlagCost[counter])
																		{
																		DrawNotification(For_ActivatorOnly, StrParam(s:"You've paid $", i:FlagCost[counter], s:" to apply ", s:StripColors(FlagName(Flag)), s:"'s Flag."), 	notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  ON, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
																		MoneyInfo[counter] += -FlagCost[counter];
																		FlagCost[counter] = FlagCost[counter] + FlagPrice;
																		FlagInfo[counter] = Flag;
																		if (FlagCost[counter] > MaxMoney)	FlagCost[counter] = MaxMoney;
																		}

																	else 		DrawNotification(For_ActivatorOnly, StrParam(s:"Not enough money! $", i:FlagCost[counter], s:" is required"), 							notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  ON, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
																	}




															}


								//Remember Name's Account index
								CurrentName[PlayaNum + MaxPlayers] = StrParam(i:counter);


								Light_ChangeToValue(TIDRAM_Money + Playanum, MoneyInfo[counter]);
								PlayerFlag[Playanum] = FlagInfo[counter];
								Light_ChangeToValue(TIDRAM_FlagCost + Playanum, FlagCost[counter]);


						break;



						CASE FALSE:		// NAME DOESN"T EXIST, CREATING IT

						i = 0;
						while (i < MaxChars)
							{
							Light_ChangeToValue(TIDRAM_MoneyChar, GetChar(StringA, i));
							MoneyNAME[counter * MaxChars + i] = GetSectorLightLevel(TIDRAM_MoneyChar);
							i++;
							}

						ServerInfo[RegisteredPlayers]++;
						//log(s:"Money name count:  ", i:ServerInfo[MoneyNameCount]);
						Light_ChangeToValue(TIDRAM_Money	+ Playanum, 	0);
						PlayerFlag[Playanum] = 0;
						Light_ChangeToValue(TIDRAM_FlagCost + Playanum, 0);
						break;
						}


			}
		}

	else
		{
		if (PlayerInGame(Playanum))
			{
			if (CheckActorInventory(PLAYER_TID + Playanum, Money))
				{
				TakeActorInventory(PLAYER_TID + PlayaNum, Money, MaxByte);
				ClientScript (PlayaNum, "MSG_LogInAcc", 0, 0, 0);
				}
			}
		else
			{
			Light_ChangeToValue(TIDRAM_Money	+ Playanum,		0);
			PlayerFlag[Playanum] = 0;
			Light_ChangeToValue(TIDRAM_FlagCost	+ Playanum,		0);
			}
		}




}



Script "MSG_LogInAcc" (int Num) CLIENTSIDE
{
LogInNotification();
}

Script "MSG_MaxMoney" (int Num) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"You're full of Money! $", i:MaxMoney, s:" is a maximum!"), notepose_BOT, notepara_ALIGN, ICON_None, StrParam(c:ICON_Money), "f", "ERFONT",  ON, ON, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
}

function str ShowWinnerNames (int SeasonNum)
{

int i, Header;
str InitialName = "";
str Color		= "";
str Current		= "";
str Space 		= "";
str Result 		= "";
str NamePart 	= "";
str Gap 		= "";
str Char 		= "";
str Date 		= "";
int counter = 	MaxStages;

if (GetPort() == Zandronum)
	if (IsCompetitive())
		{
		SERVERINFO[MaxCharsAllStages] = 0;
		BeginDBTransaction();
		}





while(counter > 0)
	{



			if (counter < 10)	Space = " ";
			else 				Space = "";
			//-----------------------------------------------
			Header = (counter - 1)*GAMEINFO[MaxNameChars];
			//-----------------------------------------------
			i = 0; 		NamePart = "";	InitialName = "";	Gap = "   ";
			//-----------------------------------------------

			Switch(GetPort())
				{
				CASE ZDaemon:

					While(i < GAMEINFO[MaxNameChars])
						{
						if (counter == ServerInfo[STAGE])	{	Color = "\ck";	Current = ">>> ";	}
						else								{	Color = "\cj";	Current = "    ";	}
						NamePart = StrParam(s:NamePart, c:WinnerNames[Header + i]);
						i++;
						}
				break;

				CASE Zandronum:



					if (StrLen(GetDBEntryString(StrParam(s:"Season", i:SeasonNum), 			StrParam(i:1, s:"___StageWinner_DATE" 			))))
								ServerInfo[WinDates] = true;

					Switch(ServerInfo[WinDates])
						{
						Case FALSE:	Date = ""; 					break;
						Case TRUE:	Date = "%%%%%%%%%%%%%%%%";	break; //16
						}

					if (StrLen(GetDBEntryString(StrParam(s:"Season", i:SeasonNum), 			StrParam(i:counter, s:"___StageWinner_DATE" 			))))
								Date = StrParam(s:GetDBEntryString(StrParam(s:"Season", i:SeasonNum), 			StrParam(i:counter, s:"___StageWinner_DATE" 			)), s:"%%%%%%");




						//~ if first char of the winner ID is a TILDE		(Not a Logged in Winner)
					if 		(GetChar(GetDBEntryString	(StrParam(s:"Season", i:SeasonNum), 		StrParam(i:counter, s:"___StageWinner_ID")),  0 ) 	== 126)
								{
								InitialName = 	GetDBEntryString(StrParam(s:"Season", i:SeasonNum), 		StrParam(i:counter, s:"___StageWinner_ID"));
								i = 1;		Gap = " & ";
								While(i < StrLen(InitialName))
									{
									NamePart = StrParam(s:NamePart, c:GetChar(InitialName, i));
									i++;
									}
								InitialName = NamePart;		NamePart = "";
								}


						// if there is no winner of this stage yet
					else if 		(GetDBEntry			(StrParam(s:"Season", i:SeasonNum), 		StrParam(i:counter, s:"___StageWinner_ID")) 		== -1)
								InitialName = 	"------";


					else
								InitialName = 	GetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:					GetDBEntry(StrParam(s:"Season", i:SeasonNum), 		StrParam(i:counter, s:"___StageWinner_ID"))					, s:"___CURRENTNAME"));

					InitialName = StripColors(InitialName);

					//Replacing SPACES to fake spaces, because the engine fucks up the SPACE(32) char lettering
					i = 0;
					While(i < StrLen(InitialName))
						{
						if (GetChar(InitialName,  i ) == 32)	//Space
								Char = 37; //%, because players cant have % in their names
						else	{
								Char = GetChar(InitialName,  i );
								}
						NamePart = StrParam(s:NamePart, c:Char);
						i++;
						}





					//Setting up the max chars
					i = StrLen(NamePart);

					if (SERVERINFO[MaxCharsAllStages] < i) 	SERVERINFO[MaxCharsAllStages] = i;

				break;
				}

			Result = StrParam(s:Result, s:Color, s:Current, s:Date, s:"STAGE ", s:Space, i:counter, s:".", s:Gap, s:NamePart, s:"\n");



	counter--;

	}









if (GetPort() == Zandronum)
	if (IsCompetitive())
		{
		SetCvarString("ER_Scoreboard", Result);
		EndDBTransaction();
		}







return Result;
}










function void RenderLegends (void)
{
int counter, Source, Iteration, MonumentHeight, LocalStart, StartFrom;
str LegendName = "";
/*
if (GetPort() == Zandronum)
{
LegendNames[0] = 90;
LegendNames[1] = 69;
LegendNames[2] = 66;
LegendNames[3] = 69;
LegendNames[4] = 82;
LegendNames[5] = 80;
LegendNames[6] = 65;
LegendNames[7] = 76;
LegendNames[8] = 32;
LegendNames[9] = 32;
LegendNames[10] = 32;
LegendNames[11] = 32;

LegendNames[12] = 76;
LegendNames[13] = 79;
LegendNames[14] = 79;
LegendNames[15] = 80;
LegendNames[16] = 69;
LegendNames[17] = 82;
LegendNames[18] = 32;
LegendNames[19] = 32;
LegendNames[20] = 32;
LegendNames[21] = 32;
LegendNames[22] = 32;
LegendNames[23] = 32;

LegendNames[24] = 91;
LegendNames[25] = 77;
LegendNames[26] = 65;
LegendNames[27] = 82;
LegendNames[28] = 73;
LegendNames[29] = 78;
LegendNames[30] = 69;
LegendNames[31] = 71;
LegendNames[32] = 85;
LegendNames[33] = 89;
LegendNames[34] = 93;
LegendNames[35] = 32;
}
*/

Switch(GetPort()) //ZDA and ZAN seems to render scale from TEXTURES ina a different way.
	{
	CASE ZDaemon:	Source = LINETAG_ZDaemonLegends;	break;
	CASE Zandronum:	Source = LINETAG_ZDaemonLegends;/*LINETAG_ZandronumLegends;*/	break;
	}



While(Iteration < MaxLegends)
	{

	LegendName = "";
	MonumentHeight = 0;
	counter = 0;

Switch(GetPort()) //ZDA and ZAN seems to render scale from TEXTURES ina a different way.
	{
	CASE ZDaemon:	LocalStart = Iteration*(GAMEINFO[MaxNameChars]); 	break;
	CASE Zandronum:	LocalStart = Iteration*(GAMEINFO[MaxNameChars]);	break;
	}





	while(counter < GAMEINFO[MaxNameChars])
		{
		LegendName = StrParam(s:LegendName, c:LegendNames[LocalStart + Counter]);
		counter++;
		}

	LegendName = StringNoEdgeSpaces(LegendName);




			counter = 0;
			//Calculating MonumentHeight
			MonumentHeight = StrLen(LegendName);
			//Start Letter Placement at
			StartFrom = GAMEINFO[MaxNameChars] - MonumentHeight;




			//Now place the letters
					counter = 0;
					while(counter < MonumentHeight)
						{
												SetLineTexture(Source + LocalStart + StartFrom + counter, 											SIDE_FRONT,TEXTURE_MIDDLE, StrParam(s:"LETTR", i:LegendNames[LocalStart + counter]));
												SetLineTexture(Source + LocalStart + StartFrom + counter + (MaxLegends*GAMEINFO[MaxNameChars]), 	SIDE_FRONT,TEXTURE_MIDDLE, "LETTNULL");
												SetLineTexture(Source + LocalStart + StartFrom + counter + (MaxLegends*GAMEINFO[MaxNameChars]), 	SIDE_BACK, TEXTURE_MIDDLE, "LETTNULL");

						counter++;
						}

	iteration++;
	}


}










/*

  ______   ______     ______   .______             __        ______     _______  __    ______
 /      | /  __  \   /  __  \  |   _  \           |  |      /  __  \   /  _____||  |  /      |
|  ,----'|  |  |  | |  |  |  | |  |_)  |          |  |     |  |  |  | |  |  __  |  | |  ,----'
|  |     |  |  |  | |  |  |  | |   ___/           |  |     |  |  |  | |  | |_ | |  | |  |
|  `----.|  `--'  | |  `--'  | |  |               |  `----.|  `--'  | |  |__| | |  | |  `----.
 \______| \______/   \______/  | _|               |_______| \______/   \______| |__|  \______|


*/






function str LeadingZeros (int Value, int ZeroesCount)
{
    int i;
    str result = StrParam(d:Value);
    int len = StrLen(result);
    for (i=len; i<ZeroesCount; i++)
        result = StrParam(s:"0", s:result);
    return result;
}




function str ZDA_LogSeasonStage (void)
{
str Result;
if(IsCompetitive()) Result = StrParam(s:"set SEASON ", s:LeadingZeros(ServerInfo[SEASON], 3), s:";", s:"set STAGE ", s:LeadingZeros(ServerInfo[STAGE], 2), s:";");
else Result = "";
return Result;
}

function str ZDA_LogWinners (void)
{
int counter;
bool TrueCharDetected;
str Result = "";
if(IsCompetitive())
	{

	while(counter < GAMEINFO[MaxNameChars]*MaxStages)
		{
		//Result = StrParam(s:Result, c:Crypt(Encrypt, WinnerNames[counter]));
		Result = StrParam(s:Result, c:WinnerNames[counter]);
		if (WinnerNames[counter] != '-')	TrueCharDetected = TRUE;
		counter++;
		}

	if (TrueCharDetected)		Result = StrParam(s:"#", s:Result);
	else						Result = "";
	}



else Result = "";
return Result;
}

function str ZDA_LogLegends (void)
{
int counter;
bool TrueCharDetected;
str Result = "";
if(IsCompetitive())
	{

		while(counter < GAMEINFO[MaxNameChars]*MaxLegends)
		{
		//Result = StrParam(s:Result, c:Crypt(Encrypt, LegendNames[counter]));
		Result = StrParam(s:Result, c:LegendNames[counter]);
		if (LegendNames[counter] != ' ')	TrueCharDetected = TRUE;
		counter++;
		}

	if (TrueCharDetected)		Result = StrParam(s:"#", s:Result);
	else						Result = "";
	}
else Result = "";
return Result;
}


function str ZDA_LogMemoOwner (void)
{
int counter;
str Result = "";
bool TrueCharDetected;

		while(counter < MaxPortNameCharsZDA)
		{
		//Result = StrParam(s:Result, c:Crypt(Encrypt, LegendNames[counter]));
		if (MemoOwner[counter] == ' ')		break;
		Result = StrParam(s:Result, c:Crypt(Encrypt, MemoOwner[counter]));
		TrueCharDetected = TRUE;
		counter++;
		}

	if (TrueCharDetected)		Result = StrParam(s:"#", i:MemoOwner[MemoOwnerType], s:"#", s:Result);
	else						Result = "";

return Result;
}


function str ZDA_LogMemoOwnerMSG (void)
{
int counter;
str Result = "";
bool TrueCharDetected;

		if (MemoOwnerMSG[0]) // if message exists
		while(counter < MaxMemoOwnerMSGChars)
			{
			//Result = StrParam(s:Result, c:Crypt(Encrypt, LegendNames[counter]));
			TrueCharDetected = TRUE;

			//if (!MemoOwnerMSG[counter])		Result = StrParam(s:Result, c:' ');
			//else								Result = StrParam(s:Result, c:MemoOwnerMSG[counter]);
			Result = StrParam(s:Result, c:Crypt(Encrypt, MemoOwnerMSG[counter]));

			counter++;
			}

	if (TrueCharDetected)		Result = StrParam(s:"#", s:Result);
	else						Result = "";

return Result;
}




function void ZDA_StatsInfo (void)
{
log(s:"------------------------------------\n------------------------------------\n---  STATS COMMAND FOR AN ADMIN  ---\n-just copy/paste it in RCON command line-\n-to restore player progress after reboot---\n------------------------------------\n------------------------------------");
//log(											s:"rcon set STATS ", s:"\"", s:"#", i:ServerInfo[SEASON], s:"#", i:ServerInfo[STAGE], s:"#", i:ServerInfo[TRY], s:ZDA_LogWinners(), s:ZDA_LogLegends(), s:"\"");
log(s:"------------------------------------\n", s:"rcon set STATS ", s:"\"", s:"#", i:ServerInfo[SEASON], s:"#", i:ServerInfo[STAGE], s:"#", i:ServerInfo[TRY], s:ZDA_LogWinners(), s:ZDA_LogLegends(), s:ZDA_LogMemoOwner(), s:ZDA_LogMemoOwnerMSG(), s:"\"");
log(s:"\n--then, type PUKENAME LOAD----------\n------------------------------------");
}



function str FrameString (void)
{
str Result = "aggggggggb\neiiiiiiiif\nchhhhhhhhd";
return Result;
}







Script "INFOLOGIC" (void)
{
int counter, EverySecond, EveryHalfSecond, IconCounter, BossMaxHealth, BossHealth, i;
int EveryFifteen = 15;
str TimeIconChar = "",
	TimeLetter = "",
	AdventureIcon = "",
	EnemyPrint = "",
	CurrRoundChar = "",
	CurrRoundStr = "",
	StringA = "",
	StringB = "";

bool PrintHUD_TOP, PrintHUD_MID;

//A Zdaemon message to restore progress via console upon server restart, yeah clunky as f, but what can u do with an oldass port
if (IsCompetitive())	if(GetPort() == ZDaemon)	ZDA_StatsInfo();



//Map loaded, waiting for someone to enter the game.
While(PlayerStatus(DOESNT_MATTER) <= ps_DEAD)	delay(1);

//delay(1);
SetPlayerProperty(1, false, PROP_TOTALLYFROZEN);
Set_AllGodmode(false);
//A player joined

if (IsCompetitive())	if   (GetPort() == ZDaemon)			ShowScoreboard (ZDaemon);
ACS_NamedExecute("GAMELOGIC", 0);


While(PlayerStatus(DOESNT_MATTER) > ps_DEAD)
	{




	if(EveryHalfSecond > 0) EveryHalfSecond--;
	else

// This here will happen every half a sec
		{



			if(GAMESTATE > gs_IDLE)
				{
						/*
						//Spawn Weapons
						counter = id_minWEAPON + 1; // + Pistol
						while (counter <= AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON])
							{
							//if (!IsTIDUsed(ACTORTID_StartWeaponTID + counter))
							if (!(ClassifyActor(ACTORTID_StartWeaponTID + counter) & ACTOR_ALIVE))
							SpawnSpotForced(ActorString(counter, as_CODE), ACTORTID_StartWeaponSPOT + counter, ACTORTID_StartWeaponTID + counter, 0);
							counter++;
							}
						*/

						//Print Scores
						if ((RoundInfo[CurrentRound] == GAMEINFO[RoundsCount]) && GAMESTATE == gs_END)	{}
						else SortPlayerScores(SPS_AlsoPrint);

						Switch(GAMESTATE)
						{
						CASE gs_IDLE:
						PrintHUD_TOP = false;	PrintHUD_MID = false;
						break;



						CASE gs_LOADING:
						PrintHUD_TOP = true;	PrintHUD_MID = true;
						CurrRoundChar = StrParam(c:ICON_Round);
						CurrRoundStr = StrParam(i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount]);
						TimeIconChar = StrParam(c:ICON_HEADER_Load + IconCounter);
						if (LoadBit >= RoundInfo[LoadSegments]) 	TimeLetter = "100%";
						else										TimeLetter = StrParam(i:((FixedDiv(Int2Fix(LoadBit), Int2Fix(RoundInfo[LoadSegments]))* 100) >> 16), s:"%");

						if (IconCounter < 3) IconCounter++;
						else IconCounter = 0;

						break;



						CASE gs_ACTIVE:
						CurrRoundChar = StrParam(c:ICON_Round);
						CurrRoundStr = StrParam(i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount]);
						if 	((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_RAISE)	&& (RoundInfo[PlaygroundReached]) && ((!RoundInfo[CheckpointReached]) && (RoundInfo[CurrSubstanceHeight] < RoundInfo[MaxSubstanceHeight])))
								{
								TimeIconChar = 	StrParam(c:ICON_Substance);
								TimeLetter	 = 	StrParam(i:((FixedDiv(Int2Fix(RoundInfo[CurrSubstanceHeight]), Int2Fix(RoundInfo[MaxSubstanceHeight]))* 100) >> 16), s:"%");
								}
						else	{
								TimeIconChar = 	StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(TimeLeft), Int2Fix(RoundInfo[TimeGiven]))* 100) >> 16)/10);
								TimeLetter	 = 	StrParam(s:TimeColor(TimeLeft), s:PrintClock(TimeLeft));
								}

							if(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS)
									{
										AdventureIcon = StrParam(c:ICON_Boss);
										EnemyPrint = StrParam(i:((FixedDiv(Int2Fix(GetActorProperty(ACTORTID_Boss, APROP_Health)), Int2Fix(AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]))* 100) >> 16), s:"%");
										if (((FixedDiv(Int2Fix(GetActorProperty(ACTORTID_Boss, APROP_Health)), Int2Fix(AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]))* 100) >> 16)	< 0)	EnemyPrint = "0%";
									}
							else
									{
									AdventureIcon = StrParam(c:ICON_EnemyCount);
									EnemyPrint = StrParam(i:GetSectorLightLevel(TIDRAM_EnemyCount));//StrParam(i:ThingCount(0, ACTORTID_Enemy));
									}

						break;

						CASE gs_END:

							if ((RoundInfo[CurrentRound] == GAMEINFO[RoundsCount]) && GAMESTATE == gs_END)	//STAGE WIN
									{
									if (GAMEINFO[InputNameTime] > 0)	//if player in the input room
										{
										PrintHUD_TOP = true;	PrintHUD_MID = true;
										CurrRoundChar = StrParam(c:ICON_Exit);
										CurrRoundStr = StrParam(s:"INPUT");
										TimeIconChar = StrParam(c:ICON_None);
										TimeLetter = StrParam(s:PrintClock(GAMEINFO[InputNameTime]));
										}

									else
										{
										CurrRoundStr = StrParam(i:RoundInfo[CurrentRound], s:"/", i:GAMEINFO[RoundsCount]);
										PrintHUD_TOP = false;	PrintHUD_MID = false;
										}
									}

							else
									{
									PrintHUD_TOP = true;	PrintHUD_MID = true;
									TimeIconChar = StrParam(c:ICON_Exit);
									if (AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByENEMYONLY)
																																	{
																																	TimeIconChar = StrParam(c:ICON_None);
																																	TimeLetter = StrParam(s:"");
																																	}

									else
																																	{
																																	TimeIconChar = StrParam(c:ICON_Exit);
																																	TimeLetter = StrParam(s:TimeColor(TimeLeft), s:PrintClock(TimeLeft));
																																	}
									}
						break;
						}



								SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);

								/////////////////////////////////////TOP
							if (PrintHUD_TOP == true)
								{
								SetFont("ERICON");
								HudMessageBold(s:CurrRoundChar;	HUDMSG_FADEOUT, 				HUDid_TOP_ICON, COLORTEXT_MAIN, int2fix(X_TOP_ICON), int2fix(Y_TOP_ICON), 1.0, 1.0);
								SetFont("ERFONT");
								HudMessageBold(s:CurrRoundStr;	HUDMSG_FADEOUT, 				HUDid_TOP_LETTER, COLORTEXT_MAIN, int2fix(X_TOP_LETTER), int2fix(Y_TOP_LETTER), 1.0, 1.0);
								SetFont("ERICON");
								HudMessageBold(s:FrameString();	HUDMSG_FADEOUT|HUDMSG_ALPHA, 	HUDid_TOP_BACK, COLORTEXT_MAIN, int2fix(X_TOP_BACK), int2fix(Y_TOP_BACK), 1.0, 1.0, 0.5);
								}
								/////////////////////////////////////MIDDLE
							if (PrintHUD_MID == true)
								{
								SetFont("ERICON");
								HudMessageBold(s:TimeIconChar;	HUDMSG_FADEOUT, 				0, COLORTEXT_MAIN, int2fix(X_MIDDLE_ICON), int2fix(Y_MIDDLE_ICON), 1.0, 1.0);
								SetFont("ERFONT");
								HudMessageBold( s:TimeLetter;	HUDMSG_FADEOUT, 				HUDid_MIDDLE_LETTER, COLORTEXT_MAIN, int2fix(X_MIDDLE_LETTER), int2fix(Y_MIDDLE_LETTER), 1.0, 1.0);
								SetFont("ERICON");
								HudMessageBold(s:FrameString();	HUDMSG_FADEOUT|HUDMSG_ALPHA, 	HUDid_MIDDLE_BACK, COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK), int2fix(Y_MIDDLE_BACK), 1.0, 1.0, 0.5);
								}
								if (GAMESTATE == gs_ACTIVE)
								{
								/////////////////////////////////////BOTTOM
								SetFont("ERICON");
								HudMessageBold(s:AdventureIcon;	HUDMSG_FADEOUT, 				HUDid_BOTTOM_ICON, COLORTEXT_MAIN, int2fix(X_BOTTOM_ICON), int2fix(Y_BOTTOM_ICON), 1.0, 1.0);
								SetFont("ERFONT");
								HudMessageBold(s:EnemyPrint ;	HUDMSG_FADEOUT, 				HUDid_BOTTOM_LETTER, COLORTEXT_MAIN, int2fix(X_BOTTOM_LETTER), int2fix(Y_BOTTOM_LETTER), 1.0, 1.0);
								SetFont("ERICON");
								HudMessageBold(s:FrameString();	HUDMSG_FADEOUT|HUDMSG_ALPHA,	HUDid_BOTTOM_BACK , COLORTEXT_MAIN, int2fix(X_BOTTOM_BACK), int2fix(Y_BOTTOM_BACK), 1.0, 1.0, 0.5);
								}





					if ((GAMESTATE > gs_LOADING)	&& (GetPort() == ZDaemon))		ZDA_Dmg2PlayerScore();

				}



		EveryHalfSecond = Sec/2;
		}




	if(EverySecond > 0) EverySecond--;
	else

// This here will happen every sec
		{

		if (GetPort() == Zandronum)
			if(IsNetworkGame())
				if (EveryFifteen > 0) EveryFifteen--;
				else
					{
					StorePlayerinfo();
					EveryFifteen = DataStoreInterval;
					}



		if (GAMEINFO[InputNameTime] > BottomLine) GAMEINFO[InputNameTime]--;


		if(GAMESTATE > gs_LOADING)
			{
//////////////////////////////////////////////////////////////////////// DEMO VERSION
		if (GAMEINFO[DemoVersion] > 0)
				{
				if (GAMEINFO[DemoVersion] < DemoTime)
					{
					DrawNotification(For_Everyone, StrParam(s:"DEMO WILL END IN... ", s:PrintClock(GAMEINFO[DemoVersion] - 1), s:"    Play online for full experience!"), notepose_SPECIAL, 	notepara_ALIGN, ICON_Clock, StrParam(c:ICON_Clock), "j", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);
					}
				if (GAMEINFO[DemoVersion] == 1)
							{
							SetPlayerProperty(1, true, PROP_TOTALLYFROZEN);		Set_AllGodmode(true);

							ScreenFade (For_Everyone, 1.0, CR_BLACK, 2.0, 999.0, 0);
							Switch(GetPort())
								{
								CASE ZDaemon: Exit_Normal(0);	break;
								CASE Zandronum:	if (IsNetworkGame())	ConsoleCommand("Map TITLEMAP");	break;
								}
							AmbientSound("SFXBOSSS", 127);
							SetMusic("D_NONE");
							Light_ChangeToValue(TIDRAM_Intro, TRUE);
							delay(sec*2);
							for(i = 0; i < MaxPlayers; i++)		TeleportOther(PLAYER_TID + i, ACTORTID_DemoEnd + i, FALSE);
							while(true)	{DemoMessage(0); delay(SEC);}
							}
				GAMEINFO[DemoVersion]--;
				}
/////////////////////////////////////////////////////////////////////////////////
				if(TimeLeft > BottomLine)
					{


						Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
						{
						CASE adventure_BOSS:
						CASE adventure_MAZE:
						CASE adventure_LINEAR:

						if (RoundInfo[adventureCounter] > -1)
								{
								if (RoundInfo[adventureCounter] == 0)
									{
									SetWarmupBlockLines(FALSE);
									if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS)		NoiseAlert(PLAYER_TID + BestScorePLAYANUM[0], ACTORTID_Boss);
									}
								RoundInfo[adventureCounter]--;
								}
						break;

						CASE adventure_INVASION:

						if (RoundInfo[adventureCounter] > -1)
							{

							StringA = "WATCH OUT! AN INVASION IS EXPECTED IN...";
							DrawNotification(For_Everyone, StrParam(s:StringA, i:RoundInfo[adventureCounter]), notepose_TOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(RoundInfo[adventureCounter]), Int2Fix(InvasionStartTime))* 100) >> 16)/10), "j", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);

						if (RoundInfo[adventureCounter] == 0)
								{
									SetLineTexture(LINETAG_PlaygroundPerimeter, 	SIDE_FRONT, TEXTURE_MIDDLE, "-");
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, None, BLOCKF_SIGHT);
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, None, BLOCKF_EVERYTHING);
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, BLOCKF_PLAYERS, 	None);
									Line_SetBlocking(LINETAG_PlaygroundPerimeter, None, BLOCKF_MONSTERS);
									//SetWarmupBlockLines(FALSE);
								}
							RoundInfo[adventureCounter]--;
							}
						break;



						CASE adventure_FLOW:

						if (RoundInfo[adventureCounter] > 1)
							{


							RoundInfo[adventureCounter]--;
							StringB = "";
							Switch(RoundInfo[MiniCheckpoint])
								{
								CASE 0:	StringB = "FOR THE FIRST TIME ";	break;
								CASE 1:	StringB = "FOR THE LAST TIME ";		break;
								}
							StringA = StrParam(s:"AREA WILL BE FLOODED ", s:StringB, s: "IN...");
							DrawNotification(For_Everyone, StrParam(s:StringA, i:RoundInfo[adventureCounter] - 1, s:"!"), notepose_TOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(RoundInfo[adventureCounter]), Int2Fix(FlowInverseTime))* 100) >> 16)/10), "j", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);
							}


						break;
						}






							Switch(GAMESTATE)
							{


								CASE gs_END:

									if ((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS) || (RoundInfo[CurrentRound] >= GAMEINFO[RoundsCount]))	TimeLeft++;
									if (PlayerStatus(-1) == ps_HUB)	TimeLeft = BottomLine; // if everyone returned to hub no need to wait
									if (TimeLeft > PanicTime) TimeLeft = PanicTime;

								break;
							}



					if(!GetSectorLightLevel(TIDRAM_HoldTime))
						{
						if(GetSectorLightLevel(TIDRAM_JoinTimeLeft) > 0)		Light_ChangeToValue(TIDRAM_JoinTimeLeft, GetSectorLightLevel(TIDRAM_JoinTimeLeft) -1);
						TimeLeft--;
						if (RoundInfo[PlaygroundReached]) GAMEINFO[MapTime]++;
						}



					}




			}


		EverySecond = Sec;
		}

	if (GetPort() == ZDaemon)	if (ZD_GetGameInfo(ZD_GAMEINFO_SURVIVALRESET))	break;


	delay(1);
	}


// MISSION FAILED


SetMusic("D_NONE");
AmbientSound("SFXFAIL", 127);



// RESET MAP
/*if (GAMEINFO[MapTime] > PanicTime)*/
if (GAMEINFO[NextTry])	ServerInfo[TRY]++;


MinigameWinnerIs();




//if  ((StrLen(GetCurrentGameMode()) == 8) && (GetChar(GetCurrentGameMode(), 1) == 85))		{	StringA = "SMALLFONT";	StringB = "g";	}
if  (GetPort() >= Zandronum)				StringB = "g";
else										StringB = "j";

if (GAMEINFO[MinigameWinPlayaPTS] > 0)
if (GAMEINFO[MinigameWinPlayaNUM] > 0)
DrawNotification(For_Everyone, StrParam(s:"Minigame Winner is ", n:GAMEINFO[MinigameWinPlayaNUM] + 1, s:" (", i:GAMEINFO[MinigameWinPlayaPTS], s:" PTS)"), 				notepose_SPECIAL, 	notepara_CENTER, ICON_None, StrParam(c:ICON_None), 	StringB, "SMALLFONT",  ON, ON, noteFadeIn_None, noteHold_Failed, noteFadeOut_Failed);
DrawNotification(For_Everyone, StrParam(s:"PLAY TIME"), 																												notepose_MID, 		notepara_CENTER, ICON_None, StrParam(c:ICON_None), 	StringB, "SMALLFONT",  ON, ON, noteFadeIn_None, noteHold_Failed, noteFadeOut_Failed);

DrawNotification(For_Everyone, StrParam(s:PrintClock(GAMEINFO[MapTime])),																								notepose_BOT, 		notepara_CENTER, ICON_None, StrParam(c:ICON_None), 	StringB, "BIGFONT",  	ON, ON, noteFadeIn_None, noteHold_Failed, noteFadeOut_Failed);


if (IsCompetitive())	if   (GetPort() == Zandronum)			ShowScoreboard (Zandronum);




SetCvar("ER_SERVERGreetPlayerNumber", -1);
SetCvar("ER_SERVERGreetString", "");
Light_ChangeToValue(TIDRAM_MapReset, TRUE);


	Switch(GetPort())
		{
		CASE ZDaemon: 		i = SEC*5;	break;//i = SEC*4 - 5;	break;
		CASE Zandronum:
		CASE GZDoom: 		i = SEC*5;		break;
		}

delay(i);

MapReset();

terminate;



}



function void ShowScoreboard (int Port)
{
int counter, i, x;
			Switch(GetPort())
				{
				CASE ZDaemon: 		i = CR_GOLD;	break;
				CASE Zandronum: 	i = CR_GREY;	break;
				}
			SetFont("ERFONTSW");
			SetHUDSize(HUDX_LARGE,		HUDY_LARGE,	FALSE);
			Switch(Port)
				{
				CASE ZDaemon: 	X = HUDX_LARGE/2 +	HUDX_LARGE/3;		break;
				CASE Zandronum: X = HUDX_LARGE/2;						break;
				}

			HudMessageBold	(s:"SEASON ", i:ServerInfo[SEASON], s:" WINNERS";		HUDMSG_FADEINOUT, HUDid_AddPurchase, i, 		int2fix(X), 					int2fix(HUDY_LARGE/2 - HUDY_LARGE/48),						MissionFailed_Hold, MissionFailed_FadeIn, MissionFailed_FadeOut);
			SetHUDSize(HUDX_MEDIUM,		HUDY_MEDIUM,	FALSE);
			Switch(Port)
				{
				CASE ZDaemon: 	X = HUDX_MEDIUM/2 +	HUDX_MEDIUM/3;		break;
				CASE Zandronum: X = HUDX_MEDIUM/2;						break;
				}
			HudMessageBold	(s:ShowWinnerNames(ServerInfo[SEASON]);					HUDMSG_FADEINOUT, HUDid_AddMessage, CR_WHITE,	int2fix(X), 					int2fix(HUDY_MEDIUM/2 - HUDY_MEDIUM/48 + HUDY_MEDIUM/4),	MissionFailed_Hold, MissionFailed_FadeIn, MissionFailed_FadeOut);

			ScoreboardBackground(Port);


			//DECIDING A FLAG!
			if (GetPort() == Zandronum)		//for zandronum only show when mission failed
				{
				BeginDBTransaction();

					SetDBEntry("ServerInfo", "TRY", ServerInfo[TRY]);

					SetHUDSize(HUDX_TINY*2, HUDY_TINY*2, 0);
					counter = 	MaxStages;	int 	ddd = 0;
					while(counter > 0)
						{

						//Check if the stage winner exists (not -1)
						if 			(GetDBEntry					(StrParam(s:"Season", i:ServerInfo[SEASON]), 		StrParam(i:counter, s:"___StageWinner_ID")) 	== -1)			i = 999;	//Then a Blank Flag
						else	if	(GetChar(GetDBEntryString	(StrParam(s:"Season", i:ServerInfo[SEASON]), 		StrParam(i:counter, s:"___StageWinner_ID")), 0) == 126)  		i = 998;		//Then United Nations
						else
							{
									i = 0;
									while (i <= AllFlags)
										{
										if (!StrCmp(GetDBEntryString("PlayerInfo", StrParam(s:"id_", i:				GetDBEntry	(StrParam(s:"Season", i:ServerInfo[SEASON]), 		StrParam(i:counter, s:"___StageWinner_ID"))								, s:"___FLAG")),		 StripColors(FlagName(i))))		break;		//remember the 'i'

										i++;
										}
										if (i > AllFlags)	i = 999;

							}



						SetCvar(StrParam(s:"ER_SFLAG", i:counter), i);

						SetFont(StrParam(s:"FLAG", i:i));
						HudMessageBold(s:"A";		HUDMSG_FADEINOUT|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, int2fix(HUDX_TINY + 64*14 - SERVERINFO[MaxCharsAllStages]*64/2 - (64 + 8)), 		int2fix(HUDY_TINY - HUDY_TINY/24 + HUDY_TINY/2) - int2fix((MaxStages/2)*64) + int2fix(ddd*64) , 			MissionFailed_Hold, MissionFailed_FadeIn, MissionFailed_FadeOut, FlagAlpha(i));
						ddd++;
						counter--;
						}

				EndDBTransaction();
				}


}






function void ScoreboardBackground (int Port)
	{
	int counter, x, y, i, t;
	str String = "";
	int Width = (12 + ServerInfo[WinDates]*16 + SERVERINFO[MaxCharsAllStages])/3;
	int Height = 8;
	SetHUDSize(HUDX_VERYBIG, HUDY_VERYBIG, 0);
	SetFont("ERICON");

	if (GetPort() == ZDaemon)	Width = Width*2;

	while(y < Height)
		{
			while(x < Width)
				{
				String = StrParam(s:String, c:ICON_BlackScreen);
				x++;
				}

			String = StrParam(s:String, s:"\n");
			y++; x = 0;
		}

			Switch(Port)
				{
				CASE ZDaemon: 	i = HUDX_VERYBIG/2 +	HUDX_VERYBIG/3;	t = CR_DARKGREY;	break;
				CASE Zandronum: i = HUDX_VERYBIG/2;						t = CR_BLACK;		break;
				}

			HudMessageBold	(s:String; HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_AddBackground, t,	int2fix(i), 					int2fix(HUDY_VERYBIG/2 + HUDY_VERYBIG/4 - 5), MissionFailed_Hold, 		noteFadeIn_Standart, noteFadeOut_Standart, AdvertAlpha);

	}




Script "ER_Scoreboard" (void) NET
{
int counter, counterB, A;

if (!ServerInfo[SEASON])
	{
	DrawNotification(For_ActivatorOnly, StrParam(s:"There is no season going on at the moment!"), 	notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_None),			"g", "ERFONT",  OFF, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
	Terminate;
	}

	SetFont("ERFONTSW");
	SetHUDSize(HUDX_LARGE,		HUDY_LARGE,	FALSE);
	HudMessage(s:"SEASON ", i:ServerInfo[SEASON], s:" WINNERS";			HUDMSG_FADEINOUT, HUDid_AddPurchase,	CR_WHITE, 	int2fix(HUDX_LARGE/2), 	int2fix(HUDY_LARGE/2 - HUDY_LARGE/48),			noteHold_Long, noteFadeIn_Standart, noteFadeOut_Standart);
	SetHUDSize(HUDX_MEDIUM,		HUDY_MEDIUM,	FALSE);
	HudMessage(s:GetCVarString("ER_Scoreboard");						HUDMSG_FADEINOUT, HUDid_AddMessage,		CR_WHITE,	int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 - HUDY_MEDIUM/48 + HUDY_MEDIUM/4),	noteHold_Long, noteFadeIn_Standart, noteFadeOut_Standart);


	SetHUDSize(HUDX_TINY*2, HUDY_TINY*2, 0);
	counter = 	MaxStages;	CounterB = 0;
	while(counter > 0)
		{



		SetFont(StrParam(s:"FLAG", i:GetCvar(StrParam(s:"ER_SFLAG", i:counter))));
//		HudMessage(s:"A";		HUDMSG_FADEINOUT|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, int2fix(HUDX_TINY + 64*6 - SERVERINFO[MaxCharsAllStages]*64/2 - (64 + 8)), 		int2fix(HUDY_TINY - HUDY_TINY/24 + HUDY_TINY/2) - int2fix((MaxStages/2)*64) + int2fix(counterB*64) , 			3.0, 1.0, 1.0, FlagAlpha(GetCvar(StrParam(s:"ER_SFLAG", i:counter))));
		HudMessage(s:"A";		HUDMSG_FADEINOUT|HUDMSG_ALPHA, 0, CR_UNTRANSLATED, int2fix(HUDX_TINY + 64*14 - SERVERINFO[MaxCharsAllStages]*64/2 - (64 + 8)), 		int2fix(HUDY_TINY - HUDY_TINY/24 + HUDY_TINY/2) - int2fix((MaxStages/2)*64) + int2fix(counterB*64) , 			noteHold_Long, noteFadeIn_Standart, noteFadeOut_Standart, FlagAlpha(GetCvar(StrParam(s:"ER_SFLAG", i:counter))));

		CounterB++;
		counter--;
		}

	int x, y;
	str String = "";
	int Width = (12 + ServerInfo[WinDates]*16 + SERVERINFO[MaxCharsAllStages])/3;
	int Height = 8;
	SetHUDSize(HUDX_VERYBIG, HUDY_VERYBIG, 0);
	SetFont("ERICON");
	while(y < Height)
		{
			while(x < Width)
				{
				String = StrParam(s:String, c:ICON_BlackScreen);
				x++;
				}

			String = StrParam(s:String, s:"\n");
			y++; x = 0;
		}


	HudMessage(s:String; HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_AddBackground, CR_BLACK, int2fix(HUDX_VERYBIG/2), int2fix(HUDY_VERYBIG/2 + HUDY_VERYBIG/4 - 5), noteHold_Long, noteFadeIn_Standart, noteFadeOut_Standart, AdvertAlpha);



		A = 0;
		while (A < StrLen(GetCVarString("ER_Scoreboard")))
			{
				if (GetChar(GetCVarString("ER_Scoreboard"), A) == 38)
					{
						SetHUDSize(HUDX_MEDIUM,		HUDY_MEDIUM,	FALSE);		SetFont("ERFONT");
						HudMessage(	s:"Winners marked 'X' were not logged in their account upon their\n",
									s:"victory and thus their win won't be calculated when the game \n",
									s:"will decide a season winner.  Please, log in next time!";
									HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_RED,	int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 - HUDY_MEDIUM/3 - HUDY_MEDIUM/8),	noteHold_Long, noteFadeIn_Standart, noteFadeOut_Standart);
						break;
					}
				A++;
			}


}





function int GetWinnerScore (int PlayerNum)
{
int result = RNG(1, 10000);
return Result;
}














Script "MSG_LateToJoin" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"TOO LATE TO CONTINUE!"), 		notepose_BOT, notepara_ALIGN, ICON_Sad, StrParam(c:ICON_Sad), "g", "ERFONT",  OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
}




SCRIPT "ChangeMusic" (int Num) CLIENTSIDE
{
LocalSetMusic(StrParam(s:"D_MUS", i:Num));
}




function int BlockAt_to_BC (int Row, int Cmn)
{
int Result;
Switch (Row)
	{
	CASE 0:	Switch(Cmn)		{	CASE 0:Result =  1;break;CASE 1:Result =  2;break;CASE 2:Result =  3;break;CASE 3:Result =  4;break;CASE 4:Result =  5;break;CASE 5:Result =  6;break;CASE 6:Result =  7;break;	}	break;
	CASE 1:	Switch(Cmn)		{	CASE 0:Result =  8;break;CASE 1:Result =  9;break;CASE 2:Result = 10;break;CASE 3:Result = 11;break;CASE 4:Result = 12;break;CASE 5:Result = 13;break;CASE 6:Result = 14;break;	}	break;
	CASE 2:	Switch(Cmn)		{	CASE 0:Result = 15;break;CASE 1:Result = 16;break;CASE 2:Result = 17;break;CASE 3:Result = 18;break;CASE 4:Result = 19;break;CASE 5:Result = 20;break;CASE 6:Result = 21;break;	}	break;
	CASE 3:	Switch(Cmn)		{	CASE 0:Result = 22;break;CASE 1:Result = 23;break;CASE 2:Result = 24;break;CASE 3:Result = 25;break;CASE 4:Result = 26;break;CASE 5:Result = 27;break;CASE 6:Result = 28;break;	}	break;
	CASE 4:	Switch(Cmn)		{	CASE 0:Result = 29;break;CASE 1:Result = 30;break;CASE 2:Result = 31;break;CASE 3:Result = 32;break;CASE 4:Result = 33;break;CASE 5:Result = 34;break;CASE 6:Result = 35;break;	}	break;
	CASE 5:	Switch(Cmn)		{	CASE 0:Result = 36;break;CASE 1:Result = 37;break;CASE 2:Result = 38;break;CASE 3:Result = 39;break;CASE 4:Result = 40;break;CASE 5:Result = 41;break;CASE 6:Result = 42;break;	}	break;
	CASE 6:	Switch(Cmn)		{	CASE 0:Result = 43;break;CASE 1:Result = 44;break;CASE 2:Result = 45;break;CASE 3:Result = 46;break;CASE 4:Result = 47;break;CASE 5:Result = 48;break;CASE 6:Result = 49;break;	}	break;
	}
return Result;
}







#libdefine	GLP_Root			1
#libdefine	GLP_ContainerType	2
#libdefine	GLP_Direction		3
#libdefine	GLP_BorderXMethod	4
#libdefine	GLP_BorderYMethod	5
#libdefine	GLP_Stairs			6
#libdefine	GLP_BlockCounter	7
#libdefine	GLP_VecIn			8
#libdefine	GLP_VecOut			9
#libdefine	GLP_ElementTag		10
#libdefine	GLP_BlocksAmount	11

function int GetLayoutProperties	(int LayoutID, int What, int SnakeHeader)
{
int Result, 	Root, BlockCounter, VecIn, VecOut, ContainerType, Direction, BorderXMethod, BorderYMethod, Stairs, ElementTag, BlocksAmount;
bool ForceXwall, ForceYwall;



// The first and the last blocks should always have predefined rotation, and must be a OneBlock
Switch(LayoutID)
{
CASE 1:						//Snakey
BlocksAmount = 25;
	Switch(SnakeHeader)
	{
	CASE 1:  	Root = TRUE;	BlockCounter =  1;		ElementTag =  1;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = StartBlock;		Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 2: 	Root = TRUE;	BlockCounter =  2;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 3:  	Root = FALSE;	BlockCounter =  3;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 4:  	Root = TRUE;	BlockCounter =  4;		ElementTag =  3;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 5:  	Root = TRUE;	BlockCounter =  5;		ElementTag =  4;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 6:  	Root = FALSE;	BlockCounter = 10;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 7:  	Root = FALSE;	BlockCounter =  9;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 8:  	Root = FALSE;	BlockCounter =  8;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 9:  	Root = TRUE;	BlockCounter =  7;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 10:	Root = TRUE;	BlockCounter =  6;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 11:	Root = FALSE;	BlockCounter = 11;		ElementTag =  6;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 12:  	Root = TRUE;	BlockCounter = 12;		ElementTag =  7;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 13:  	Root = TRUE;	BlockCounter = 13;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 14:  	Root = FALSE;	BlockCounter = 14;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 15:  	Root = FALSE;	BlockCounter = 15;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 16:  	Root = FALSE;	BlockCounter = 20;		ElementTag =  9;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 17:  	Root = TRUE;	BlockCounter = 19;		ElementTag =  9;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 18:  	Root = FALSE;	BlockCounter = 18;		ElementTag = 10;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 19:  	Root = TRUE;	BlockCounter = 17;		ElementTag = 10;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 20:  	Root = TRUE;	BlockCounter = 16;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 21:  	Root = TRUE;	BlockCounter = 21;		ElementTag = 12;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 22:  	Root = TRUE;	BlockCounter = 22;		ElementTag = 13;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 23:  	Root = TRUE;	BlockCounter = 23;		ElementTag = 14;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 24:  	Root = FALSE;	BlockCounter = 24;		ElementTag = 14;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 25: 	Root = TRUE;	BlockCounter = 25;		ElementTag = 15;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = FinishBlock;	Direction = ToRIGHT;				BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	ForceYwall = TRUE;	break;
	}
break;


CASE 2:						//Spiral
BlocksAmount = 25;
	Switch(SnakeHeader)
	{
	CASE 1:  	Root = TRUE;	BlockCounter =  1;		ElementTag =  1;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = StartBlock;		Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 2: 	Root = TRUE;	BlockCounter =  2;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 3:  	Root = FALSE;	BlockCounter =  3;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 4:  	Root = TRUE;	BlockCounter =  4;		ElementTag =  3;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 5:  	Root = TRUE;	BlockCounter =  5;		ElementTag =  4;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 6:  	Root = FALSE;	BlockCounter = 10;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 7:  	Root = FALSE;	BlockCounter = 15;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 8:  	Root = TRUE;	BlockCounter = 20;		ElementTag =  5;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 9:  	Root = FALSE;	BlockCounter = 25;		ElementTag =  5;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	ForceYwall = TRUE;	break;
	CASE 10:	Root = FALSE;	BlockCounter = 24;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 11:	Root = FALSE;	BlockCounter = 23;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 12:  	Root = TRUE;	BlockCounter = 22;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 13:  	Root = FALSE;	BlockCounter = 21;		ElementTag =  7;	VecIn = ToLEFT;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 14:  	Root = TRUE;	BlockCounter = 16;		ElementTag =  7;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_Full;		break;
	CASE 15:  	Root = FALSE;	BlockCounter = 11;		ElementTag =  8;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 16:  	Root = TRUE;	BlockCounter =  6;		ElementTag =  8;	VecIn = ToUP;		VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 17:  	Root = TRUE;	BlockCounter =  7;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 18:  	Root = FALSE;	BlockCounter =  8;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 19:  	Root = FALSE;	BlockCounter =  9;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 20:  	Root = TRUE;	BlockCounter = 14;		ElementTag = 10;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_Full;		break;
	CASE 21:  	Root = FALSE;	BlockCounter = 19;		ElementTag = 10;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	CASE 22:  	Root = FALSE;	BlockCounter = 18;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 23:  	Root = TRUE;	BlockCounter = 17;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 24:  	Root = TRUE;	BlockCounter = 12;		ElementTag = 12;	VecIn = ToUP;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 25: 	Root = TRUE;	BlockCounter = 13;		ElementTag = 13;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = FinishBlock;	Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	}
break;



CASE 3:						//Semi-Spiral
BlocksAmount = 25;
	Switch(SnakeHeader)
	{
	CASE 1:  	Root = TRUE;	BlockCounter = 11;		ElementTag =  1;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = StartBlock;		Direction = ToRIGHT;				BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 2: 	Root = TRUE;	BlockCounter = 12;		ElementTag =  2;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 3:  	Root = TRUE;	BlockCounter = 13;		ElementTag =  3;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 4:  	Root = TRUE;	BlockCounter = 18;		ElementTag =  4;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	CASE 5:  	Root = TRUE;	BlockCounter = 17;		ElementTag =  5;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 6:  	Root = TRUE;	BlockCounter = 16;		ElementTag =  6;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 7:  	Root = TRUE;	BlockCounter = 21;		ElementTag =  7;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 8:  	Root = TRUE;	BlockCounter = 22;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 9:  	Root = FALSE;	BlockCounter = 23;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 10:	Root = TRUE;	BlockCounter = 24;		ElementTag =  9;	VecIn = ToRIGHT;	VecOut = ToUP;		ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_Full;		ForceXwall = TRUE;	break;
	CASE 11:	Root = FALSE;	BlockCounter = 19;		ElementTag = 10;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 12:  	Root = TRUE;	BlockCounter = 14;		ElementTag = 10;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = TwoBlocks;		Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_Full;		break;
	CASE 13:  	Root = TRUE;	BlockCounter =  9;		ElementTag = 11;	VecIn = ToUP;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 14:  	Root = FALSE;	BlockCounter =  8;		ElementTag = 12;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 15:  	Root = TRUE;	BlockCounter =  7;		ElementTag = 12;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 16:  	Root = TRUE;	BlockCounter =  6;		ElementTag = 13;	VecIn = ToLEFT;		VecOut = ToUP;		ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 17:  	Root = TRUE;	BlockCounter =  1;		ElementTag = 14;	VecIn = ToUP;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 18:  	Root = TRUE;	BlockCounter =  2;		ElementTag = 15;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 19:  	Root = FALSE;	BlockCounter =  3;		ElementTag = 15;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 20:  	Root = FALSE;	BlockCounter =  4;		ElementTag = 15;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 21:  	Root = TRUE;	BlockCounter =  5;		ElementTag = 16;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 22:  	Root = TRUE;	BlockCounter = 10;		ElementTag = 17;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = ToUP_or_ToDOWN;			BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 23:  	Root = FALSE;	BlockCounter = 15;		ElementTag = 17;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 24:  	Root = FALSE;	BlockCounter = 20;		ElementTag = 17;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 25: 	Root = TRUE;	BlockCounter = 25;		ElementTag = 18;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = FinishBlock;	Direction = ToDOWN;					BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	ForceYwall = TRUE;	break;
	}
break;

CASE 4:						//Mixion
BlocksAmount = 25;
	Switch(SnakeHeader)
	{
	CASE 1:  	Root = TRUE;	BlockCounter =  1;		ElementTag =  1;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = StartBlock;		Direction = ToDOWN;					BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 2: 	Root = TRUE;	BlockCounter =  6;		ElementTag =  2;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 3:  	Root = TRUE;	BlockCounter = 11;		ElementTag =  3;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 4:  	Root = TRUE;	BlockCounter = 12;		ElementTag =  4;	VecIn = ToRIGHT;	VecOut = ToUP;		ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	CASE 5:  	Root = TRUE;	BlockCounter =  7;		ElementTag =  5;	VecIn = ToUP;		VecOut = ToUP;		ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 6:  	Root = TRUE;	BlockCounter =  2;		ElementTag =  6;	VecIn = ToUP;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 7:  	Root = TRUE;	BlockCounter =  3;		ElementTag =  7;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		break;
	CASE 8:  	Root = FALSE;	BlockCounter =  4;		ElementTag =  7;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = TwoBlocks;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 9:  	Root = TRUE;	BlockCounter =  5;		ElementTag =  8;	VecIn = ToRIGHT;	VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 10:	Root = TRUE;	BlockCounter = 10;		ElementTag =  9;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 11:	Root = TRUE;	BlockCounter = 15;		ElementTag = 10;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 12:  	Root = TRUE;	BlockCounter = 14;		ElementTag = 11;	VecIn = ToLEFT;		VecOut = ToUP;		ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 13:  	Root = TRUE;	BlockCounter =  9;		ElementTag = 12;	VecIn = ToUP;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 14:  	Root = TRUE;	BlockCounter =  8;		ElementTag = 13;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 15:  	Root = TRUE;	BlockCounter = 13;		ElementTag = 14;	VecIn = ToDOWN;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_Full;		break;
	CASE 16:  	Root = TRUE;	BlockCounter = 18;		ElementTag = 15;	VecIn = ToDOWN;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_Full;		break;
	CASE 17:  	Root = TRUE;	BlockCounter = 17;		ElementTag = 16;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	CASE 18:  	Root = TRUE;	BlockCounter = 16;		ElementTag = 17;	VecIn = ToLEFT;		VecOut = ToDOWN;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_wEntrance;	break;
	CASE 19:  	Root = TRUE;	BlockCounter = 21;		ElementTag = 18;	VecIn = ToDOWN;		VecOut = ToRIGHT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 20:  	Root = TRUE;	BlockCounter = 22;		ElementTag = 19;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = ToRIGHT_or_ToLEFT;		BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 21:  	Root = FALSE;	BlockCounter = 23;		ElementTag = 19;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	break;
	CASE 22:  	Root = FALSE;	BlockCounter = 24;		ElementTag = 19;	VecIn = ToRIGHT;	VecOut = ToRIGHT;	ContainerType = ThreeBlocks;	Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_wEntrance;	ForceXwall = TRUE;	break;
	CASE 23:  	Root = TRUE;	BlockCounter = 25;		ElementTag = 20;	VecIn = ToRIGHT;	VecOut = ToUP;		ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_None;		BorderYMethod = BorderFill_None;		ForceXwall = TRUE;	ForceYwall = TRUE;	break;
	CASE 24:  	Root = TRUE;	BlockCounter = 20;		ElementTag = 21;	VecIn = ToUP;		VecOut = ToLEFT;	ContainerType = OneBlock;		Direction = 0;						BorderXMethod = BorderFill_wEntrance;	BorderYMethod = BorderFill_None;		ForceYwall = TRUE;	break;
	CASE 25: 	Root = TRUE;	BlockCounter = 19;		ElementTag = 22;	VecIn = ToLEFT;		VecOut = ToLEFT;	ContainerType = FinishBlock;	Direction = ToLEFT;					BorderXMethod = BorderFill_Full;		BorderYMethod = BorderFill_wEntrance;	break;
	}
break;

}




/*
  _  __      _        _          _              _         _              _          _                 _
 (_)/ _|  __| |_ __ _(_)_ _ ___ | |_  __ _ ___ | |_ ___  | |__  ___   __| |___ _ __| |___ _  _ ___ __| |
 | |  _| (_-<  _/ _` | | '_(_-< | ' \/ _` (_-< |  _/ _ \ | '_ \/ -_) / _` / -_) '_ \ / _ \ || / -_) _` |
 |_|_|   /__/\__\__,_|_|_| /__/ |_||_\__,_/__/  \__\___/ |_.__/\___| \__,_\___| .__/_\___/\_, \___\__,_|
                                                                              |_|         |__/
*/


if 	(
	(RoundInfo[StairsChance] >= 50)	&&
	//((ContainerType >= OneBlock) && (ContainerType < FourBlocks))
	(ContainerType < FourBlocks)
	)


	{


	Switch(VecIn)
		{
		CASE	ToRIGHT:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToDOWN: 	Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToLEFT: 	Stairs = None;						break;		// I M P O S S I B L E
						CASE ToUP:		Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						}
		break;
		CASE	ToDOWN:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToDOWN: 	Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToLEFT: 	Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToUP: 		Stairs = None;						break;		// I M P O S S I B L E
						}
		break;
		CASE	ToLEFT:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = None;						break;		// I M P O S S I B L E
						CASE ToDOWN: 	Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToLEFT: 	Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToUP: 		Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_Full;		if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						}
		break;
		CASE	ToUP:
				Switch(VecOut)
						{
						CASE ToRIGHT: 	Stairs = Stairs_DIAGONAL_right;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_wEntrance;	break;
						CASE ToDOWN: 	Stairs = None;						break;		// I M P O S S I B L E
						CASE ToLEFT: 	Stairs = Stairs_DIAGONAL_left;		if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						CASE ToUP: 		Stairs = Stairs_NORMAL;				if(ForceXwall == FALSE)	BorderXMethod = BorderFill_wEntrance;	if(ForceYwall == FALSE)	BorderYMethod = BorderFill_Full;		break;
						}
		break;
		}














	if (Stairs)
			{


			if (RoundInfo[InvertedRoute] == true) 	//If there is an inverted route setting
					{


					Switch(VecIn)
						{
						CASE ToRIGHT: 	VecIn = ToLEFT; 	break;
						CASE ToDOWN: 	VecIn = ToUP; 		break;
						CASE ToLEFT: 	VecIn = ToRIGHT; 	break;
						CASE ToUP: 		VecIn = ToDOWN; 	break;
						}

					Switch(VecOut)
						{
						CASE ToRIGHT: 	VecOut = ToLEFT; 	break;
						CASE ToDOWN: 	VecOut = ToUP; 		break;
						CASE ToLEFT: 	VecOut = ToRIGHT; 	break;
						CASE ToUP: 		VecOut = ToDOWN; 	break;
						}

					Switch(Stairs)
						{
						CASE Stairs_DIAGONAL_right: 	Stairs = Stairs_DIAGONAL_left; 		break;
						CASE Stairs_DIAGONAL_left: 		Stairs = Stairs_DIAGONAL_right; 	break;
						}




					int tempVecIn = VecOut; int tempVecOut = VecIn;
						VecIn = tempVecIn; 		VecOut = tempVecOut;




					}



			Direction = VecIn;
			ContainerType = OneBlock;	//STAIRS are always a OneBlock




					//if(ContainerType == OneBlock)
								Switch(VecIn)
									{
									CASE	ToRIGHT:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = StairsHeight;	break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = StairsHeight;	RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP:		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									CASE	ToDOWN:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = StairsHeight;	break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = StairsHeight;	RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP:		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									CASE	ToLEFT:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = StairsHeight;	RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP: 		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									CASE	ToUP:
											Switch(VecOut)
													{
													CASE ToRIGHT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = StairsHeight;	break;
													CASE ToDOWN: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToLEFT: 	RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													CASE ToUP: 		RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;			break;
													}
									break;
									}




			}



									if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_LINEAR)
										if (Stairs == Stairs_NORMAL)
											if (!RoundInfo[StairsDecided])
													{
													RoundInfo[StairsDecided] = TRUE;

													if (RoundInfo[CurrFloorHeight] - StairsHeight > DefaultPitFloorHeight )
															RoundInfo[InvertedStairs] = RNG(FALSE, TRUE);
													}



								if (RoundInfo[StairsDecided])
									 if (RoundInfo[InvertedStairs]) 	//If Stairs inverted
											{
											Switch(VecIn)
												{
												CASE ToRIGHT: 	VecIn = ToLEFT; 	break;
												CASE ToDOWN: 	VecIn = ToUP; 		break;
												CASE ToLEFT: 	VecIn = ToRIGHT; 	break;
												CASE ToUP: 		VecIn = ToDOWN; 	break;
												}

											Switch(VecOut)
												{
												CASE ToRIGHT: 	VecOut = ToLEFT; 	break;
												CASE ToDOWN: 	VecOut = ToUP; 		break;
												CASE ToLEFT: 	VecOut = ToRIGHT; 	break;
												CASE ToUP: 		VecOut = ToDOWN; 	break;
												}
											}










	}

if(Stairs == None)	{RoundInfo[AddBorderEntryHeightX] = None;			RoundInfo[AddBorderEntryHeightY] = None;	}






















if (RoundInfo[InvertedRoute] == true) 	//If there is an inverted route setting
		{
					Switch(ContainerType)
						{
						CASE StartBlock: 		ContainerType = FinishBlock; 	break;
						CASE FinishBlock: 		ContainerType = StartBlock; 	break;
						}
		}




			if (Direction == 0) 				Direction = RNG(1,4);

	else	if (Direction == ToRIGHT_or_ToLEFT)	if (RNG(0,1) == false)	Direction = ToRIGHT;	else Direction = ToLEFT;
	else	if (Direction == ToUP_or_ToDOWN)	if (RNG(0,1) == false)	Direction = ToUP; 		else Direction = ToDOWN;










Switch(What)
		{
		CASE GLP_Root:				Result = Root;				break;
		CASE GLP_ContainerType: 	Result = ContainerType;		break;
		CASE GLP_Direction: 		Result = Direction;			break;
		CASE GLP_BorderXMethod:		Result = BorderXMethod;		break;
		CASE GLP_BorderYMethod:		Result = BorderYMethod;		break;
		CASE GLP_Stairs:			Result = Stairs;			break;
		CASE GLP_BlockCounter:		Result = BlockCounter;		break;
		CASE GLP_VecIn:				Result = VecIn;				break;
		CASE GLP_VecOut:			Result = VecOut;			break;
		CASE GLP_ElementTag:		Result = ElementTag;		break;
		CASE GLP_BlocksAmount:		Result = BlocksAmount;		break;
		}


return Result;
}












int InputNameTurn, InputHeader;

int LayoutID = 0;				int SnakeHeader = 0;			int OldElementTag = 0;		int ElementTag = 0;			int VecIn = 0;
int VecOut = 0;					int Stairs = 0;					int BorderXmethod = 0;		int BorderYmethod = 0;		int ListCounter = 0;
int ContainerRoot = 0;			int Zpecial = 0;





#libdefine BOSS_RootBlockCounter 7
#libdefine BOSS_PlaygroundBlocks 9

#libdefine GLPB_BlockCounter 	0
#libdefine GLPB_BorderXMethod 	1
#libdefine GLPB_BorderYMethod 	2

function int GetLayoutPropertiesBoss	(int Counter, int ReturnWhat)
{
int Result, BlockCounter;
Switch(counter)
		{
		CASE 1:		BlockCounter = BOSS_RootBlockCounter;									BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 2:		BlockCounter = BOSS_RootBlockCounter + 1;								BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 3:		BlockCounter = BOSS_RootBlockCounter + 2;								BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_Full;			break;
		CASE 4:		BlockCounter = BOSS_RootBlockCounter + 0 + sqrt(PlaygroundBlocks);		BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 5:		BlockCounter = BOSS_RootBlockCounter + 1 + sqrt(PlaygroundBlocks);		BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 6:		BlockCounter = BOSS_RootBlockCounter + 2 + sqrt(PlaygroundBlocks);		BorderXMethod	=	BorderFill_wEntrance;		BorderYMethod	=	BorderFill_Full;			break;
		CASE 7:		BlockCounter = BOSS_RootBlockCounter + 0 + sqrt(PlaygroundBlocks)*2;	BorderXMethod	=	BorderFill_Full;			BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 8:		BlockCounter = BOSS_RootBlockCounter + 1 + sqrt(PlaygroundBlocks)*2;	BorderXMethod	=	BorderFill_Full;			BorderYMethod	=	BorderFill_wEntrance;		break;
		CASE 9:		BlockCounter = BOSS_RootBlockCounter + 2 + sqrt(PlaygroundBlocks)*2;	BorderXMethod	=	BorderFill_Full;			BorderYMethod	=	BorderFill_Full;			break;
		}

Switch(ReturnWhat)
	{
	CASE GLPB_BlockCounter:		Result = BlockCounter;	break;
	CASE GLPB_BorderXMethod:	Result = BorderXMethod;	break;
	CASE GLPB_BorderYMethod:	Result = BorderYMethod;	break;
	}

return Result;
}






/*

  _______      ___      .___  ___.  _______           __        ______     ______   .______
 /  _____|    /   \     |   \/   | |   ____|         |  |      /  __  \   /  __  \  |   _  \
|  |  __     /  ^  \    |  \  /  | |  |__            |  |     |  |  |  | |  |  |  | |  |_)  |
|  | |_ |   /  /_\  \   |  |\/|  | |   __|           |  |     |  |  |  | |  |  |  | |   ___/
|  |__| |  /  _____  \  |  |  |  | |  |____          |  `----.|  `--'  | |  `--'  | |  |
 \______| /__/     \__\ |__|  |__| |_______|         |_______| \______/   \______/  | _|


*/

Script "GAMELOGIC" (void)
{
int BlockCounter = 0;			int ContainerType = 0;			int Direction = 0;			int ColumnNum = 0;			int RowNum = 0;
int ContainerTry = 0;			int counter = 0;
int a = 0;						int b = 0;						//int c = 0;


LoadBit = 0;


bool ForceAutoName = false;
str StringA = "";
str StringB = "";

GAMESTATE = gs_LOADING;
RoundInfo[EnemyCounter] = 0;
Light_ChangeToValue(TIDRAM_EnemyCount, 0);
RoundInfo[CheckpointReached] = FALSE;
RoundInfo[PlaygroundReached] = FALSE;

RoundInfo[LoadSegments] = PlaygroundBlocks*2;	//Clears and deploys





/*
  ___             _      ___                   _
 | _ \___ ___ ___| |_   / __|___ ___ _ __  ___| |_ _ _ _  _
 |   / -_|_-</ -_)  _| | (_ / -_) _ \ '  \/ -_)  _| '_| || |
 |_|_\___/__/\___|\__|  \___\___\___/_|_|_\___|\__|_|  \_, |
                                                       |__/

*/





			{


//---------- SET IT ALWAYS !------------------------------------------------

			//ACTORS
			for(a = ACTORTID_Enemy; a < ACTORTID_Enemy + MaxEnemy; a++)
					{
					Thing_Deactivate	(a);
					Thing_Remove		(a);
					}


			Thing_Deactivate	(ACTORTID_Boss);
			Thing_Remove		(ACTORTID_Boss);





			//HUB
			PortalVisuals(OFF);

			Light_ChangeToValue(TIDRAM_ExitMarkerA, FALSE);
			Light_ChangeToValue(TIDRAM_ExitMarkerB, FALSE);


//---------- SET IT JUST ONCE !------------------------------------------------





			if (RoundInfo[MiniCheckPoint] == 0)
					{
					LayoutID = RNG(1,4);
					//Change Textures, Fog, etc
					SetAtmosphere(RoundInfo[CurrentRound]);
					RoundInfo[GlobalCeilingHeight] 	= AdventureCeilingHeight();
					RoundInfo[GlobalFloorHeight] 	= DefaultFloorHeight;
					RoundInfo[AddBorderEntryHeightX] = None;
					RoundInfo[AddBorderEntryHeightY] = None;
					RoundInfo[InvertedStairs] = None;
					RoundInfo[CurrFloorHeight] = None;
					RoundInfo[PitFloorHeight]	=	DefaultPitFloorHeight;
					RoundInfo[PitCeilingHeight]	=	DefaultPitCeilingHeight;

					//SetOutsideLines(LINETAG_PlaygroundFence, 		OFF, "-");
					//SetOutsideLines(LINETAG_PlaygroundPerimeter,	OFF, "-");

					//Ouside Lines
					SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_BACK, TEXTURE_BOTTOM,	TextureIs(WallEDGEtx));
					SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_BACK, TEXTURE_TOP, 	TextureIs(WallEDGEtx));
					SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_FRONT, TEXTURE_MIDDLE, "-");
					SetLineTexture(LINETAG_PlaygroundFence, 	SIDE_FRONT, TEXTURE_MIDDLE, "-");
					Line_SetBlocking(LINETAG_PlaygroundPerimeter, None,	BLOCKF_SIGHT);
					Line_SetBlocking(LINETAG_PlaygroundPerimeter, None,	BLOCKF_EVERYTHING);
					Line_SetBlocking(LINETAG_PlaygroundPerimeter, None,	BLOCKF_CREATURES);
					Line_SetBlocking(LINETAG_PlaygroundFence, 	  None, BLOCKF_CREATURES);


					if (GetPort() > ZDaemon)
						{
						Thing_Remove		(ACTORTID_AmbientSound);
						Thing_Remove		(ACTORTID_AmbientWater);
						}

					SetWarmupBlockLines(FALSE);
					}




//---------- SET IT ALWAYS !------------------------------------------------


			RoundInfo[adventureCounter] = 0;
			RoundInfo[EnemyAmmo] = 0;
			ListCounter = 0;
			SetPlaygroundColor();

			//RoundInfo[StartpointTAG] 	= ImpossibleNum;
			//RoundInfo[FinishpointTAG] 	= ImpossibleNum;



			/* DEBUG */




			FillArea(0, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER, DOESNT_MATTER);


			//Refresh Border Exceptions for projectiles
			//-------------------------------------------------------------------
			ACS_NamedTerminate("Projectiles", 0);	Thing_Remove(ACTORTID_Projectile);
			for(a = 0; a < ProjectilaSlots; a++)	for(b = 0; b < ProjectilaParams; b++)	Projectila[a][b] = 0;
			RoundInfo[BorderExceptionCounter] = 0;

			// Clear items
			ACS_NamedTerminate("Items", 0);			//Thing_Remove(ACTORTID_Projectile);

			for(a = 0; a <= RoundInfo[SectorItemCounter]; a++)	for(b = 0; b < SectorItemParams; b++)	{	Thing_Remove(ACTORTID_DynamicTid + SectorItem [a][si_SECTOR]);		SectorItem [a][b] = 0;		}
			RoundInfo[SectorItemCounter] = 0;


			// Clear Worms
			ACS_NamedTerminate("Worms", 0);
			for(a = 0; a < WormSlots; a++)	for(b = 0; b < WormParams; b++)	Worm[a][b] = 0;


			// Clear Soil
			ACS_NamedTerminate("Soil", 0);
			for(a = 0; a < SoilSlots; a++)	for(b = 0; b < SoilParams; b++)	Soil[a][b] = 0;


/*
			RoundInfo[WeaponSpawnerCounter] 	= RoundInfo[WeaponSpawnerQueue];
			RoundInfo[MoneySpawnerCounter] 		= RoundInfo[MoneySpawnerQueue];
			RoundInfo[HealthSpawnerCounter] 	= RoundInfo[HealthSpawnerQueue];
			RoundInfo[AmmoSpawnerCounter] 		= RoundInfo[AmmoSpawnerQueue];
*/
			//-------------------------------------------------------------------
			while(BlockCounter < PlaygroundBlocks)
				{
				counter = 1;
				BlockCounter++;
				if (RoundInfo[MiniCheckPoint] == 0)		ClearBlockTextures (BlockCounter);

//////////////////// OUTSIDE SECTORS /////////////////////////////////////////////////
					if (BlockCounterAtTheEdge(ToRIGHT,  BlockCounter) == TRUE)
								{
								delay(	SetArea 		(area_FLOOR, 							BlockCounter, ToRIGHT, 	1, 	8,  9,  9, RoundInfo[PitFloorHeight], 		"F_SKY1", SectorSpecial_CLEAR));
								delay(	SetArea 		(area_CEILING, 							BlockCounter, ToRIGHT, 	1, 	8,  9,  9, RoundInfo[GlobalCeilingHeight], 	"F_SKY1", None));				//RoundInfo[PitCeilingHeight]
								b = 8;
								}
					else b = 9;

					if (BlockCounterAtTheEdge(ToDOWN, 	BlockCounter) == TRUE)
								{
								delay(	SetArea 		(area_FLOOR, 							BlockCounter, ToRIGHT, 	9, 	9,  1,  8, RoundInfo[PitFloorHeight], 		"F_SKY1", SectorSpecial_CLEAR));
								delay(	SetArea 		(area_CEILING, 							BlockCounter, ToRIGHT, 	9, 	9,  1,  8, RoundInfo[GlobalCeilingHeight], 	"F_SKY1", None));				//RoundInfo[PitCeilingHeight]
								a = 8;
								}
					else a = 9;
////////////////////MAIN SECTORS /////////////////////////////////////////////////
					while(counter <= a)
						{
						delay(	SetArea 		(area_FLOOR, 							BlockCounter, ToRIGHT, 	counter, 	counter,  1,  b, RoundInfo[GlobalFloorHeight], 		TextureIs(FlatBASEtx), SectorSpecial_CLEAR));
						delay(	SetArea 		(area_CEILING, 							BlockCounter, ToRIGHT, 	counter, 	counter,  1,  b, RoundInfo[GlobalCeilingHeight], 	TextureIs(CeilBASEtx), None));
						counter ++;
						}


				loadbit++;
				}
			counter = 0;
			BlockCounter = 0;
			SetSectorVisual(SECTORTAG_pit);

			}









//LOADING


			delay(SEC*2);
					// -----
			/* DEBUG */	//ChangeCamera(ACTORTID_DebugCamera, 1, 1);










/*
  _____             _                 _                          _                 _                      _
 |  __ \           | |               | |                /\      | |               | |                    | |
 | |  | | ___ _ __ | | ___  _   _    | |__  _   _      /  \   __| |_   _____ _ __ | |_ _   _ _ __ ___    | |_ _   _ _ __   ___
 | |  | |/ _ \ '_ \| |/ _ \| | | |   | '_ \| | | |    / /\ \ / _` \ \ / / _ \ '_ \| __| | | | '__/ _ \   | __| | | | '_ \ / _ \
 | |__| |  __/ |_) | | (_) | |_| |   | |_) | |_| |   / ____ \ (_| |\ V /  __/ | | | |_| |_| | | |  __/   | |_| |_| | |_) |  __/
 |_____/ \___| .__/|_|\___/ \__, |   |_.__/ \__, |  /_/    \_\__,_| \_/ \___|_| |_|\__|\__,_|_|  \___|    \__|\__, | .__/ \___|
             | |             __/ |           __/ |                                                             __/ | |
             |_|            |___/           |___/                                                             |___/|_|
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
*/

Switch(LayoutType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]))
		{

			/*
			  _                            _         ____      _    _   _ ____   ___  __  __
			 | |    __ _ _   _  ___  _   _| |_      |  _ \    / \  | \ | |  _ \ / _ \|  \/  |
			 | |   / _` | | | |/ _ \| | | | __|     | |_) |  / _ \ |  \| | | | | | | | |\/| |
			 | |__| (_| | |_| | (_) | |_| | |_      |  _ <  / ___ \| |\  | |_| | |_| | |  | |
			 |_____\__,_|\__, |\___/ \__,_|\__|     |_| \_\/_/   \_\_| \_|____/ \___/|_|  |_|
						 |___/
			*/
			CASE	LayoutType_Random:

				RoundInfo[InvertedRoute] = FALSE;

				Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
						{
						CASE adventure_MAZE:	RoundInfo[StartpointTAG] = RNG(1, PlaygroundBlocks/2);	break;

						CASE adventure_INVASION:
						RoundInfo[StartpointTAG] = RNG(1,4);
						Switch(RoundInfo[StartpointTAG])
								{
								CASE 1:	break;
								CASE 2:	break;
								CASE 3:	RoundInfo[StartpointTAG] = sqrt(PlaygroundBlocks) + 1;	break;
								CASE 4:	RoundInfo[StartpointTAG] = sqrt(PlaygroundBlocks) + 2;	break;
								}
						break;

						}


				While(BlockCounter < PlaygroundBlocks)
				{


					while(BlockCounter < (sqrt(PlaygroundBlocks)*(RowNum + 1)) )		//Checking this row

							{


								BlockCounter++;

								if(StrLen(BlockAt[RowNum][ColumnNum]) <= 1) // if this block is vacant

											{
											delay(10);
											ContainerTry = 0;






											While(ContainerTry < MaxContainerTries)
												{
													Direction 		= RNG(1,4);

															if (BlockCounter >= RoundInfo[StartpointTAG])	ContainerType 	= OneBlock;		//FORCE A TELEPORT BLOCK
													else 	if (ContainerTry == MaxContainerTries - 1)		ContainerType 	= OneBlock;
													else 													ContainerType 	= RNG(1, 3);	//AllowedContainerTypes);



													if (CheckArea(ContainerType, Direction, RowNum, ColumnNum) == true)
														{

															/*
															  ___                             _   _
															 | _ \_ _ ___ _ __  __ _ _ _ __ _| |_(_)___ _ _  ___
															 |  _/ '_/ -_) '_ \/ _` | '_/ _` |  _| / _ \ ' \(_-<
															 |_| |_| \___| .__/\__,_|_| \__,_|\__|_\___/_||_/__/
																		 |_|

															*/

															ReloadObstacles();
															FillArea(1, ContainerType, Direction, RowNum, ColumnNum, NONE, NONE, NONE);
															RoundInfo[OptEntranceX] = false;
															RoundInfo[OptEntranceY] = RNG(false, true);


															/*
															   ___         _        _                ___             _
															  / __|___ _ _| |_ __ _(_)_ _  ___ _ _  | _ ) ___ _ _ __| |___ _ _ ___
															 | (__/ _ \ ' \  _/ _` | | ' \/ -_) '_| | _ \/ _ \ '_/ _` / -_) '_(_-<
															  \___\___/_||_\__\__,_|_|_||_\___|_|   |___/\___/_| \__,_\___|_| /__/


															*/



															FillContainerBorders(ContainerType, BlockCounter, Direction);
															Delay(GenDel_Border);
															/*
															   ___         _        _                 ___
															  / __|___ _ _| |_ __ _(_)_ _  ___ _ _   / __|___ _ _ ___
															 | (__/ _ \ ' \  _/ _` | | ' \/ -_) '_| | (__/ _ \ '_/ -_)
															  \___\___/_||_\__\__,_|_|_||_\___|_|    \___\___/_| \___|


															*/

															Deploying = true;

																	if (BlockCounter >= RoundInfo[StartpointTAG])	ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, StartBlock);
																	else											ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);

															While(Deploying == true) delay(1);
															/*
															  __  __ ___ ___  ___
															 |  \/  |_ _/ __|/ __|
															 | |\/| || |\__ \ (__
															 |_|  |_|___|___/\___|

															*/


															LoadBit	+=	ContainerType;


															ContainerTry = MaxContainerTries;
														}

													else ContainerTry++;


												}





											}



								ColumnNum++;

							}
				RowNum++;
				ColumnNum = 0;


				}

				RoundInfo[FinishpointTAG] = RoundInfo[StartpointTAG];
				Light_ChangeToValue(TIDRAM_ExitMarkerA, RoundInfo[FinishpointTag]/100);




		break;








			/*
			  _                            _         ______   __   _____ _   _ _____    _     ___ ____ _____
			 | |    __ _ _   _  ___  _   _| |_      | __ ) \ / /  |_   _| | | | ____|  | |   |_ _/ ___|_   _|
			 | |   / _` | | | |/ _ \| | | | __|     |  _ \\ V /     | | | |_| |  _|    | |    | |\___ \ | |
			 | |__| (_| | |_| | (_) | |_| | |_      | |_) || |      | | |  _  | |___   | |___ | | ___) || |
			 |_____\__,_|\__, |\___/ \__,_|\__|     |____/ |_|      |_| |_| |_|_____|  |_____|___|____/ |_|
						 |___/
			*/

			CASE	LayoutType_ByTheList:

					//---------------------------------------------------------------------------------------------------------
					if (RoundInfo[MiniCheckpoint] == 0)									RoundInfo[InvertedRoute] = RNG(false, true);

					if (RoundInfo[MiniCheckpoint] >	 0)
											{
											if (RoundInfo[InvertedRoute] == false)		RoundInfo[InvertedRoute] = TRUE;
											else										RoundInfo[InvertedRoute] = FALSE;
											}

					//---------------------------------------------------------------------------------------------------------

					RoundInfo[StairsDecided] = FALSE;


					Switch(RoundInfo[InvertedRoute])
						{
						CASE FALSE:		SnakeHeader = 0;					break;
						CASE TRUE:		SnakeHeader = PlaygroundBlocks + 1; break;
						}




						While(ListCounter < GetLayoutProperties(LayoutID, GLP_BlocksAmount,	DOESNT_MATTER) )
						{


							ListCounter++;
							Zpecial = None;
							ReloadObstacles();


						Switch(RoundInfo[InvertedRoute])
							{
							CASE FALSE:		SnakeHeader++;	OldElementTag 	=	GetLayoutProperties(LayoutID, GLP_ElementTag, 	SnakeHeader - 1);	break;
							CASE TRUE:		SnakeHeader--;	OldElementTag 	=	GetLayoutProperties(LayoutID, GLP_ElementTag, 	SnakeHeader + 1);	break;
							}

						//------ Retrieving the Layout's Information -----------------------------------------------------------------------------------------------------------------------

								ElementTag		=	GetLayoutProperties(LayoutID, GLP_ElementTag, 	SnakeHeader	   );


								if ((ElementTag != OldElementTag))	// REFRESH STAIRS CHANCE, if switching to new element
								Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
									{
									CASE  adventure_RAISE: 	RoundInfo[StairsChance] = RNG(40,	100);	break;	//always use stair blocks if it's possible
									CASE  adventure_LINEAR: RoundInfo[StairsChance] = RNG(0, 	60);	break;  //randomize stair blocks
									CASE  adventure_FLOW:	RoundInfo[StairsChance] = RNG(50, 	100);	break;  //fake stairs to use diagonals
									}
								ContainerRoot	=	GetLayoutProperties(LayoutID, GLP_Root,				SnakeHeader);
								VecIn			=	GetLayoutProperties(LayoutID, GLP_VecIn,			SnakeHeader);
								VecOut			=	GetLayoutProperties(LayoutID, GLP_VecOut,			SnakeHeader);
								ContainerType	=	GetLayoutProperties(LayoutID, GLP_ContainerType,	SnakeHeader);
								BlockCounter	=	GetLayoutProperties(LayoutID, GLP_BlockCounter, 	SnakeHeader);
								Direction		= 	GetLayoutProperties(LayoutID, GLP_Direction, 		SnakeHeader);
								Stairs 			= 	GetLayoutProperties(LayoutID, GLP_Stairs,	 		SnakeHeader);
								BorderXMethod	=	GetLayoutProperties(LayoutID, GLP_BorderXMethod,	SnakeHeader);
								BorderYMethod	=	GetLayoutProperties(LayoutID, GLP_BorderYMethod,	SnakeHeader);

						//---------------------------------------------------------------------------------------------------------------------------------

//ChangeCamera(BlockCounter*100 + 24, 1, 1);
								/*
								   ___ ___  _  _ _____ _   ___ _  _ ___ ___     ___  ___  ___ ___  ___ ___  ___
								  / __/ _ \| \| |_   _/_\ |_ _| \| | __| _ \   | _ )/ _ \| _ \   \| __| _ \/ __|
								 | (_| (_) | .` | | |/ _ \ | || .` | _||   /   | _ \ (_) |   / |) | _||   /\__ \
								  \___\___/|_|\_| |_/_/ \_\___|_|\_|___|_|_\   |___/\___/|_|_\___/|___|_|_\|___/

								*/

									RoundInfo[OptEntranceX] = RNG(true,false);		RoundInfo[OptEntranceY] = RNG(true,false);
									SetBorderWall (BorderSideX, BorderXMethod, BlockCounter, Direction);
									SetBorderWall (BorderSideY, BorderYMethod, BlockCounter, Direction);
									Delay(GenDel_Border);



					//If CONTAINER SPACE IS FREE, then deploying it ===========================================================================================





								Deploying = true;





														if ((RoundInfo[StairsChance] >= 50) && (ContainerType < SpecialBlocks))	//If game chose it to be Stairs block. It won't need the
																{


																	if (ContainerType < FourBlocks)
																			{


																						if ((CheckArea( OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true))	//even if forces to be stairs, this block should be free at first.

																							{


																									if (Stairs) 		//if there is an actual ladder block
																										{

																													Zpecial = Stairs;

																															Switch(Stairs)
																															{
																															CASE	Stairs_NORMAL:			a = 101;	b = 101;
																															if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)		{a = 501;	b = 501;}
																															ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:RNG(a, b)), 0, BlockCounter, Direction);			break;


																															CASE	Stairs_DIAGONAL_left:	a = 102;	b = 102;
																															if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)		{a = 502;	b = 502;}
																															ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:RNG(a, b)), 0, BlockCounter, Direction);			break;

																															CASE	Stairs_DIAGONAL_right:	a = 103;	b = 103;
																															if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)		{a = 503;	b = 503;}
																															ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:RNG(a, b)), 0, BlockCounter, Direction);			break;
																															}
																										}


																									else						//if it can't be a stair block, but already preassigned as a stair block, just fill it with the basic OneBlock
																										{

																										ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], OneBlock)), 0, BlockCounter, Direction);

																										}



																							FillArea(1, OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);

																							}

																						// else skip
																			}


																else
																					{
																					if (ContainerRoot == TRUE)
																							{


																								//	if 		((CheckArea( ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true))	//If there is enough space for the container
																											//{
																											ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);
																											FillArea(1, ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																											//}
																							}
																					}


																}

														else //if that's a usual ContainerSet

																{

																	if (ContainerRoot == TRUE)	 //If a pointer is at the Container Root
																		{


																				if (ContainerType >= SpecialBlocks)
																							{
																							//RoundInfo[CurrFloorHeight] += 128;
																							Switch(ContainerType)
																									{
																									case	StartBlock:			ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, StartBlock);			break;
																									case	FinishBlock:		ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, FinishBlock);			break;
																									}

																							Zpecial = ContainerType;
																							FillArea(1, OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																							}


																				else
																							{



																							if 		((CheckArea( ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true))	//If there is enough space for the container
																										{
																										//RoundInfo[CurrFloorHeight] += 128;

																										ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);
																										FillArea(1, ContainerType, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																										}

																							else if ((CheckArea( OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter)) == true)) //okay then if there is not enough space, does it at least allow to place One Block in the ruined container space?
																										{
																										//RoundInfo[CurrFloorHeight] += 128;

																										ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], OneBlock)), 0, BlockCounter, Direction);
																										FillArea(1, OneBlock, Direction, BlockAtAXIS(AxisY, BlockCounter), BlockAtAXIS(AxisX, BlockCounter), VecIn, VecOut, Zpecial);
																										}

																							}



																				//else just skip the whole thing

																		}


																	else if (ContainerRoot == FALSE)  //If a pointer is at the Minor counter
																		{
																		Deploying = false;
																		//log(s:"SKIP BLOCK ", i:Blockcounter);

																			if (ElementTag == OldElementTag) // if staying in the same element
																					{
																					//just keep going
																					}


																			if (ElementTag != OldElementTag) // and if entering the new Element
																					{
																					//just keep going as well
																					}



																		}


																}





						Delay(5);

						While(Deploying == true) delay(1);



						//======================================================================================================================================================


						LoadBit++;
						}





			break;



			/*
			  _                            _         ____   ___  ____ ____
			 | |    __ _ _   _  ___  _   _| |_      | __ ) / _ \/ ___/ ___|
			 | |   / _` | | | |/ _ \| | | | __|     |  _ \| | | \___ \___ \
			 | |__| (_| | |_| | (_) | |_| | |_      | |_) | |_| |___) |__) |
			 |_____\__,_|\__, |\___/ \__,_|\__|     |____/ \___/|____/____/
						 |___/
			*/

			CASE	LayoutType_Boss:

			LoadBit += sqrt(PlaygroundBlocks) - BOSS_PlaygroundBlocks;
			ContainerType = OneBlock;
			RoundInfo[OptEntranceX] = TRUE;		RoundInfo[OptEntranceY] = TRUE;

			//RoundInfo[StartpointTAG] = RNG(BlockCounter_Boss(1), BlockCounter_Boss(PlaygroundBlocksBOSS));
			//SET TELEPORT
			Switch(RNG(1,4))
					{
					CASE 1: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(1, GLPB_BlockCounter);	break;
					CASE 2: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(3, GLPB_BlockCounter);	break;
					CASE 3: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(7, GLPB_BlockCounter);	break;
					CASE 4: RoundInfo[StartpointTAG] = GetLayoutPropertiesBoss(9, GLPB_BlockCounter);	break;
					}


				//-----UP AND LEFT BORDER-----------------------------------------------------------------------
					counter = 0;
					while (counter < 3)
							{
							counter++;
							SetBorderWall (BorderSideX, BorderFill_Full, counter + 1,							ToRIGHT);
							}
					counter = 0;
					while (counter < 3)
							{
							counter++;
							SetBorderWall (BorderSideY, BorderFill_Full, counter*sqrt(PlaygroundBlocks) + 1,	ToRIGHT);
							}
				//--------------------------------------------------------------------------------------


			while (ListCounter < BOSS_PlaygroundBlocks)
					{
					Listcounter++;
					BlockCounter = GetLayoutPropertiesBoss(Listcounter, GLPB_BlockCounter);
					Direction = RNG(1,4);

					//Container Borders -----------------------------------------------------------------


					SetBorderWall (BorderSideX, GetLayoutPropertiesBoss(Listcounter, GLPB_BorderXMethod), BlockCounter, Direction);
					SetBorderWall (BorderSideY, GetLayoutPropertiesBoss(Listcounter, GLPB_BorderYMethod), BlockCounter, Direction);
					Delay(GenDel_Border);
					//-----------------------------------------------------------------------------------


					// Placing a container
					Deploying = true;

					if (BlockCounter >= RoundInfo[StartpointTAG])	ACS_NamedExecuteAlways("TELEPORTBLOCK", 0, BlockCounter, Direction, StartBlock);
					else											ACS_NamedExecuteAlways(StrParam(s:"DEPLOY_", i:ContainerSet(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], ContainerType)), 0, BlockCounter, Direction);

					While(Deploying == true) 	delay(1);


					LoadBit++;
					}


			break;



		}

//--------------------------------------------------------------------
//---------------------------CHECKPOINT LOCATION SWITCHING



if (AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS] > 0)
		{


				if (RoundInfo[MiniCheckPoint] == 0)
					{
					RoundInfo[MiniStartpoint]		=		ImpossibleNum;
					RoundInfo[MiniFinishpoint]		= 		RoundInfo[FinishpointTag];
					//---------------------------------------------------------------------
					//RoundInfo[StartpointTag]		=		STAYS THE SAME
					RoundInfo[FinishpointTag]		=		ImpossibleNum;
					}

		else 	if ((RoundInfo[MiniCheckPoint] > 0)	&& 	(RoundInfo[MiniCheckPoint] < AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS]))
					{
					RoundInfo[MiniStartpoint]		=		RoundInfo[StartpointTag];
					RoundInfo[MiniFinishpoint]		= 		RoundInfo[FinishpointTag];
					//---------------------------------------------------------------------
					RoundInfo[StartpointTag]		=		ImpossibleNum;
					RoundInfo[FinishpointTag]		=		ImpossibleNum;
					}


		else 	if (RoundInfo[MiniCheckPoint] == AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS])
					{
					RoundInfo[MiniStartpoint]		=		RoundInfo[StartpointTag];
					RoundInfo[MiniFinishpoint]		= 		ImpossibleNum;
					//---------------------------------------------------------------------
					RoundInfo[StartpointTag]		=		ImpossibleNum;
					//RoundInfo[FinishpointTag]		=		STAYS THE SAME
					}



//for(a = 1; a <= PlaygroundBlocks; a++)	ClearBlockTextures (a);

counter = 0;
while (counter < PlaygroundBlocks)
		{
		counter++;
		ClearBlockTextures (counter);
		delay(gendel_Height);
		}



		}



// if that's a normal, no minicheckpoints round
else
		{
		//RoundInfo[StartpointTag]		=		STAYS THE SAME
		//RoundInfo[FinishpointTag]		=		STAYS THE SAME
		RoundInfo[MiniStartpoint] 		= 		ImpossibleNum;
		RoundInfo[MiniFinishpoint] 		= 		ImpossibleNum;
		}

//--------------------------------------------------------------------
//--------------------------------------------------------------------



/*
     _              _     _            _     ____                        _
    / \   _ __ ___ | |__ (_) ___ _ __ | |_  / ___|  ___  _   _ _ __   __| |___
   / _ \ | '_ ` _ \| '_ \| |/ _ \ '_ \| __| \___ \ / _ \| | | | '_ \ / _` / __|
  / ___ \| | | | | | |_) | |  __/ | | | |_   ___) | (_) | |_| | | | | (_| \__ \
 /_/   \_\_| |_| |_|_.__/|_|\___|_| |_|\__| |____/ \___/ \__,_|_| |_|\__,_|___/

*/
	if 	 (((GetPort() == ZDaemon) && (RoundInfo[CurrentRound] == 1)) || (GetPort() > ZDaemon))

		{
			if (RoundInfo[MiniCheckPoint] == 0)
					{
					a = TagAt ( 7, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
					a = TagAt ( 9, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
					a = TagAt (17, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
					a = TagAt (19, ToRIGHT, 28);		RefreshSpotHeight(refreshspot_DEFAULT, a);			SpawnSpotForced("MapSpot", a, ACTORTID_AmbientSound, 0);
																											SpawnSpotForced("MapSpot", ACTORTID_AmbientSpot, 	ACTORTID_AmbientSound, 0);
					StringA = StrParam(s:"AmbientSequence", i:GetSectorLightLevel(TIDRAM_Mood), i:RNG(1,3));
					Switch(GetPort())
						{
						CASE ZDaemon:
						CASE GZDoom:
						SoundSequenceOnActor(ACTORTID_AmbientSound, 	StringA);
						break;
						CASE Zandronum:
						SpawnSpotForced(StringA, ACTORTID_AmbientSound, ACTORTID_AmbientSound, 0);
						break;
						}


					}
		}


//---------------------------------------------------------------------




			Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				CASE adventure_BOSS:


							//SetActorProperty(ACTORTID_Boss, APROP_SpawnHealth, a);
							SpawnSpotForced(ActorString(RNG(id_Railgunner, id_Cyberdemon), as_CODE), 1300, ACTORTID_Boss, 0);
							SetActorProperty(ACTORTID_Boss, APROP_Health, AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]);
							//log(s:"BOSS SPAWNED ", i:IsTIDUsed(ACTORTID_Boss));

				//break;


				CASE adventure_MAZE:
				CASE adventure_LINEAR:

							RoundInfo[adventureCounter] = InvasionStartTime/2;
							//DRAW TEXTURES
							SetWarmupBlockLines(TRUE);

				break;
				CASE adventure_RAISE:
							RoundInfo[TimeGiven] = 99999;
							//OBTAINING VARIOUS HEIGHTS------------------------------------------------------------------------------------------------
							RoundInfo[PitFloorHeight]		=	GetSectorFloorZ(SECTORTAG_pit, 0, 0) >> 16;								//Obtaining a pit floor height
							RoundInfo[SubstanceLineOffset]	= 	(abs(RoundInfo[PitFloorHeight]) + RoundInfo[GlobalCeilingHeight])* -1;	//Preparing an offset for the Substance line textures;
							SetClientSubstanceOffset();

							RoundInfo[MaxSubstanceHeight]	=	GetSectorFloorZ(RoundInfo[FinishpointTAG], 0, 0) >> 16;					//Obtaining a physical height for the substance to reach
							RoundInfo[AbsSubstanceHeight]	=	RoundInfo[MaxSubstanceHeight] + abs(RoundInfo[PitFloorHeight]);			//Obtaining the absolute range of the substance movement. Important to define difficulty and speed.
							RoundInfo[CurrSubstanceHeight] 	= 	RoundInfo[PitFloorHeight];												//Set dummy Damage Height
							//RoundInfo[SubstanceMoveDelay]	=	SetSubstanceSpeed();														//Set Substance Speed
							//log(s:"ABS HEIGHT IS ", i:RoundInfo[AbsSubstanceHeight]);
							//SET SUBSTANCE LINES TEXTURE AND OFFSET-----------------------------------------------------------------------------------
							for (a = 1; a <= PlaygroundBlocks;  a++)
								{
								SetLineTexture(a, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								SetLineTexture(a, SIDE_BACK, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								}
							SetLineTexture(LINETAG_Outside, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
							SetLineTexture(LINETAG_Outside, SIDE_BACK, TEXTURE_MIDDLE, TextureIs (WallRAIStx));

							//-------------------------------------------------------------------------------------------------------------------------



				break;

				CASE adventure_INVASION:

							RoundInfo[adventureCounter] = InvasionStartTime;
							//DRAW TEXTURES
							//SetOutsideLines(LINETAG_PlaygroundFence, 		ON, TextureIs (WallFENCtx));
							//SetOutsideLines(LINETAG_PlaygroundPerimeter,	ON, TextureIs (WallFENCtx));
							SetLineTexture(LINETAG_PlaygroundPerimeter, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs(WallEDGEtx));
							SetLineTexture(LINETAG_PlaygroundFence, 	SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallFENCtx));
							Line_SetBlocking(LINETAG_PlaygroundPerimeter, 	BLOCKF_SIGHT, None);
							Line_SetBlocking(LINETAG_PlaygroundPerimeter, 	BLOCKF_EVERYTHING, None);
							Line_SetBlocking(LINETAG_PlaygroundFence, 		BLOCKF_CREATURES, None);



							//////////////////
							//  C O L U M N //
							//////////////////
							counter = 0;
							while(counter < sqrt(PlaygroundBlocks))
									{
									counter++;
									/*
											   __
									  ___ ___ / /_   ___ ________ ___ _
									 (_-</ -_) __/  / _ `/ __/ -_) _ `/
									/___/\__/\__/   \_,_/_/  \__/\_,_/
																				-------------------------------------------------------------
									*/
									delay(	SetArea 	(area_FLOOR, 	ContainerInfo(InfoType_ORDER, OneBlock, 1, counter * sqrt(PlaygroundBlocks), ToRIGHT), ToRIGHT, 	1, 	8,  9,  9, RoundInfo[GlobalFloorHeight], 	TextureIs(FlatSECOtx), None));


									/*
											   __
									  ___ ___ / /_    ___ ___  ___ __ _  __ __
									 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
									/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
																	   /___/  	-------------------------------------------------------------
									*/
									a = 64;	b = 0;
									while(a < 72)
										{
										if (b > 0) b--;
										else 	{
												delay(	SetEnemy (ContainerInfo(InfoType_ORDER, OneBlock, 1, counter * sqrt(PlaygroundBlocks), ToRIGHT), ToRIGHT, 	a, ANG_to_LEFT,  			0	+ RandomRange(20)));
												if (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 33 )																				b = RNG(2,3);
												else if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] >= 33 ) && (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 66 ))		b = RNG(2,4);
												else																																			b = RNG(3,4);
												}

										a++;
										}


									}

							//////////////////
							//     R O W    //
							//////////////////

							counter = PlaygroundBlocks - sqrt(PlaygroundBlocks);
							while(counter < PlaygroundBlocks)
									{
									counter++;
									/*
											   __
									  ___ ___ / /_   ___ ________ ___ _
									 (_-</ -_) __/  / _ `/ __/ -_) _ `/
									/___/\__/\__/   \_,_/_/  \__/\_,_/
																				-------------------------------------------------------------
									*/
									delay(	SetArea 	(area_FLOOR, 	ContainerInfo(InfoType_ORDER, OneBlock, 1, counter, ToRIGHT), ToRIGHT, 	9, 	9,  1,  8, RoundInfo[GlobalFloorHeight], 	TextureIs(FlatSECOtx), None));


									/*
											   __
									  ___ ___ / /_    ___ ___  ___ __ _  __ __
									 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
									/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
																	   /___/  	-------------------------------------------------------------
									*/
									a = 73;	b = 0;
									while(a < 81)
										{
										if (b > 0) b--;
										else 	{
												delay(	SetEnemy (ContainerInfo(InfoType_ORDER, OneBlock, 1, counter, ToRIGHT), ToRIGHT, 	a, ANG_to_UP,  		0	+ RandomRange(20)));
												if (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 33 )																				b = RNG(2,3);
												else if ((AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] >= 33 ) && (AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] < 66 ))		b = RNG(1,3);
												else																																			b = RNG(0,2);
												}
										a++;
										}


									}

				break;



				CASE adventure_FLOW:

				if (RoundInfo[MiniCheckPoint] == 0)
						{
						for(a = 0; a < PlaygroundBlocks; a+=2)		{
																	RefreshSpotHeight(refreshspot_DEFAULT, TagAt (a + 1, ToRIGHT, 28));
																	SpawnSpotForced("MapSpot", TagAt (a + 1, ToRIGHT, 28), ACTORTID_AmbientWater, 0);
																	}

																	if (GetPort() > ZDaemon)	SoundSequenceOnActor(ACTORTID_AmbientWater, 	"AmbientSequenceWater");
						}



				break;


				}






				/*else*/ /* DEBUG */	//SpawnSpotForced("DoomImp", 230, ACTORTID_Enemy, 0);
				/* DEBUG */	delay(SEC*1);

				ACS_NamedExecute("RandomEvent", 0, AdventureInfo[RoundInfo[CurrentRound]][adv_RANDOMEVENT]);
				ACS_NamedExecute("Projectiles", 0);
				ACS_NamedExecute("Items", 0);

				RoundInfo[SoilRestart] 	= TRUE;		ACS_NamedExecute("Worms", 0);
				RoundInfo[WormsRestart] = TRUE;		ACS_NamedExecute("Soil", 0);



				if (RoundInfo[MiniCheckPoint] == 0)
					{
					RoundInfo[TimeGiven] = 60*10 + AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]*5	+ ServerInfo[STAGE]*45;
					Light_ChangeToValue(TIDRAM_JoinTimeLeft, JoinTime);
					TimeLeft = RoundInfo[TimeGiven]; //TimeLeft = JoinTime;

					}



/*
  ____  _____ __  __  ___                     _   _  ___  ____  __  __    _    _
 |  _ \| ____|  \/  |/ _ \      ___  _ __    | \ | |/ _ \|  _ \|  \/  |  / \  | |
 | | | |  _| | |\/| | | | |    / _ \| '__|   |  \| | | | | |_) | |\/| | / _ \ | |
 | |_| | |___| |  | | |_| |   | (_) | |      | |\  | |_| |  _ <| |  | |/ ___ \| |___
 |____/|_____|_|  |_|\___/     \___/|_|      |_| \_|\___/|_| \_\_|  |_/_/   \_\_____|

*/

if (!GAMEINFO[DemoVersion])
{

Switch(GetPort())
		{
		CASE ZDaemon:		if (Netmode() == TRUE)	GAMEINFO[DemoVersion] = TRUE;				break;
		CASE Zandronum:		if ((!IsNetworkGame())	/*|| (!ServerInfo[66]) */ )
													GAMEINFO[DemoVersion] = TRUE;				break;
		CASE GZDoom:								GAMEINFO[DemoVersion] = TRUE;				break;
		}

if (GAMEINFO[DemoVersion])
		{
		GAMEINFO[DemoVersion] = DemoTime;
		}
}












/*
     _    ____ _____ _____     _______       ____    _    __  __ _____
    / \  / ___|_   _|_ _\ \   / / ____|     / ___|  / \  |  \/  | ____|
   / _ \| |     | |  | | \ \ / /|  _|      | |  _  / _ \ | |\/| |  _|
  / ___ \ |___  | |  | |  \ V / | |___     | |_| |/ ___ \| |  | | |___
 /_/   \_\____| |_| |___|  \_/  |_____|     \____/_/   \_\_|  |_|_____|

*/



			//HUB
			PortalVisuals(ON);


			ACS_NamedTerminate("MCR_KillWhileDeploying", 0);

			if (RoundInfo[CurrentRound] == 1)
					if (RoundInfo[MiniCheckPoint] == 0)
							DrawNotification(For_Everyone, StrParam(s:StrToUpper(CreateLocationName())), notepose_MID, notepara_ALIGN, ICON_Location, StrParam(c:ICON_Location), "j", "ERFONT", OFF, ON, noteFadeIn_long, noteHold_Short, noteFadeOut_Short);



if (RoundInfo[MiniCheckPoint] == 0)

			{
			Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				CASE adventure_BOSS:
						Switch(RNG(1,3)){CASE 1:	StringA = "KILL "; break;						CASE 2:	StringA = "DESTROY "; break;					CASE 3:	StringA = "BEAT "; break;	}
						StringA = StrParam(s: StringA, s:"THE BOSS!");

				break;

				CASE adventure_MAZE:
						Switch(RNG(1,3)){CASE 1:	StringA = "CLEAR OFF OF "; break;				CASE 2:	StringA = "DESTROY "; break;					CASE 3:	StringA = "GET RID OF "; break;	}
						Switch(RNG(1,3)){CASE 1:	StringB = "GET BACK "; break;		 			CASE 2:	StringB = "FALL BACK "; break;		 			CASE 3:	StringB = "RETURN "; break;	}
						StringA = StrParam(s: StringA, s:"ALL ENEMIES AND ", s:StringB, s:"TO PORTAL!");
				break;

				CASE adventure_LINEAR:
						Switch(RNG(1,3)){CASE 1:	StringA = "FIGHT THROUGH THE "; break;			CASE 2:	StringA = "DESTROY THE "; break;				CASE 3:	StringA = "LEAVE NO "; break;	}
						Switch(RNG(1,3)){CASE 1:	StringB = "REACH "; break;		 				CASE 2:	StringB = "FIND "; break;		 				CASE 3:	StringB = "MAKE IT TO "; break;	}
						StringA = StrParam(s: StringA, s:"ENEMIES, AND ", s:StringB, s:"THE CHECKPOINT!");
				break;

				CASE adventure_RAISE:
						Switch(RNG(1,3)){CASE 1:	StringA = "CLIMB "; break;		 				CASE 2:	StringA = "MAKE YOUR WAY "; break;		 		CASE 3:	StringA = "GO "; break;	}
						StringA = StrParam(s: StringA, s:"TO THE TOP, BEFORE ", s:FailTextureName(), s:" GETS YOU!");
				break;

				CASE adventure_INVASION:
						StringA = "";
						// see INFOLOGIC
				break;

				CASE adventure_FLOW:
						Switch(RNG(1,3)){CASE 1:	StringA = "RIDE "; break;						CASE 2:	StringA = "FOLLOW "; break;						CASE 3:	StringA = "SURF "; break;	}
						Switch(RNG(1,4)){CASE 1:	StringB = "STAY SHARP!"; break;					CASE 2:	StringB = "DON'T SLOW DOWN!"; break;			CASE 3:	StringB = "KEEP YOUR EYES OPEN!"; break;	CASE 4:	StringB = "AVOID THE OBSTACLES!"; break;}
						StringA = StrParam(s: StringA, s:"THE FLOW AND ", s:StringB);
				break;
				}

			DrawNotification(For_Everyone, StringA, notepose_TOP, notepara_ALIGN, ICON_Mission, StrParam(c:ICON_Mission), "j", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
			}






			a = 0; 		b = 0;
			GAMESTATE = gs_ACTIVE;













			While(GAMESTATE == gs_ACTIVE)
				{

					if(PlayerStatus(-1) <= ps_DEAD) Terminate;	 //if everyone "died" then terminate whole script,


									//COUNT ENEMIES
									Light_ChangeToValue(TIDRAM_EnemyCount, 0);
									counter = ACTORTID_Enemy;
									while (counter < ACTORTID_Enemy + RoundInfo[EnemyCounter])
									//for(i = ACTORTID_Enemy; i < ACTORTID_Enemy + MaxEnemy; i++)
										{
										if ((GetActorZ(counter)>>16) <= RoundInfo[PitFloorHeight])	Thing_Remove(counter);
										if (ClassifyActor(counter) & ACTOR_ALIVE)	Light_ChangeToValue(TIDRAM_EnemyCount, GetSectorLightLevel(TIDRAM_EnemyCount) + 1);
										counter++;
										}


									counter = 0;
									While(counter < MaxPlayers)
										{


											if (RoundInfo[CheckpointReached] == FALSE)
												{

														if 	(
															((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] != adventure_BOSS)	&& (GetSectorLightLevel(TIDRAM_EnemyCount)	<= 0))	|//(ThingCount(0, ACTORTID_Enemy) <= 0))	|
															((AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_BOSS)	&& (ThingCount(0, ACTORTID_Boss)  			<= 0))
															)

															{
																	//If current round requires to beat the enemy and they were beaten then switch to gamestate gs_END immidiatelly
																	if 	(AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByENEMYONLY)
																								{
																								RoundInfo[CheckpointReached] = TRUE;
																								GAMESTATE = gs_END;
																								//log(s:"a");
																								}





																	else	 	//or else if there is a checkpoint that has to be reached, and someone first did it // if (AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByTELEPORT)
																		{
																		if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_MAZE)
																			{
																			//if 	(GetSectorLightLevel(TIDRAM_ExitMarkerA) == 0)	Light_ChangeToValue(TIDRAM_ExitMarkerA, RoundInfo[FinishpointTag]/100);
																			if 	(GetSectorLightLevel(TIDRAM_ExitMarkerB) == 0)	Light_ChangeToValue(TIDRAM_ExitMarkerB, RoundInfo[FinishpointTag] - (GetSectorLightLevel(TIDRAM_ExitMarkerA)*100));
																			}



																				if (PlayerCheckpoint[counter] == RoundInfo[CurrentRound])
																					{
																					//RoundInfo[CheckpointReached] = TRUE;

																							// If First Player to reach Mini Checkpoint, then
																							if (CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, PlayerDiameter, RoundInfo[MiniFinishpoint], 0, 0, 0) == true)
																									{
																									RoundInfo[CheckpointReached] = TRUE;
																									RoundInfo[AdventureCounter] = FlowInverseTime;
																									}





																							// If First Player to reach a normal Checkpoint
																							else if (CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, PlayerDiameter, RoundInfo[FinishpointTAG], 0, 0, 0) == true)
																									{
																									RoundInfo[CheckpointReached] = TRUE;
																									RoundInfo[CheckpointWinner] = counter;
																									PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
																									//ClientScript (counter, "DrawSky", OFF, 0, 0);
																									//if (RoundInfo[CurrentRound] < GAMEINFO[RoundsCount])
																												{
																												TeleportOther(PLAYER_TID + counter, ACTORTID_Hub + counter, true);
																												StringA = StripColors(StrParam(n:counter + 1));

																												b = StrLen(StringA);
																												if (b > 20)
																													{
																													a = 0;	StringB = "";
																													while (a < 20 - 2)
																														{
																														StringB = StrParam(s:StringB, c:GetChar(StringA, a));
																														a++;
																														}
																													StringA = StrParam(s:StringB, s:"..");
																													}


																												DrawNotification(For_Everyone, StrParam(s:StringA, s:" made it to the checkpoint!"), notepose_TOP, notepara_ALIGN, ICON_Checkmark, StrParam(c:ICON_Checkmark), "j", "ERFONT",  OFF, ON, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
																												}

																									a = 0;
																									while (a < MaxPlayers)
																											{
																															//exclude the Checkpoint winner
																											if (a != RoundInfo[CheckpointWinner])
																													if (PlayerStatus(a) == ps_PLAYGROUND)		ClientScript (a, "MSG_Hurry", AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE], 0, 0);

																											a++;
																											}
																									GAMESTATE = gs_END;




																									}

																					}

																		}
																}




												}




											if(GetSectorLightLevel(TIDRAM_JoinTimeLeft) <= 0)
												if (PlayerCheckpoint[counter] == RoundInfo[CurrentRound])
													if (PlayerStatus(counter) == ps_HUB)
														Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);









														// Player is too slow at the FLOW adventure ---------------------------------------------------------------------------------------------------------------------
														if((PlayerStatus(counter) == ps_PLAYGROUND) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW))
																{
																if 	(
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[MiniStartpoint],		0, 0, 0) == false) &&
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[MiniFinishpoint],		0, 0, 0) == false) &&
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[FinishpointTAG],		0, 0, 0) == false) &&
																	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 320, RoundInfo[StartpointTAG],		0, 0, 0) == false)
																	)
																	if ((abs(GetActorVelX(PLAYER_TID + counter)>>16) < 5) && (abs(GetActorVelY(PLAYER_TID + counter)>>16) < 5))  		Thing_Damage(PLAYER_TID + counter, RNG(1,2), MOD_WATER);

																}
/*

														// Player is on the bad Floor ---------------------------------------------------------------------------------------------------------------------
														if 	(GetPort() >= Zandronum)
																if(PlayerStatus(counter) == ps_PLAYGROUND)
																	{

																		if ((GetActorZ(PLAYER_TID + counter)>>16) <= RoundInfo[PitFloorHeight])
																			{
																						if (CheckActorFloorTexture(PLAYER_TID + counter, "F_SKY1"))
																							{
																							ClientScript (counter, "PlayerScreenFade", CR_WHITE, 0.5, 1.0);
																							SpawnForced("MapSpot", GetActorX(PLAYER_TID + counter) + int2fix(SkyfallOffset), GetActorY(PLAYER_TID + counter), GetActorZ(PLAYER_TID + counter) - int2fix(PlayerHeight), ACTORTID_Skyfall + counter, GetActorAngle(PLAYER_TID + counter)>>16);
																							Thing_Move(PLAYER_TID + counter, ACTORTID_Skyfall + counter, TRUE);
																							Thing_Remove(ACTORTID_Skyfall + counter);
																							}

																				else	if (CheckActorFloorTexture(PLAYER_TID + counter, "FLTBLACK"))
																							{
																							ClientScript (counter, "PlayerScreenFade", CR_BLACK, 0.25, 1.0);
																							Thing_Move(PLAYER_TID + counter, ACTORTID_SkyfallInner, TRUE);
																							SetActorAngle(PLAYER_TID + counter, RNG(0,255) << 8);
																							}

																				if (GAMEINFO[Mood] == mood_SPACE)	SetActorProperty(PLAYER_TID + counter, APROP_Alpha, 0.0);
																				Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);


																			}

																	}
*/

															// if some Player entering a teleport in the hub ---------------------------------------------------------------------------------------------------------------------
															if(	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 48, ACTORTID_MainTeleport, 0, 0, 0) == true) && (PlayerCheckpoint[counter] == RoundInfo[CurrentRound]) && (RoundInfo[MiniCheckPoint] == 0))
															{
																if (RoundInfo[PlaygroundReached] == false)
																							{
																								TimeLeft = RoundInfo[TimeGiven];
																								RoundInfo[PlaygroundReached] = true;
																								GAMEINFO[NextTry] = true;
																								Light_ChangeToValue(TIDRAM_RoundMusic, AdventureInfo[RoundInfo[CurrentRound]][adv_MUSIC]);
																							}

																		ClientScript (counter, "ChangeMusic", AdventureInfo[RoundInfo[CurrentRound]][adv_MUSIC], 0, 0);
																		ClientScript (counter, "PlayerScreenFade", CR_WHITE, 0.0, 2.0);
																		Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
																			{
																			CASE adventure_BOSS:
																			ClientScript (counter, "SFX", GetPort(), SFX_BossEnter, StandartVolume);
																			break;
																			}

																		Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_RANDOMEVENT])
																			{
																			/*CASE event_WORM:
																			ClientScript (counter, "MSG_WormsNotify", 0, 0, 0);
																			break;*/
																			CASE event_BOMB:
																			ClientScript (counter, "MSG_BombNotify", 0, 0, 0);
																			break;
																			}
															/*
															//if player didnt buy anything give him enemy locator
															if(GetPort() == Zandronum)
																if(!CheckActorInventory(PLAYER_TID + counter, Ability))
																	GiveActorInventory(PLAYER_TID + counter, Ability, id_EnemyLocator);
															*/





																//Give round weapon
																if (CheckActorInventory(PLAYER_TID + counter, ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_CODE)) == FALSE)
																		{
																			GiveActorInventory(PLAYER_TID + counter, ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_CODE), 1);

																			//if player received hard weap, but doesn't have SSG, give it.
																			if (AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON] > id_SuperShotgun)
																			GiveActorInventory(PLAYER_TID + counter, ActorString(id_SuperShotgun, as_CODE), 1);

																			ClientScript (counter, "MSG_NewWeapon", AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], 0, 0);

																		}


															ClientScript (counter, "DrawSky", ON, GetSectorLightLevel(TIDRAM_Mood)*10 + GetSectorLightLevel(TIDRAM_Location), 0);

															/*if (GAMEINFO[GameTest])*/	TeleportOther(PLAYER_TID + counter, RoundInfo[StartpointTAG], true);
															SetActorAngle(PLAYER_TID + counter, (RNG(0, 255) << 8));
															}


										counter++;

										}


				if (RoundInfo[adventureCounter] == 1)
					{

						if (RoundInfo[MiniCheckpoint] < AdventureInfo[RoundInfo[CurrentRound]][adv_MINICHECKPOINTS])
								{
								if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW)
							//SET SUBSTANCE LINES TEXTURE AND OFFSET-----------------------------------------------------------------------------------
								for (a = 1; a < PlaygroundBlocks;  a++) {
								  if (/*a == RoundInfo[MiniStartpoint]/100 ||*/ a == RoundInfo[MiniFinishpoint]/100 /*|| a == RoundInfo[StartpointTag]/100 || a == RoundInfo[FinishpointTag]/100*/) 	continue;
								SetLineTexture(a, SIDE_FRONT, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								SetLineTexture(a, SIDE_BACK, TEXTURE_MIDDLE, TextureIs (WallRAIStx));
								ACS_NamedExecute("MCR_KillWhileDeploying", 0);
/*										for (b = 0; b < MaxPlayers;  b++)
												if((PlayerStatus(b) == ps_PLAYGROUND) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW))
														{
														if 	(
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniStartpoint],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniFinishpoint],	0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[FinishpointTAG],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[StartpointTAG],		0, 0, 0) == false)
															)
															Thing_Damage(PLAYER_TID + b, InstantDeath, MOD_WATER);

														}
*/







								//Line_SetTextureOffset(a, NO_CHANGE, int2fix(RoundInfo[SubstanceLineOffset]), SIDE_FRONT, TEXFLAG_MIDDLE);
								//Line_SetTextureOffset(a, NO_CHANGE, int2fix(RoundInfo[SubstanceLineOffset]), SIDE_BACK, TEXFLAG_MIDDLE);
																			}



								RoundInfo[MiniCheckpoint]++;
								RoundInfo[adventureCounter] = 0;
								restart;
								}
					}











				if (TimeLeft <= BottomLine)	//That means nobody made it through the checkpoint in time
				{
					counter = 0;
					While(counter < MaxPlayers)
					{
					Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
					counter++;
					}

				Terminate;
				}




/*
     _       _                      _                  _           _     ___   ___  ____
    / \   __| |_   _____ _ __ _ __ | |_ _   _ _ __ ___( )___      | |   / _ \ / _ \|  _ \
   / _ \ / _` \ \ / / _ \ '__| '_ \| __| | | | '__/ _ \// __|     | |  | | | | | | | |_) |
  / ___ \ (_| |\ V /  __/ |  | | | | |_| |_| | | |  __/ \__ \     | |__| |_| | |_| |  __/
 /_/   \_\__,_| \_/ \___|_|  |_| |_|\__|\__,_|_|  \___| |___/     |_____\___/ \___/|_|

*/


			Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
				{
				CASE adventure_BOSS:		break;
				CASE adventure_MAZE:		break;
				CASE adventure_LINEAR:		break;
				CASE adventure_RAISE:




						if (RoundInfo[CurrSubstanceHeight] < RoundInfo[MaxSubstanceHeight] )	//while dummy Substance level is lower than the highest point

								{
										if (RoundInfo[SubstanceMoveTimer] == 0)
											{

											/*
											for (a = 1; a <= PlaygroundBlocks;  a++)
												{
												Line_SetTextureOffset(a, NO_CHANGE, int2fix(1), SIDE_FRONT,		TEXFLAG_MIDDLE|TEXFLAG_ADDOFFSET);
												Line_SetTextureOffset(a, NO_CHANGE, int2fix(1), SIDE_BACK,		TEXFLAG_MIDDLE|TEXFLAG_ADDOFFSET);
												}
											*/
											RoundInfo[CurrSubstanceHeight]++;
											RoundInfo[SubstanceLineOffset]++;
											SetClientSubstanceOffset();
											if (RoundInfo[CurrSubstanceHeight] < 0)		RoundInfo[SubstanceMoveTimer]	=	0;
											else										RoundInfo[SubstanceMoveTimer]	=	SetSubstanceSpeed();	//RoundInfo[SubstanceMoveDelay];
											}

										else											RoundInfo[SubstanceMoveTimer]--;





								}
						else
							{
								if (TimeLeft > PanicTime) TimeLeft = JoinTime;
							}

									// KILL THE PLAYER IF HE's ON OR BELOW THE SUBSTANCE
									counter = 0;
									While(counter < MaxPlayers)
										{
										if((PlayerStatus(counter) == ps_PLAYGROUND) && (GetActorZ(PLAYER_TID + counter) < int2fix(RoundInfo[CurrSubstanceHeight])))
												{
												Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_SLIME);
												ClientScript (counter, "PlayerScreenFade", CR_BLACK, 0.25, 1.0);
												SetActorProperty(PLAYER_TID + counter, APROP_Alpha, 0);
												Thing_Move(PLAYER_TID + counter, ACTORTID_DeathSubstance, TRUE);
												}
										counter++;
										}
				break;

				}






				//log(s:"ACTIVATOR is ", i:ActivatorTID());


				delay(1);
				}




				RoundInfo[MiniCheckpoint] = 0;

				GAMESTATE = gs_END;



/*
  ____   ___  _   _ _   _ ____     __        _____ _   _
 |  _ \ / _ \| | | | \ | |  _ \    \ \      / /_ _| \ | |
 | |_) | | | | | | |  \| | | | |    \ \ /\ / / | ||  \| |
 |  _ <| |_| | |_| | |\  | |_| |     \ V  V /  | || |\  |
 |_| \_\\___/ \___/|_| \_|____/       \_/\_/  |___|_| \_|

*/


			if(GAMESTATE == gs_END)
				{
				PortalVisuals(OFF);
				ACS_NamedTerminate("RandomEvent", 0);
				ACS_NamedExecute("RandomEvent", 0, DOESNT_MATTER);


						if (RoundInfo[CurrentRound] < GAMEINFO[RoundsCount])
						{






											//If it was Boss Adventure or Invasion
											if(AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByENEMYONLY)
												{

												Delay(TakeBreath);

												counter = 0;
												While(counter < MaxPlayers)
													{
													//if a secondary boss has been defeated
													if(PlayerStatus(counter) == ps_PLAYGROUND)
																{
																PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
																TeleportOther(PLAYER_TID + counter, ACTORTID_Hub + counter, true);

																	ClientScript (counter, "ChangeMusic", AdventureInfo[None][adv_MUSIC], 0, 0);
																	//ClientScript (counter, "DrawSky", OFF, 0, 0);



																}
													//someone is at the hub and didnt go through checkpoint by this point
													else if (	(PlayerStatus(counter) == ps_HUB) && (PlayerCheckpoint[counter] <= RoundInfo[CurrentRound])	)
																{
																Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
																ClientScript (counter, "MSG_LateToJoin", 0, 0, 0);
																}
													counter++;
													}

												}



											else if(AccomplishType(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE]) == AccomplishByTELEPORT)
												{
													While(Timeleft > BottomLine)   //Then wait for everyone to give a chance to get out from the playground
															{
															counter = 0;
															While(counter < MaxPlayers)
																{
																//all the other players that enter the checkpoint after the first player
																if (	(CheckActorPosition(PLAYER_TID + counter, pos_ByActorPos, 32, RoundInfo[FinishpointTAG], 0, 0, 0) == true) && (PlayerCheckpoint[counter] <= RoundInfo[CurrentRound]))
																			{

																					PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
																					TeleportOther(PLAYER_TID + counter, ACTORTID_Hub + counter, true);


																					//ClientScript (counter, "DrawSky", OFF, 0, 0);

																					// FIX THIS, need to make a proper condition if cp winner entered, and to apply something to all other the other players at once




																			}

																//someone is at the hub and didnt go through checkpoint by this point
																else if (	(PlayerStatus(counter) == ps_HUB) && (PlayerCheckpoint[counter] <= RoundInfo[CurrentRound])	)
																			{
																			Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
																			ClientScript (counter, "MSG_LateToJoin", 0, 0, 0);
																			}



																counter++;
																}
															delay(1);
															}


													//everyone who was left at the playground when Timeleft reaches Zero
													counter = 0;
													While(counter < MaxPlayers)
													{

														if (PlayerStatus(counter) == ps_PLAYGROUND)
															{
															Thing_Damage(PLAYER_TID + counter, InstantDeath, MOD_UNKNOWN);
															}
													counter++;
													}







												}

						RoundInfo[CurrentRound]++;
						}






/*
  ____ _____  _    ____ _____    __        _____ _   _
 / ___|_   _|/ \  / ___| ____|   \ \      / /_ _| \ | |
 \___ \ | | / _ \| |  _|  _|      \ \ /\ / / | ||  \| |
  ___) || |/ ___ \ |_| | |___      \ V  V /  | || |\  |
 |____/ |_/_/   \_\____|_____|      \_/\_/  |___|_| \_|

*/


				else if (RoundInfo[CurrentRound] >= GAMEINFO[RoundsCount])
						{
						MinigameWinnerIs();


						/*
															_         _
						  ___ __ _ _ ___ ___ _ _    ____ __| |__ _ __| |_
						 (_-</ _| '_/ -_) -_) ' \  (_-< '_ \ / _` (_-< ' \
						 /__/\__|_| \___\___|_||_| /__/ .__/_\__,_/__/_||_|
													  |_|
						*/
						AmbientSound("SFXBOSSF", 127);
						SetHUDSize(HUDX_FULLSCREEN, HUDY_FULLSCREEN, 0);		SetFont("ERICON");
						ScreenFade (For_Everyone, 1.0, CR_WHITE, 0, 0.5, 2.0);

						counter = 0;
						While(counter < MaxPlayers)
							{
							//if a final boss has been defeated
							if((PlayerStatus(counter) == ps_PLAYGROUND) && (RoundInfo[CurrentRound] == GAMEINFO[RoundsCount]))
										{
										PlayerCheckpoint[counter] = RoundInfo[CurrentRound] + 1;
										}
							counter++;
							}


						Set_AllGodmode(true);





						//SETTING THE 'NEXT' STUFF

							SortPlayerScores(0); //DECIDE THE WINNER

							TempSEASON =	ServerInfo[SEASON];
							TempSTAGE = 	ServerInfo[STAGE];
							TempTRY = 		ServerInfo[Try];
/*
     _         _                                     ____  _                    __        ___
    / \  _   _| |_ ___  _ __   __ _ _ __ ___   ___  / ___|| |_ __ _  __ _  ___  \ \      / (_)_ __  _ __   ___ _ __
   / _ \| | | | __/ _ \| '_ \ / _` | '_ ` _ \ / _ \ \___ \| __/ _` |/ _` |/ _ \  \ \ /\ / /| | '_ \| '_ \ / _ \ '__|
  / ___ \ |_| | || (_) | | | | (_| | | | | | |  __/  ___) | || (_| | (_| |  __/   \ V  V / | | | | | | | |  __/ |
 /_/   \_\__,_|\__\___/|_| |_|\__,_|_| |_| |_|\___| |____/ \__\__,_|\__, |\___|    \_/\_/  |_|_| |_|_| |_|\___|_|
                                                                    |___/
*/
							if(IsCompetitive())		//first autoname this record
								{


															FillTheName();
								if (GetPort() == Zandronum)	FillTheNameDB();
								}




/*

     _            _             _               _   _           _     ____  _
    / \   ___ ___(_) __ _ _ __ (_)_ __   __ _  | \ | | _____  _| |_  / ___|| |_ __ _  __ _  ___
   / _ \ / __/ __| |/ _` | '_ \| | '_ \ / _` | |  \| |/ _ \ \/ / __| \___ \| __/ _` |/ _` |/ _ \
  / ___ \\__ \__ \ | (_| | | | | | | | | (_| | | |\  |  __/>  <| |_   ___) | || (_| | (_| |  __/
 /_/   \_\___/___/_|\__, |_| |_|_|_| |_|\__, | |_| \_|\___/_/\_\\__| |____/ \__\__,_|\__, |\___|
                    |___/               |___/                                        |___/

*/
						ServerInfo[TRY] = 1;

						if ((ServerInfo[STAGE] < MaxStages) && (ServerInfo[STAGE] > 0))    // If Stage number < Final Stage
							{
							ServerInfo[STAGE]++;
							}


						else																// If that was a final stage
							{
							ServerInfo[STAGE] = 0;
							ServerInfo[SEASON] = 0;
							}





// REMEMBER THE UPCOMING SEASON/STAGE/NUM numbers

						Switch(GetPort())
							{


							Case Zandronum:

								BeginDBTransaction();
								SetDBEntry("ServerInfo", "SEASON", 	ServerInfo[SEASON]);
								SetDBEntry("ServerInfo", "STAGE",  	ServerInfo[STAGE]);
								SetDBEntry("ServerInfo", "TRY",  	ServerInfo[TRY]);
								EndDBTransaction();
								break;

							case ZDaemon:
								//Reset Last Winner
								for (a = 0; a < MaxPortNameCharsZDA;	a++)		MemoOwner[a]		= 0;
								for (a = 0; a < MaxMemoOwnerMSGChars;  a++)			MemoOwnerMSG[a]		= 0;


								//fill the new one
								StringA = StrParam(n:GAMEINFO[WinnerPlayerNum] + 1);
								for (a = 0; a < StrLen(StringA);  a++)
									{
									Light_ChangeToValue(TIDRAM_Temp, GetChar(StringA, a));
									MemoOwner[a] = GetSectorLightLevel(TIDRAM_Temp);
									}
								MemoOwner[MemoOwnerType] = AsLastWinner;


								break;


							}




/*

  _____                        ____  _
 |  ___| __ ___  ___ _______  |  _ \| | __ _ _   _  ___ _ __ ___
 | |_ | '__/ _ \/ _ \_  / _ \ | |_) | |/ _` | | | |/ _ \ '__/ __|
 |  _|| | |  __/  __// /  __/ |  __/| | (_| | |_| |  __/ |  \__ \
 |_|  |_|  \___|\___/___\___| |_|   |_|\__,_|\__, |\___|_|  |___/
                                             |___/

*/

						//Freeze Players
						Switch(GetPort())
							{
							Case Zandronum: Case GZDoom:

								SetPlayerProperty(1, true, PROP_TOTALLYFROZEN);
								break;
							}

						Delay(TakeBreath);

						SetMusic(StrParam(s:"D_MUS", i:AdventureInfo[mus_CALM][adv_MUSIC]));
						Light_ChangeToValue(TIDRAM_RoundMusic, 	AdventureInfo[mus_CALM][adv_MUSIC]);

/*
   ____              _ _ _
  / ___|_ __ ___  __| (_) |_ ___
 | |   | '__/ _ \/ _` | | __/ __|
 | |___| | |  __/ (_| | | |_\__ \
  \____|_|  \___|\__,_|_|\__|___/

*/

if (TempSTAGE <= 0)		//random game

						{
						if (ServerInfo[CREDITS] <= 0)
									{
									a = TRUE;
									ServerInfo[CREDITS] = 1;
									}
						else
									{
									ServerInfo[CREDITS]--;
									a = FALSE;
									}
						}


else					a = TRUE;	//competitive game


			if (a)
				{



						ScreenFade (For_Everyone, 1.0, CR_WHITE, 0, 0.5, 2.0);
						Delay(Sec/4);
						Light_ChangeToValue(TIDRAM_WinCamera, 100);	//Switch Camera to Skyboxy


							//Show Credits
							for(a = 0; a < MaxPlayers; a++)		ClientScript (a, "Cutscene", 1, 0, 0);


							a = CREDITS_StartAt;
							While(a > -CREDITS_StartAt/2)
							{
								a--;
								delay(1);
							}



				}





/*
  ____  _____ ____ ___ ____ _____ _____ ____    _____ _   _ _____  __        _____ _   _ _   _ _____ ____
 |  _ \| ____/ ___|_ _/ ___|_   _| ____|  _ \  |_   _| | | | ____| \ \      / /_ _| \ | | \ | | ____|  _ \
 | |_) |  _|| |  _ | |\___ \ | | |  _| | |_) |   | | | |_| |  _|    \ \ /\ / / | ||  \| |  \| |  _| | |_) |
 |  _ <| |__| |_| || | ___) || | | |___|  _ <    | | |  _  | |___    \ V  V /  | || |\  | |\  | |___|  _ <
 |_| \_\_____\____|___|____/ |_| |_____|_| \_\   |_| |_| |_|_____|    \_/\_/  |___|_| \_|_| \_|_____|_| \_\

*/

		if (TempSEASON)		//IsCompetitive()
			if (TempSTAGE)
				{

				/*
						   __   _ __
				 ___  ____/ /  (_) /_
				/ _ \/ __/ _ \/ / __/
				\___/_/ /_.__/_/\__/

				*/

				ChangeCamera(0, 1, 0);

				//for(a = 0; a < MaxPlayers; a++)			if (a != GAMEINFO[WinnerPlayerNum])			ClientScript (a, "WaitingForWinner", 0, 0, 0);

				Light_ChangeToValue(TIDRAM_WinCamera, GAMEINFO[WinnerPlayerNum]);	//Switch Camera on to the player

/*
  _   _        __                        __        ___
 | | | |_ __  / _|_ __ ___  ___ _______  \ \      / (_)_ __  _ __   ___ _ __
 | | | | '_ \| |_| '__/ _ \/ _ \_  / _ \  \ \ /\ / /| | '_ \| '_ \ / _ \ '__|
 | |_| | | | |  _| | |  __/  __// /  __/   \ V  V / | | | | | | | |  __/ |
  \___/|_| |_|_| |_|  \___|\___/___\___|    \_/\_/  |_|_| |_|_| |_|\___|_|

*/


							if (GetPort() >= Zandronum)	SetPlayerProperty(1, false, PROP_TOTALLYFROZEN);


/*
  ___ _   _ ____  _   _ _____      _    ____  _____    _
 |_ _| \ | |  _ \| | | |_   _|    / \  |  _ \| ____|  / \
  | ||  \| | |_) | | | | | |     / _ \ | |_) |  _|   / _ \
  | || |\  |  __/| |_| | | |    / ___ \|  _ <| |___ / ___ \
 |___|_| \_|_|    \___/  |_|   /_/   \_\_| \_\_____/_/   \_\

*/






								StringA = "";
								GAMEINFO[InputNameTime] = GAMEINFO[MaxNameChars]*20;
								TeleportOther(PLAYER_TID + GAMEINFO[WinnerPlayerNum], ACTORTID_InputArea, true);


//									SetFont("ERFONT");	SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
//									HudMessageBold(s:"Always input the same name to\n\nincrement your season score!" ;		HUDMSG_FADEOUT, 0, COLORTEXT_MAIN, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/8), 8.0, 4.0);

								if (GetPort() == Zandronum)
									a = PlayerIsLoggedIn(GAMEINFO[WinnerPlayerNum]); //1



								While ((GAMEINFO[InputNameTime] > BottomLine) && (ClassifyActor(PLAYER_TID + GAMEINFO[WinnerPlayerNum]) & ACTOR_ALIVE))
									{
									if (GetPort() == Zandronum)								//if player logged in during the input phase
										if ((PlayerIsLoggedIn(GAMEINFO[WinnerPlayerNum])) && (!a));
												{
												a = PlayerIsLoggedIn(GAMEINFO[WinnerPlayerNum]);
												//log(i:a);
												//FillTheName();
												FillTheNameDB();
												}




									counter = 0; StringA = "";	StringB = "";
									//if (GetPort() == Zandronum)		if (!PlayerIsLoggedIn(GAMEINFO[WinnerPlayerNum])) 	{StringA = "~"; 	counter = 1;	if (!InputNameTurn) InputNameTurn = 1;}

									While(counter < GAMEINFO[MaxNameChars])
											{
											//if (WinnerNames[InputHeader + counter] == 32)		StringA = StrParam(s:"\ck", s:StringA, s:"\cj-");
											StringA = StrParam(s:"\ck", s:StringA, c:WinnerNames[InputHeader + counter]);


											//if (WinnerNames[InputHeader + counter] != 32)		StringA = StrParam(s:"\ck", s:StringA, c:WinnerNames[InputHeader + counter]);
											//else 												StringA = StrParam(s:"\ck", s:StringA, s:"\cj-");
											if (counter == InputNameTurn )	StringB = StrParam(s:"\cj", s:StringB, s:"^");
											else							StringB = StrParam(s:"\cj", s:StringB, s:"_");

											counter++;
											}


									//SetActivator
									SetFont("ERFONT");
									SetHUDSize(HUDX_BIG, HUDY_BIG, 0);			HudMessageBold(s:StringA, s:"\n\cj", s:StringB ;		HUDMSG_PLAIN, HUDid_InputName, CR_YELLOW, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2), 1.0 );
									if(InputNameTurn < MinAllowedInput)
											{
											//if ((InputNameTurn <= 0) && (WinnerNames[InputHeader + 0] == 126)) InputNameTurn = 1;	// Dont delete ~ if it exists
											ForceAutoName = true;
											ClientScript (counter, "MSG_MinLettersReq", MinAllowedInput, 0, 0);
											}

									else if ((InputNameTurn == MinAllowedInput) &&  ((WinnerNames[InputHeader + 0]== 32) || (WinnerNames[InputHeader + 2]== 32)))
											{
											ForceAutoName = true;
											ClientScript (counter, "MSG_ManyBlanks", 0, 0, 0);
											}

									else	ForceAutoName = false;


											//ClientScript (counter, "MSG_InputSameName", MinAllowedInput, 0, 0);


									//SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, 0);
									//HudMessageBold(s:"\cl", s:StringB;							HUDMSG_FADEOUT, HUDid_INPUTNOTE, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(Y_TOP_LETTER), 1.0, 1.0 );
									//SetActivator
									delay(sec/2);
									}




								//Checking conditions of the inputed name
									if (ForceAutoName == true) // if only 2 chars inputed
										{

																	FillTheName();
										if (GetPort() == Zandronum)	FillTheNameDB();
										}


								//Reveal winner's name in the end as this  V
								counter = 0;	StringA = "";
								while(counter < GAMEINFO[MaxNameChars])
								{
								StringA = StrParam(s:StringA, c:WinnerNames[InputHeader + counter]);
								counter++;
								}



								if ((TempSTAGE == MaxStages) && (GetPort() != GZDoom))		NewLegend(TempSEASON); //Create a new monument at the end of the season


								//A Zdaemon message to restore progress via console upon server restart, yeah clunky as f, but what can u do with an oldass port
								Switch(GetPort())
									{
									CASE ZDaemon:	ZDA_StatsInfo();	break;
									/*CASE Zandronum:
											{

											counter = 0;	StringA = "";
											while(counter < GAMEINFO[MaxNameChars])
												{
												StringA = StrParam(s:StringA, c:WinnerNames[InputHeader + counter]);
												counter++;
												}


											BeginDBTransaction();
											SetDBEntryString(StrParam(s:"DB_Season", i:TempSEASON, s:"Winners"), StrParam(s:"DB_WinnerOfStage", i:TempSTAGE), StringA);
											EndDBTransaction();

											}
									break;*/
									}








				}






				ScreenFade (For_Everyone, 1.0, CR_WHITE, 0, 0.5, 2.0);
				StringA = CurrentName[GAMEINFO[WinnerPlayerNum]];
				//log(s:"winner is ", s:CurrentName[GAMEINFO[WinnerPlayerNum]]);

				if (tempSTAGE > 0)
									{



									if(GetPort() == Zandronum)
										{
										BeginDBTransaction();

													if (GetChar(GetDBEntryString(StrParam(s:"Season", i:TempSEASON), 		StrParam(i:TempSTAGE, s:"___StageWinner_ID")), 0)	!= 126)
															StringA = GetDBEntryString(	"PlayerInfo", StrParam(s:"id_", i:					GetDBEntry(StrParam(s:"Season", i:TempSEASON), 		StrParam(i:TempSTAGE, s:"___StageWinner_ID"))					, s:"___CURRENTNAME"));

										EndDBTransaction();
										}


									StringB = StrParam(s:" OF STAGE ", i:TempSTAGE);
									SetHUDSize(HUDX_VERYBIG, HUDY_VERYBIG, 0);
									a = int2fix(HUDX_VERYBIG/2);
									b = int2fix(HUDY_VERYBIG/2);
									}
				else
									{
									StringB = "";
									//StringA = StripColors(StrParam(n:GAMEINFO[WinnerPlayerNum] + 1));
									SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
									a = int2fix(HUDX_BIG/2);
									b = int2fix(HUDY_BIG/2);
									}

				StringA = StripColors(StringA);
				StringA = StrToUpper(StringA);


				Light_ChangeToValue(TIDRAM_WinCamera, 99);
				//ChangeCamera(ACTORTID_SkyboxCamera, 1, 0);
				//-----------------------------------------------------------------
				SetFont("ERFONT");
				HudMessageBold(s:StringNoEdgeSpaces(StringA);			HUDMSG_PLAIN, 0, CR_YELLOW, 	a, b, 66.0 );
				//-----------------------------------------------------------------
				SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
				HudMessageBold(s:"IS THE WINNER", s:StringB, s:"!";		HUDMSG_PLAIN, 0, CR_WHITE, 		int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2 + HUDY_BIG/16), 66.0 );
				if (GetPort() >= Zandronum)
					{
					SetFont(StrParam(s:"FLAG", i:PlayerFlag[GAMEINFO[WinnerPlayerNum]]));
					HudMessageBold(s:"A";								HUDMSG_PLAIN, 0, CR_UNTRANSLATED, int2fix(HUDX_BIG/2), int2fix(HUDY_BIG/2 - HUDY_BIG/8), 66.0 );
					}
				AmbientSound("SFXWIN", 127);




				delay(SEC*3);

				Light_ChangeToValue(TIDRAM_MapReset, TRUE);

				delay(SEC*3);


				//EXIT MAP
				ScreenFade (For_Everyone, 1.0, CR_BLACK, 2.0, 999.0, 0.0);
				delay(SEC*2);




				Switch(GetPort())
					{
					CASE ZDaemon:
					CASE GZDoom:
					Exit_Normal(0);
					break;

					CASE Zandronum:
					if (IsNetworkGame())	ServerInfo[ZANmapwin] = TRUE;
					Exit_Normal(0);
					break;
					}

				terminate;

				}



		RoundInfo[StartpointTag]		=		ImpossibleNum;
		RoundInfo[FinishpointTag]		=		ImpossibleNum;
		RoundInfo[MiniStartpoint] 		= 		ImpossibleNum;
		RoundInfo[MiniFinishpoint] 		= 		ImpossibleNum;


		restart;

		}
}







/*
   ____ _   _ _____ ____   ____ _____ _   _ _____
  / ___| | | |_   _/ ___| / ___| ____| \ | | ____|
 | |   | | | | | | \___ \| |   |  _| |  \| |  _|
 | |___| |_| | | |  ___) | |___| |___| |\  | |___
  \____|\___/  |_| |____/ \____|_____|_| \_|_____|

*/
function str GetYearCopyright (void)
{
str Year = "2022";
Switch (GetPort())
	{
	CASE GZDoom:
	CASE ZDaemon: Year = "2022"; break;
	CASE Zandronum:

	if (StrToNum(Strftime (SystemTime(), "%Y", false)) 		> 		StrToNum(Year))		Year = StrParam(s:Year, 	s:" - ",  	s:Strftime (SystemTime(), "%Y", false));

	break;
	}

return Year;
}


function str AuthorName (void)
{
str Result = "";
Switch(RNG(0, 6))
	{
	case 0:	Result = 	"~~~~~~~~~~Zeberpal~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
	case 1:	Result = 	"~~~~~~~~~~some~guy~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
	case 2:	Result = 	"~~~~~~~~~~creator~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
	case 3:	Result = 	"~~~~~~~~~~You-Know-Who~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
	case 4:	Result = 	"~~~~~~~~~~He-Who-Must-Not-Be-Named~~~~~~~~~~~~~~~~~~~~~~~";		break;
	case 5:	Result = 	"~~~~~~~~~~some~russian~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
	case 6:	Result = 	"~~~~~~~~~~some~freak~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
	}
return Result;
}


SCRIPT "Cutscene" (int SSpecial) CLIENTSIDE
{
int VERTendency = RandomNoZero(-1, 1);
int ANGtendency = RandomNoZero(-1, 1);



SetActorAngle(ACTORTID_SkyboxCamera, RNG(0,255) << 8);
SetActorPitch(ACTORTID_SkyboxCamera, RNG(FREELOOK_LIMIT_UP/2,FREELOOK_LIMIT_DOWN/2) << 8);

int CREDITS_VERTICITY = CREDITS_StartAt;


Thing_Remove(ACTORTID_SkyChant);

While(CREDITS_VERTICITY > -CREDITS_StartAt/2)
	{
	ChangeCamera(ACTORTID_SkyboxCamera, 0, 0);
	if ((GetActorPitch(ACTORTID_SkyboxCamera) >> 8) < FREELOOK_LIMIT_UP/2)		VERTendency = 1;
	if ((GetActorPitch(ACTORTID_SkyboxCamera) >> 8) > FREELOOK_LIMIT_DOWN/2)	VERTendency = -1;


	SetActorAngle(ACTORTID_SkyboxCamera, GetActorAngle(ACTORTID_SkyboxCamera) + 0.0005 * ANGtendency);
	SetActorPitch(ACTORTID_SkyboxCamera, GetActorPitch(ACTORTID_SkyboxCamera) + (0.0001 * VERTendency));



Switch(SSpecial)
	{
	CASE 1:

SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
SetFont("ERSPACE");
HudMessage(
s:"\cg~~~~~CREATED~BY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Zeberpal~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",

s:"\n\n\n\n",

s:"\cg~~~~~CLASSIC~[LA]~BY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~FLUNKY~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",

s:"\n\n\n\n\n",

s:"\cg~~~~~THANKS~FOR~HELP~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Kaminsky~~~~~~~~~~~~~~~~DrinkyBird~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~ZeroDev~~~~~~~~~~~~~~~~~TDRR~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Agent~Ash~~~~~~~~~~~~~~~Flambeau~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~buu342~~~~~~~~~~~~~~~~~~phantombeta~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~TheMisterCat~~~~~~~~~~~~UberGewei~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~WaTaKiD~~~~~~~~~~~~~~~~~Trillster~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Kamz~~~~~~~~~~~~~~~~~~~~MVICE~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Popsoap~~~~~~~~~~~~~~~~~Suplex~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Iko~~~~~~~~~~~~~~~~~~~~~Kaapeli47~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Penguin~~~~~~~~~~~~~~~~~Binary~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Arkore~~~~~~~~~~~~~~~~~~Necrodoom~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~AF-Domains~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cg~~~~~THANKS~FOR~RESOURCES~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Batandy~~~~~~~~~~~~~~~~~Captain Red~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Gez~~~~~~~~~~~~~~~~~~~~~gamebanana.com~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cg~~~~~THANKS~FOR~TESTING~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~DEA~~~~~~~~~~~~~~~~~~~~~Aliens~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~Ludwig~~~~~~~~~~~~~~~~~~Sonya~(ZD)~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~MVICE~~~~~~~~~~~~~~~~~~~NinjaAbes~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~FatalAngel~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~..and everyone I might have forgotten!~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cj~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cr~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n",
s:"\cr~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n"



;HUDMSG_PLAIN, HUDid_CLIENTCREDITS, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), ClientMsgDelay);


SetFont("ERSPACE");	// YEAR
HudMessage(
s:"\n\n",
s:"\n\n",

s:"\n\n",
s:"\n\n",

s:"\n\n",
s:"\n\n",

s:"\n\n",
s:"\n\n",

s:"\n",

s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\n\n",
s:"\cj", s:GetYearCopyright(), s:" @ ALL RIGHTS VIOLATED\n\n",
s:"\n\n"



;HUDMSG_PLAIN, HUDid_CLIENTCREDITEND, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), ClientMsgDelay);








SetFont("ERTIT1"); // UDB LOGO
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~!{#$%&'()*+,-./01~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~23456789:;<=>?@AB~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~CDEFGHIJKLMNOPQRS~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~TUVWXYZ[}]^_`abcd~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~efghijklmnopqrstu~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~vwxyz~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT1, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), ClientMsgDelay);






SetFont("ERTIT2"); // ZDAEMON , LAWORLDS
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~!#$%&'()*+,-.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~/0123456789:;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~<=>?@ABCDEFGH~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~IJKL~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MNOPQ~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RSTUVWXYZ[]^~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`abcdefghijk~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT2, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), ClientMsgDelay);


SetFont("ERTIT3"); // DE, Zandro1
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~!#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~$%&~*+,~~~~~~~~~~~~Z[]^_~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~'()~-./01234~~~~~~`abcdef~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~56789:;<~~~~~~ghijklm~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~=>?~~~~~~~~~~~~~~~nopqrst~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~@ABCDEFGHIJKL~~~~~uvw~xy~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~MNOPQRSTUVWXY~~~~~~z{|}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT3, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), ClientMsgDelay);


SetFont("ERTIT4"); // Slade, Zandro2
HudMessage(
s:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-./01~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2345678~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~9:;<=>?~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@ABCDEF~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GHIJKLM~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~NOPQRST~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~UVWXYZ[~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~]^_`abc~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~defghij~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~##~~~~k##~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~$%&'()*+,~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~#########~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n",
s:"\cc~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";HUDMSG_PLAIN, HUDid_CLIENTCREDTIT4, CR_UNTRANSLATED, int2fix(HUDX_MEDIUM/2), int2fix(CREDITS_VERTICITY), ClientMsgDelay);





	CREDITS_VERTICITY--;
	break;

	CASE 2:
	DemoMessage(0);
	break;
	}
	delay(1);
	}

}

/*
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  ______   ______   .__   __. .___________.    ___       __  .__   __.  _______ .______                _______   _______ .______    __        ______   ____    ____  _______.
 /      | /  __  \  |  \ |  | |           |   /   \     |  | |  \ |  | |   ____||   _  \              |       \ |   ____||   _  \  |  |      /  __  \  \   \  /   / /       |
|  ,----'|  |  |  | |   \|  | `---|  |----`  /  ^  \    |  | |   \|  | |  |__   |  |_)  |             |  .--.  ||  |__   |  |_)  | |  |     |  |  |  |  \   \/   / |   (----`
|  |     |  |  |  | |  . `  |     |  |      /  /_\  \   |  | |  . `  | |   __|  |      /              |  |  |  ||   __|  |   ___/  |  |     |  |  |  |   \_    _/   \   \
|  `----.|  `--'  | |  |\   |     |  |     /  _____  \  |  | |  |\   | |  |____ |  |\  \----.         |  '--'  ||  |____ |  |      |  `----.|  `--'  |     |  | .----)   |
 \______| \______/  |__| \__|     |__|    /__/     \__\ |__| |__| \__| |_______|| _| `._____|         |_______/ |_______|| _|      |_______| \______/      |__| |_______/



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*/








function int SetEnemy (int BlockCounter, int Direction, int Tag, int Angle, int Difficulty)
{
bool DontSpawn;
int Deelay 		= 1;
Tag				= TagAt (BlockCounter, Direction, Tag);
int Enemy, Marine, Color;
Difficulty 		= WithinHundred(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY] + Difficulty);

		if 		((Difficulty <=   0) && (Difficulty <  10))		{	Enemy = RNG(id_Zombieman, 									id_Arachnotron		);		Marine = RNG(id_MarinePlasma, 	id_MarineBerserk	);		}
else 	if 		((Difficulty >=  10) && (Difficulty <  20))		{	Enemy = RNG(id_Imp, 										id_Archvile			);		Marine = RNG(id_MarineBerserk, 	id_MarineChaingun	);		}
else 	if 		((Difficulty >=  20) && (Difficulty <  30))		{	Enemy = RNG(id_Demon,										id_SpiderMastermind	);		Marine = RNG(id_MarineChaingun, id_MarineRocket		);		}
else 	if 		((Difficulty >=  30) && (Difficulty <  40))		{	Enemy = RNG(id_HeavyWeaponDude,								id_Railgunner		);		Marine = RNG(id_MarineRocket, 	id_MarineBFG		);		}
else 	if 		((Difficulty >=  40) && (Difficulty <  50))		{	Enemy = RNG(id_Spectre,										id_Cyberdemon		);		Marine = id_MarineBFG;										}
else 	if 		((Difficulty >=  50) && (Difficulty <  60))		{	Enemy = RNG(id_Cacodemon,									id_HellKnight		);		Marine = RNG(id_MarineBFG, 		id_MarineShotgun	);		}
else 	if 		((Difficulty >=  60) && (Difficulty <  70))		{	Enemy = RNG(id_HellKnight,									id_BaronOfHell		);		Marine = id_MarineShotgun;									}
else 	if 		((Difficulty >=  70) && (Difficulty <  80))		{	Enemy = RNG(id_Mancubus,									id_Arachnotron	 	);		Marine = RNG(id_MarineShotgun, 	id_MarineRailgun	);		}
else 	if 		((Difficulty >=  80) && (Difficulty <  90))		{	Enemy = RNG(id_Arachnotron,									id_Archvile 		);		Marine = id_MarineRailgun;									}
else 	if 		((Difficulty >=  90) && (Difficulty < 100))		{	Enemy = RNG(id_Archvile,									id_Cyberdemon		);		Marine = RNG(id_MarineRailgun, 	id_MarineSSG		);		}
else 	if 		(Difficulty	 >= 100)							{	Enemy = RNG(id_Railgunner,									id_Cyberdemon		);		Marine = id_MarineSSG;										}

Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])
	{
	CASE adventure_BOSS:
	CASE adventure_MAZE:
	CASE adventure_LINEAR:
	CASE adventure_RAISE:
	CASE adventure_FLOW:
	Enemy = Enemy;
	DontSpawn = FALSE;
	break;

	CASE adventure_INVASION:
	if ((BlockCounterAtTheEdge(ToRIGHT,  BlockCounter) == TRUE) | (BlockCounterAtTheEdge(ToDOWN,  BlockCounter) == TRUE))	DontSpawn = FALSE;
	else DontSpawn = TRUE;
	Enemy = Marine;

	break;
	}





RefreshSpotHeight(refreshspot_DEFAULT, Tag);

if (Angle == DOESNT_MATTER)	Angle = Random(0, 256);
else						Angle = ActorAngle(Angle, Direction, BYTE);

if (RoundInfo[EnemyCounter] < MaxEnemy)
		{
		if (!DontSpawn)
				{

				SpawnSpotForced(ActorString(Enemy, as_CODE), Tag, ACTORTID_Temp, Angle);
				if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_INVASION)
						{
							Switch(Enemy)
								{
								CASE id_MarinePlasma:	Color = tc_BLUE;	break;
								CASE id_MarineBerserk:	Color = tc_PINK;	break;
								CASE id_MarineChaingun:	Color = tc_PEACH;	break;
								CASE id_MarineRocket:	Color = tc_YELLOW;	break;
								CASE id_MarineBFG:		Color = tc_GREEN;	break;
								CASE id_MarineShotgun:	Color = tc_BROWN;	break;
								CASE id_MarineRailgun:	Color = tc_GREY;	break;
								CASE id_MarineSSG:		Color = tc_RED;		break;
								}
						Thing_SetTranslation(ACTORTID_Temp, Color);

						Tag = StrParam(i:((FixedDiv(Int2Fix(GetActorProperty(ACTORTID_Boss, APROP_Health)), Int2Fix(AdventureInfo[RoundInfo[CurrentRound]][adv_BOSSMAXHP]))* 100) >> 16), s:"%");

						Tag = FixedMul(int2fix(AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]), 0.01);
						//if (Enemy == id_MarineRailgun)	Tag = FixedMul(Tag, 0.125);
						SetActorProperty(ACTORTID_Temp, APROP_Speed, FixedMul(GetActorProperty(ACTORTID_Temp, APROP_SPEED), 1.0 + Tag));	//		RNG(1.5, 2.0)

						}



				Thing_ChangeTID(ACTORTID_Temp, ACTORTID_Enemy + RoundInfo[EnemyCounter]);
				RoundInfo[EnemyCounter]++;

				}


		}

RoundInfo[EnemyAmmo] += GetEnemyHealth (Enemy);




return Deelay;
}





function void TimeGive (int Plus)
{
RoundInfo[TimeGiven] += Plus;
}




function void ReloadObstacles (void)
{
for(int i = 0; i < MaxObstacles; i++)		ContainerObstacle[i] = None;
}



function int DifficultyObs (void)
{
int Result = AdventureInfo[RoundInfo[CurrentRound]][adv_DIFFICULTY]/10;
if (Result >= 10)	Result = 9;
return Result;
}


function int PickObstacle (void)
{
int Pick;
int Result = -1;


//for (int i = 0; i < MaxObstacles;  i++)
while(Result < 0)
	{
	Pick = RNG(0, MaxObstacles - 1);
	if (ContainerObstacle[Pick]	== FALSE)	{ContainerObstacle[Pick] = TRUE;	Result = Pick;}
	}
return Result;
}





Script "TELEPORTBLOCK" (int BlockCounter, int Direction, int SpecialBlock )
{
int ContainerType = OneBlock;
int counter;
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
while(counter < 8)
		{
		counter++;
		delay(	SetArea 		(area_FLOOR, 				ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatSECOtx), None));
		delay(	SetArea 		(area_CEILING, 				ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[GlobalCeilingHeight], 		TextureIs(CeilBASEtx), None));
		}


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Switch(SpecialBlock)
			{
			CASE StartBlock:
			RoundInfo[StartpointTAG] = TagAt (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, BlockCenter);
			Light_ChangeToValue(TIDRAM_StartPoint, RoundInfo[StartpointTAG]/100);
			ChangeFloor(RoundInfo[StartpointTAG],  "GATE4");
			/*
					   __      _ __
			  ___ ___ / /_    (_) /____ __ _
			 (_-</ -_) __/   / / __/ -_)  ' \
			/___/\__/\__/   /_/\__/\__/_/_/_/
														-------------------------------------------------------------
			*/

			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 0, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 1, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 2, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 8, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	16, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	47, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	55, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	63, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	62, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	61, GetAmmoType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 7, GetHealthType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	15, GetHealthType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	56, GetHealthType()	));
			delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	48, GetHealthType()	));

			//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			break;

			CASE FinishBlock:
			RoundInfo[FinishpointTAG] = TagAt (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, BlockCenter);		Light_ChangeToValue(TIDRAM_ExitMarkerA, RoundInfo[FinishpointTag]/100);
			ChangeFloor(RoundInfo[FinishpointTAG],  "GATE1");
			break;
			}



Deploying = false;
}


/*


  1111111                 tttt                                                        tttt
 1::::::1              ttt:::t                                                     ttt:::t
1:::::::1              t:::::t                                                     t:::::t
111:::::1              t:::::t                                                     t:::::t
   1::::1        ttttttt:::::ttttttt        eeeeeeeeeeee        ssssssssss   ttttttt:::::ttttttt
   1::::1        t:::::::::::::::::t      ee::::::::::::ee    ss::::::::::s  t:::::::::::::::::t
   1::::1        t:::::::::::::::::t     e::::::eeeee:::::eess:::::::::::::s t:::::::::::::::::t
   1::::l        tttttt:::::::tttttt    e::::::e     e:::::es::::::ssss:::::stttttt:::::::tttttt
   1::::l              t:::::t          e:::::::eeeee::::::e s:::::s  ssssss       t:::::t
   1::::l              t:::::t          e:::::::::::::::::e    s::::::s            t:::::t
   1::::l              t:::::t          e::::::eeeeeeeeeee        s::::::s         t:::::t
   1::::l              t:::::t    tttttte:::::::e           ssssss   s:::::s       t:::::t    tttttt
111::::::111           t::::::tttt:::::te::::::::e          s:::::ssss::::::s      t::::::tttt:::::t
1::::::::::1           tt::::::::::::::t e::::::::eeeeeeee  s::::::::::::::s       tt::::::::::::::t
1::::::::::1             tt:::::::::::tt  ee:::::::::::::e   s:::::::::::ss          tt:::::::::::tt
111111111111               ttttttttttt      eeeeeeeeeeeeee    sssssssssss              ttttttttttt



*/



Script "DEPLOY_1" (int BlockCounter, int Direction)
{
//if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])	for(int c = 0; c < 64; c++)		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
//ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "TESTFLA1");
int Tag, counter;
int ContainerType = OneBlock;


DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  2,  2, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  3,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	7,  7,  7, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



/*
               _ __
   _________  (_) /
  / ___/ __ \/ / /
 (__  ) /_/ / / /
/____/\____/_/_/

*/				if (RNG(false, true))		delay(	SetSoil 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction));




//------  SET COAL  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if (RNG(false, true))		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  2,  3, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
if (RNG(false, true))		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  5,  6, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
if (RNG(false, true))		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  1,  1, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
if (RNG(false, true))		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	6,  8,  8, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);

if (	(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] != adventure_BOSS))
	{
	if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 23, ANG_to_LEFT, 		35	));
	if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 40, ANG_to_RIGHT, 		75	));
	}


Deploying = false;
}


//Doh
	/*


	  1111111          1111111
	 1::::::1         1::::::1
	1:::::::1        1:::::::1
	111:::::1        111:::::1
	   1::::1           1::::1
	   1::::1           1::::1
	   1::::1           1::::1
	   1::::l           1::::l
	   1::::l           1::::l
	   1::::l           1::::l
	   1::::l           1::::l
	   1::::l           1::::l
	111::::::111     111::::::111
	1::::::::::1     1::::::::::1
	1::::::::::1     1::::::::::1
	111111111111     111111111111


	*/


Script "DEPLOY_11" (int BlockCounter, int Direction)
{
int Tag, counter;
int ContainerType = OneBlock;
ReloadObstacles();

DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	4,  3,  7, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  4,  4, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None));
delay(	SetArea 		(area_CEILING, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	4,  3,  7, RoundInfo[CurrFloorHeight] + 256, 	TextureIs(CeilBASEtx), None));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

int EmitTag = 65;	int DevourTag = 88;		int ProjAngle = ANG_to_LEFT;	int AddHeight = None;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 84;		DevourTag = 69;			ProjAngle = ANG_to_RIGHT;		AddHeight = None;

delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 79;		DevourTag = 92;			ProjAngle = ANG_to_UP;			AddHeight = None;

delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 88;		DevourTag = 65;			ProjAngle = ANG_to_RIGHT;		AddHeight = None;

delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __      _ __
  ___ ___ / /_    (_) /____ __ _
 (_-</ -_) __/   / / __/ -_)  ' \
/___/\__/\__/   /_/\__/\__/_/_/_/
											-------------------------------------------------------------
*/

delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	36, item_RANDOM));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __
  ___ ___ / /_    ___ ___  ___ __ _  __ __
 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
                                   /___/  	-------------------------------------------------------------
*/


delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	0, ANG_to_RightDown,  		0	+ RandomRange(10)));
delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, ANG_to_DownLeft, 		50	));
delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 56, ANG_to_UpRight, 			50	));
delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 63, ANG_to_LeftUp,			0	+ RandomRange(10)));

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  2,  2, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  7,  7, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));

if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  3,  3, RoundInfo[CurrFloorHeight] + 256, 	TextureIs(FlatSECOtx), None));

Deploying = false;
}




//Doh
/*


  1111111         222222222222222
 1::::::1        2:::::::::::::::22
1:::::::1        2::::::222222:::::2
111:::::1        2222222     2:::::2
   1::::1                    2:::::2
   1::::1                    2:::::2
   1::::1                 2222::::2
   1::::l            22222::::::22
   1::::l          22::::::::222
   1::::l         2:::::22222
   1::::l        2:::::2
   1::::l        2:::::2
111::::::111     2:::::2       222222
1::::::::::1     2::::::2222222:::::2
1::::::::::1     2::::::::::::::::::2
111111111111     22222222222222222222

*/


Script "DEPLOY_12" (int BlockCounter, int Direction)
{
int Tag, counter;
int ContainerType = OneBlock;

DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);


/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	2,  3,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  6,  8, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	8,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  1,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));

if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  3,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
if (RNG(false, true))	{	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	29, ANG_to_LEFT,  		0	+ RandomRange(10)));
						}
/*SAFE PLACE*/				delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	1,  1,  1, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_    ___ ___  ___ __ _  __ __
 (_-</ -_) __/   / -_) _ \/ -_)  ' \/ // /
/___/\__/\__/    \__/_//_/\__/_/_/_/\_, /
                                   /___/  	-------------------------------------------------------------
*/


							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, ANG_to_DOWN,  		0	+ RandomRange(10)));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	9, ANG_to_DOWN,  		0	+ RandomRange(10)));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 13, ANG_to_LEFT, 		35	));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  6, ANG_to_LEFT, 		35	));
if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 15, ANG_to_LEFT, 		35	));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 54, ANG_to_UP, 			0	));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 62, ANG_to_UP, 			0	));
if (RNG(false, true))
							{
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 50, ANG_to_RIGHT,		35	+ RandomRange(10)));
							delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 57, ANG_to_RIGHT,		35	+ RandomRange(10)));
if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 48, ANG_to_RIGHT,		35	+ RandomRange(10)));
							}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __      _ __
  ___ ___ / /_    (_) /____ __ _
 (_-</ -_) __/   / / __/ -_)  ' \
/___/\__/\__/   /_/\__/\__/_/_/_/
											-------------------------------------------------------------
*/

delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  56, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  18, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  45, item_RANDOM));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





delay(	SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	 0, GetAmmoType()	));

Deploying = false;
}













/*


  1111111    333333333333333
 1::::::1   3:::::::::::::::33
1:::::::1   3::::::33333::::::3
111:::::1   3333333     3:::::3
   1::::1               3:::::3
   1::::1               3:::::3
   1::::1       33333333:::::3
   1::::l       3:::::::::::3
   1::::l       33333333:::::3
   1::::l               3:::::3
   1::::l               3:::::3
   1::::l               3:::::3
111::::::1113333333     3:::::3
1::::::::::13::::::33333::::::3
1::::::::::13:::::::::::::::33
111111111111 333333333333333

*/






Script "DEPLOY_13" (int BlockCounter, int Direction)
{
int Tag, counter, i, ObstacleCounter, 			EmitTag, DevourTag, ProjAngle, AddHeight;
int ContainerType = OneBlock;
str StringA = "";

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/						MAIN
														-------------------------------------------------------------
*/
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);
counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __                 ____
  ___ ___ / /_   _    _____ _/ / /
 (_-</ -_) __/  | |/|/ / _ `/ / /
/___/\__/\__/   |__,__/\_,_/_/_/  						Area columns
														-------------------------------------------------------------
*/
TimeGive(12);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  2,  2, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  4,  4, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  6,  6, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  8,  8, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  2,  2, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  6,  6, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);

if (!RNG(0,1))			{
						delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  1,  1, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None));
						TimeGive(TG_WALL);
						}

		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  2,  2, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  4,  4, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  6,  6, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  8,  8, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	8, 	8,  3,  3, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
		SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	8, 	8,  6,  6, RoundInfo[GlobalCeilingHeight], 		TextureIs(FlatEDGEtx), None);
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __      _ __
  ___ ___ / /_    (_) /____ __ _
 (_-</ -_) __/   / / __/ -_)  ' \
/___/\__/\__/   /_/\__/\__/_/_/_/
														-------------------------------------------------------------
*/
Switch(RNG(0,1))		{
		CASE 0:			SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 18, item_RANDOM);	break;
		CASE 1:			SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 50, item_RANDOM);	break;
						}
SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction,  8, item_RANDOM);
SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 15, item_RANDOM);
SetItem (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 56, item_RANDOM);
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __              ___
  ___ ___ / /_   ___ ___ _/ _/__ ___ ___  ___  ___
 (_-</ -_) __/  (_-</ _ `/ _/ -_)_ // _ \/ _ \/ -_)
/___/\__/\__/  /___/\_,_/_/ \__//__/\___/_//_/\__/

*/
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  6,  6, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));
Switch(RNG(0,1))		{
		CASE 0:			delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	8, 	8,  1,  1, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));	break;
		CASE 1:			delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  6,  6, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));	break;
						}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
           __          __       __           __
  ___ ___ / /_   ___  / /  ___ / /____ _____/ /__ ___
 (_-</ -_) __/  / _ \/ _ \(_-</ __/ _ `/ __/ / -_|_-<
/___/\__/\__/   \___/_.__/___/\__/\_,_/\__/_/\__/___/	-------------------------------------------------------------

*/
while (ObstacleCounter <= DifficultyObs())
{
	Switch(PickObstacle())
		{
		/*
		  ___
		 / _ \
		/ // /
		\___/

		*/
		CASE 0:
		TimeGive(15);
		Switch(RNG(0,1))
			{
			CASE 0:
				//------  SET PROJECTILE  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					EmitTag = 74;		DevourTag = 97;			ProjAngle = ANG_to_UP;			AddHeight = None;

				delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
						SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
				//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			break;

			CASE 1:
				//------  SET ENEMY  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 46, ANG_to_UP,  		25);
				//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			break;
			}
		break;
		/*
		  ___
		 <  /
		 / /
		/_/

		*/
		CASE 1:
		TimeGive(15);
		Switch(RNG(0,1))
			{
			CASE 0:
				//------  SET PROJECTILE  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					EmitTag = 83;		DevourTag = 70;			ProjAngle = ANG_to_RIGHT;			AddHeight = None;

				delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
						SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
				//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			break;

			CASE 1:
				//------  SET ENEMY  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 53, ANG_to_LEFT,  		25);
				//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			break;
			}
		break;
		/*
		   ___
		  |_  |
		 / __/
		/____/

		*/
		CASE 2:
		TimeGive(12);
		//------  SET PROJECTILE  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			EmitTag = 64;		DevourTag = 89;			ProjAngle = ANG_to_LEFT;			AddHeight = None;

		delay(	SetProjectile (area_FLOOR,			ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile (area_FLOOR,			ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile (area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile (area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile (area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		/*
		   ____
		  |_  /
		 _/_ <
		/____/

       		*/
		CASE 3:
		TimeGive(15);
		//------  SET SCROLL  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Switch(RNG(0,1))
			{
			CASE 0:	i = Direction;						break;
			CASE 1:	i = InvertDirection(Direction);		break;
			}

				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 		1, 	8,  5,  5, RoundInfo[CurrFloorHeight], 		TextureIs(FlatSCRLtx), SectorSpecial_SCROLL_VERTICAL);
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		/*
		  ____
		 / / /
		/_  _/
		 /_/

       		*/
		CASE 4:
		TimeGive(15);
		//------  SET RANDOM PATHLINE  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		counter = 0;
		while (counter < 8)
			{
			counter++;
			Switch(RNG(1,3))
				{
				CASE 1:	StringA = TextureIs(FlatBASEtx);	i = RoundInfo[CurrFloorHeight];		break;
				CASE 2:	StringA = TextureIs(FlatFAILtx);	i = RoundInfo[PitFloorHeight];		break;
				CASE 3:	StringA = TextureIs(FlatCOALtx);	i = RoundInfo[CurrFloorHeight];		break;
				}
			if (counter != 5)
					SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  counter,  counter, i, 	StringA, None);
			}

		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		/*
		   ____
		  / __/
		 /__ \
		/____/

       		*/
		CASE 5:
		TimeGive(15);
		//------  SET PIT  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	1,  1,  1, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	1,  3,  3, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	1,  7,  8, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  1,  1, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		/*
		  ____
		 / __/
		/ _ \
		\___/

		*/
		CASE 6:
		TimeGive(10);
		Switch(RNG(0,1))
			{
			CASE 0:
				//------  SET PIT  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  7,  8, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
					SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	8, 	8,  7,  8, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
			//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			break;

			CASE 1:
				//------  SET ENEMY  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 63, ANG_to_LeftUp,  		25);
				//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			break;
			}
		break;
		/*
		 ____
		/_  /
		 / /
		/_/

		*/
		CASE 7:
		TimeGive(11);
			//------  SET PIT  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  1,  2, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	8,  4,  4, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	8, 	8,  2,  2, RoundInfo[PitFloorHeight], 			TextureIs(FlatFAILtx), None);
			//------  DEL SAFE ZONE  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  6,  6, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatBASEtx), None);
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		/*
		  ___
		 ( _ )
		/ _  |
		\___/

		*/
		CASE 8:
		TimeGive(35);
			//------  SET ENEMY  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 19, ANG_to_DOWN,  		0);
				SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 21, ANG_to_LEFT,  		0);
				SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 26, ANG_to_RIGHT,  		0);
				SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 42, ANG_to_UP,  			0);
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		/*
		  ___
		 / _ \
		 \_, /
		/___/

		*/
		CASE 9:
		TimeGive(35);
			//------  SET COAL  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  3,  3, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  1,  1, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  7,  7, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
				SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  8,  8, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None);
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		break;
		}
ObstacleCounter++;
delay(1);
}

Deploying = false;
}





















/*

 222222222222222      1111111
2:::::::::::::::22   1::::::1
2::::::222222:::::2 1:::::::1
2222222     2:::::2 111:::::1
            2:::::2    1::::1
            2:::::2    1::::1
         2222::::2     1::::1
    22222::::::22      1::::l
  22::::::::222        1::::l
 2:::::22222           1::::l
2:::::2                1::::l
2:::::2                1::::l
2:::::2       222222111::::::111
2::::::2222222:::::21::::::::::1
2::::::::::::::::::21::::::::::1
22222222222222222222111111111111

*/



Script "DEPLOY_2" (int BlockCounter, int Direction)
{
int Tag, counter,		EmitTag, DevourTag, ProjAngle, AddHeight;
int ContainerType = TwoBlocks;


DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, DOESNT_MATTER);

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
// 1 2
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3,  4,  3,  9, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	3,  4,  0,  2, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7,  8,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	7,  8,  1,  1, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	7,  8,  3,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	7,  8,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Switch(RNG(false, true))
	{
	case false:

		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/

		EmitTag = 88;	DevourTag = 65;		ProjAngle = ANG_to_RIGHT;	AddHeight = 16;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	break;


	case true:
	delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, TwoBlocks, 1, BlockCounter, Direction), Direction, 13, DOESNT_MATTER, 		35	));
	break;
	}





delay(	SetItem (ContainerInfo(InfoType_ORDER,   TwoBlocks, 2, BlockCounter, Direction), Direction, 	9, item_RANDOM));

if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 62, ANG_to_Up,  		0	+ RandomRange(10)));
if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 57, ANG_to_Up, 		50	));
if (RNG(false, true))		delay(	SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 59, ANG_to_Up, 		50	));

/*
               _ __
   _________  (_) /
  / ___/ __ \/ / /
 (__  ) /_/ / / /
/____/\____/_/_/

*/				if (RNG(false, true))		delay(	SetSoil 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction));
				if (RNG(false, true))		delay(	SetSoil 	(ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction));

if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	7,  2,  2, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));

if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	2, 	4,  3,  5, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	2, 	4,  6,  7, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	5, 	6,  3,  5, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	5, 	6,  6,  6, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));

if (RNG(false, true))		SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 63, ANG_to_LeftUp,  		22);
if (RNG(false, true))		SetEnemy (ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 7, ANG_to_DownLeft,  	65);


if (RNG(false, true))
		{
		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/

		EmitTag = 64;	DevourTag = 89;		ProjAngle = ANG_to_LEFT;	AddHeight = 0;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		}






Deploying = false;
}




/*


 333333333333333     1111111
3:::::::::::::::33  1::::::1
3::::::33333::::::31:::::::1
3333333     3:::::3111:::::1
            3:::::3   1::::1
            3:::::3   1::::1
    33333333:::::3    1::::1
    3:::::::::::3     1::::l
    33333333:::::3    1::::l
            3:::::3   1::::l
            3:::::3   1::::l
            3:::::3   1::::l
3333333     3:::::3111::::::111
3::::::33333::::::31::::::::::1
3:::::::::::::::33 1::::::::::1
 333333333333333   111111111111


*/




Script "DEPLOY_3" (int BlockCounter, int Direction)
{
int Tag, counter, a, b, 			EmitTag, DevourTag, ProjAngle, AddHeight;
int ContainerType = ThreeBlocks;

DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, DOESNT_MATTER);
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, DOESNT_MATTER);

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
if (RoundInfo[CurrFloorHeight] != RoundInfo[GlobalFloorHeight])
for(int c = 0; c < 64; c++)
		{
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 1, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 2, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		Floor_MoveToValue(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 3, BlockCounter, Direction), Direction, c), MoveInstantly, RoundInfo[CurrFloorHeight]);
		}
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 1, BlockCounter, Direction), Direction, 36),  "TESTFLA3");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 2, BlockCounter, Direction), Direction, 36),  "TESTFLA3");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, ThreeBlocks, 3, BlockCounter, Direction), Direction, 36),  "TESTFLA3");*/






/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/
/*SAFE PLACE*/				delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  5,  5, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));

// 1
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5,  5,  2,  2, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  3,  3, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  4,  4, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2,  2,  5,  5, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  6,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  7,  7, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
//2
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	3,  3,  1,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	4, 	6,  4,  4, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
//3
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	4,  5,  4,  5, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, ThreeBlocks, 1, BlockCounter, Direction), Direction, 14, DOESNT_MATTER, 		0	+ RandomRange(30)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, ThreeBlocks, 3, BlockCounter, Direction), Direction, 49, DOESNT_MATTER, 		35	));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   ThreeBlocks, 2, BlockCounter, Direction), Direction, 	1, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   ThreeBlocks, 2, BlockCounter, Direction), Direction, 	3, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   ThreeBlocks, 2, BlockCounter, Direction), Direction, 	5, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   ThreeBlocks, 2, BlockCounter, Direction), Direction, 	7, item_RANDOM));



if (RNG(false, true))
		{
		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/

		EmitTag = 89;	DevourTag = 64;		ProjAngle = ANG_to_RIGHT;	AddHeight = 16;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		}


if (RNG(false, true))
		{
		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/

		EmitTag = 71;	DevourTag = 82;		ProjAngle = ANG_to_LEFT;	AddHeight = 16;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		}
/*
if (RNG(false, true))
		{
		Switch(RNG(false, true))
			{
			case FALSE:		EmitTag = 69;	DevourTag = 84;		ProjAngle = ANG_to_LEFT;	AddHeight = 16;		a = 3; b = 1;		break;
			case TRUE:		EmitTag = 84;	DevourTag = 69;		ProjAngle = ANG_to_RIGHT;	AddHeight = 16;		a = 1; b = 3;		break;
			}
		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/
/*
		AddHeight = 16;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, a, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, b, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, a, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, b, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		}
*/


a = 0;


while (a < 3)
	{
	a++;

		if (RNG(false, true))
		{
				if (RNG(false, true))
				{
				/*
				 _      ______  _________ ___
				| | /| / / __ \/ ___/ __ `__ \
				| |/ |/ / /_/ / /  / / / / / /
				|__/|__/\____/_/  /_/ /_/ /_/
				*/

													delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, a, BlockCounter, Direction), Direction, 1));
						if (RNG(false, true))		delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, a, BlockCounter, Direction), Direction, 3));
						if (RNG(false, true))		delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, a, BlockCounter, Direction), Direction, 57));
				}

				else
				{
				/*
							   _ __
				   _________  (_) /
				  / ___/ __ \/ / /
				 (__  ) /_/ / / /
				/____/\____/_/_/

				*/									delay(	SetSoil 	(ContainerInfo(InfoType_ORDER, ContainerType, a, BlockCounter, Direction), Direction));

				}
		}
	}


if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  6,  6, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	7, 	7,  6,  6, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  3,  4, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	3, 	3,  6,  6, RoundInfo[CurrFloorHeight] + 0, 		TextureIs(FlatCOALtx), None));

Deploying = false;
}






/*


       444444444    1111111
      4::::::::4   1::::::1
     4:::::::::4  1:::::::1
    4::::44::::4  111:::::1
   4::::4 4::::4     1::::1
  4::::4  4::::4     1::::1
 4::::4   4::::4     1::::1
4::::444444::::444   1::::l
4::::::::::::::::4   1::::l
4444444444:::::444   1::::l
          4::::4     1::::l
          4::::4     1::::l
          4::::4  111::::::111
        44::::::441::::::::::1
        4::::::::41::::::::::1
        4444444444111111111111


*/


Script "DEPLOY_4" (int BlockCounter, int Direction)
{
int Tag, counter;
int ContainerType = FourBlocks;

DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, DOESNT_MATTER);
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, DOESNT_MATTER);
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, DOESNT_MATTER);
DrawLineTexture 	(dlt_DRAW, dlt_MAIN,	ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, DOESNT_MATTER);

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[PitFloorHeight], 		TextureIs(FlatFAILtx), None));
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[PitFloorHeight], 		TextureIs(FlatFAILtx), None));
	}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/

/*SAFE PLACE*/				delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  8,  8, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));
/*SAFE PLACE*/				delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	3, 	3,  7,  8, RoundInfo[CurrFloorHeight], 				TextureIs(FlatSECOtx), None));

delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3,  6,  3,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	3,  6,  3,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, 	3,  6,  3,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	3,  6,  3,  6, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));


//2
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	5,  5,  1,  1, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	2,  2,  1,  1, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	1,  1,  4,  4, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	1,  1,  7,  7, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	4,  4,  8,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	7,  7,  8,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	8,  8,  5,  5, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, 	8,  8,  2,  2, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));

//4
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	5,  5,  1,  1, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	2,  2,  1,  1, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	1,  1,  4,  4, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	1,  1,  7,  7, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	4,  4,  8,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	7,  7,  8,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	8,  8,  5,  5, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, 	8,  8,  2,  2, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));

//mid
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	9,  9,  9,  9, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	9,  9,  0,  0, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	0,  0,  9,  9, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	0,  0,  9,  9, RoundInfo[GlobalCeilingHeight], 			TextureIs(FlatEDGEtx), None));
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

int EmitTag = 88;	int DevourTag = 65;		int ProjAngle = ANG_to_RIGHT;	int AddHeight = 8;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 70;		DevourTag = 83;			ProjAngle = ANG_to_LEFT;		AddHeight = 8;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 2, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 88;		DevourTag = 65;			ProjAngle = ANG_to_RIGHT;		AddHeight = 8;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

	EmitTag = 70;		DevourTag = 83;			ProjAngle = ANG_to_LEFT;		AddHeight = 8;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 4, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 3, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






//delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 1, BlockCounter, Direction), Direction, 10, DOESNT_MATTER, 		0	+ RandomRange(10)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 1, BlockCounter, Direction), Direction, 22, DOESNT_MATTER, 		0	+ RandomRange(20)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 1, BlockCounter, Direction), Direction, 53, DOESNT_MATTER, 		0	+ RandomRange(30)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 1, BlockCounter, Direction), Direction, 41, DOESNT_MATTER, 		0	+ RandomRange(40)	));

delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 3, BlockCounter, Direction), Direction, 10, DOESNT_MATTER, 		0	+ RandomRange(10)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 3, BlockCounter, Direction), Direction, 53, DOESNT_MATTER, 		0	+ RandomRange(20)	));



//delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 2, BlockCounter, Direction), Direction, 14, DOESNT_MATTER, 		0	+ RandomRange(20)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 2, BlockCounter, Direction), Direction, 22, DOESNT_MATTER, 		0	+ RandomRange(10)	));
delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, FourBlocks, 4, BlockCounter, Direction), Direction, 41, DOESNT_MATTER, 		0	+ RandomRange(10)	));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 1, BlockCounter, Direction), Direction, 	1, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 1, BlockCounter, Direction), Direction, 	3, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 1, BlockCounter, Direction), Direction, 	5, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 1, BlockCounter, Direction), Direction, 	7, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 3, BlockCounter, Direction), Direction, 	1, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 3, BlockCounter, Direction), Direction, 	3, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 3, BlockCounter, Direction), Direction, 	5, item_RANDOM));
delay(	SetItem (ContainerInfo(InfoType_ORDER,   FourBlocks, 3, BlockCounter, Direction), Direction, 	7, item_RANDOM));


Deploying = false;
}



function int InvertDirection (int Initial)
{
int Result;
Switch(Initial)
	{
	CASE ToRIGHT:	Result = ToLEFT;	break;
	CASE ToLEFT:	Result = ToRIGHT;	break;
	CASE ToDOWN:	Result = ToUP;		break;
	CASE ToUP:		Result = ToDOWN;	break;
	}
return Result;
}




function int RotateDirection (int Initial, int How)
{
int Result;

Switch(How)
	{
	CASE ToRIGHT:
		Switch(Initial)
			{
			CASE ToUP:		Result = ToRIGHT;	break;
			CASE ToRIGHT:	Result = ToDOWN;	break;
			CASE ToDOWN:	Result = ToLEFT;	break;
			CASE ToLEFT:	Result = ToUP;		break;
			}
	break;

	CASE ToLEFT:
		Switch(Initial)
			{
			CASE ToRIGHT:	Result = ToUP;		break;
			CASE ToUP:		Result = ToLEFT;	break;
			CASE ToLEFT:	Result = ToDOWN;	break;
			CASE ToDOWN:	Result = ToRIGHT;	break;
			}
	break;
	}

return Result;
}


/*


LLLLLLLLLLL                                 AAA                    DDDDDDDDDDDDD             DDDDDDDDDDDDD             EEEEEEEEEEEEEEEEEEEEEE     RRRRRRRRRRRRRRRRR
L:::::::::L                                A:::A                   D::::::::::::DDD          D::::::::::::DDD          E::::::::::::::::::::E     R::::::::::::::::R
L:::::::::L                               A:::::A                  D:::::::::::::::DD        D:::::::::::::::DD        E::::::::::::::::::::E     R::::::RRRRRR:::::R
LL:::::::LL                              A:::::::A                 DDD:::::DDDDD:::::D       DDD:::::DDDDD:::::D       EE::::::EEEEEEEEE::::E     RR:::::R     R:::::R
  L:::::L                               A:::::::::A                  D:::::D    D:::::D        D:::::D    D:::::D        E:::::E       EEEEEE       R::::R     R:::::R
  L:::::L                              A:::::A:::::A                 D:::::D     D:::::D       D:::::D     D:::::D       E:::::E                    R::::R     R:::::R
  L:::::L                             A:::::A A:::::A                D:::::D     D:::::D       D:::::D     D:::::D       E::::::EEEEEEEEEE          R::::RRRRRR:::::R
  L:::::L                            A:::::A   A:::::A               D:::::D     D:::::D       D:::::D     D:::::D       E:::::::::::::::E          R:::::::::::::RR
  L:::::L                           A:::::A     A:::::A              D:::::D     D:::::D       D:::::D     D:::::D       E:::::::::::::::E          R::::RRRRRR:::::R
  L:::::L                          A:::::AAAAAAAAA:::::A             D:::::D     D:::::D       D:::::D     D:::::D       E::::::EEEEEEEEEE          R::::R     R:::::R
  L:::::L                         A:::::::::::::::::::::A            D:::::D     D:::::D       D:::::D     D:::::D       E:::::E                    R::::R     R:::::R
  L:::::L         LLLLLL         A:::::AAAAAAAAAAAAA:::::A           D:::::D    D:::::D        D:::::D    D:::::D        E:::::E       EEEEEE       R::::R     R:::::R
LL:::::::LLLLLLLLL:::::L        A:::::A             A:::::A        DDD:::::DDDDD:::::D       DDD:::::DDDDD:::::D       EE::::::EEEEEEEE:::::E     RR:::::R     R:::::R
L::::::::::::::::::::::L       A:::::A               A:::::A       D:::::::::::::::DD        D:::::::::::::::DD        E::::::::::::::::::::E     R::::::R     R:::::R
L::::::::::::::::::::::L      A:::::A                 A:::::A      D::::::::::::DDD          D::::::::::::DDD          E::::::::::::::::::::E     R::::::R     R:::::R
LLLLLLLLLLLLLLLLLLLLLLLL     AAAAAAA                   AAAAAAA     DDDDDDDDDDDDD             DDDDDDDDDDDDD             EEEEEEEEEEEEEEEEEEEEEE     RRRRRRRR     RRRRRRR

*/

Script "DEPLOY_101" (int BlockCounter, int Direction)
{
int Tag, counter;
int ContainerType = OneBlock;

if (RoundInfo[InvertedStairs]) 		Direction = InvertDirection(Direction);
LiftCurrentHeight(ON, BlockCounter, Direction);
/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/
/*
counter = 0;
while (counter < 8)
	{
	counter++;
	//delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[PitFloorHeight], 	TextureIs(FlatFAILtx), None));

	}*/
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	8,  1,  8, RoundInfo[PitFloorHeight] + 64, 	TextureIs(FlatFAILtx), None));

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/

Switch(RNG(0, 2))
	{
	case 0:					delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  3,  3, RoundInfo[CurrFloorHeight] + 32, 				TextureIs(FlatSECOtx), None));		break;
	case 1:					delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  3,  3, RoundInfo[CurrFloorHeight] + 32, 				TextureIs(FlatSECOtx), None));		break;
	case 2:					delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	5,  3,  3, RoundInfo[CurrFloorHeight] + 32, 				TextureIs(FlatSECOtx), None));		break;
	}

							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  5,  5, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	4,  5,  5, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  5,  5, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  5,  5, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
							delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	6,  7,  7, RoundInfo[CurrFloorHeight] + 96, 				TextureIs(FlatSECOtx), None));
if (RNG(false, true))		delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	4,  7,  7, RoundInfo[CurrFloorHeight] + 96, 				TextureIs(FlatSECOtx), None));

Switch(RNG(false, true))
	{
	case false:
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	3,  1,  1, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
	break;

	case true:
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	6, 	6,  1,  1, RoundInfo[CurrFloorHeight] - 32, 				TextureIs(FlatSECOtx), None));
	break;
	}


Switch(RNG(false, true))
	{
	case false:
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	1, 	1,  8,  8, RoundInfo[CurrFloorHeight] + 80, 				TextureIs(FlatSECOtx), None));
	break;

	case true:
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	8, 	8,  8,  8, RoundInfo[CurrFloorHeight] + 80, 				TextureIs(FlatSECOtx), None));
	break;
	}



/*
                    _         __  _ __
   ___  _______    (_)__ ____/ /_(_) /__
  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
/_/           |___/							-------------------------------------------------------------
*/

int EmitTag = 97;	int DevourTag = 74;		int ProjAngle = ANG_to_DOWN;	int AddHeight = 100;

delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


if (RNG(false, true))
		{
		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/

		EmitTag = 94;	DevourTag = 77;		ProjAngle = ANG_to_DOWN;	AddHeight = 74;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		}



if (RNG(false, true))
		{
		/*
							_         __  _ __
		   ___  _______    (_)__ ____/ /_(_) /__
		  / _ \/ __/ _ \  / / -_) __/ __/ / / -_)
		 / .__/_/  \___/_/ /\__/\__/\__/_/_/\__/
		/_/           |___/							-------------------------------------------------------------
		*/

		EmitTag = 79;	DevourTag = 92;		ProjAngle = ANG_to_UP;	AddHeight = 0;

		delay(	SetProjectile 	(area_FLOOR,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_FLOOR,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_EMIT,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag, 	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
		delay(	SetProjectile 	(area_CEILING,		ProjRole_DEVOUR,	ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	DOESNT_MATTER,	AddHeight, None	))	;
				SetProjectile 	(area_PREPARATION,	DOESNT_MATTER,		ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, EmitTag,	DevourTag,	ProjAngle,		AddHeight, None	)	;
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		}



LiftCurrentHeight(OFF, BlockCounter, Direction);
Deploying = false;
}


















Script "DEPLOY_102" (int BlockCounter, int Direction)
{
int Tag, counter;
int ContainerType = OneBlock;
if (RoundInfo[InvertedStairs])
	if (RoundInfo[StairsDecided] == 1)
			{
			RoundInfo[StairsDecided] = 2;
			ACS_NamedExecute("DEPLOY_103", 0, BlockCounter, Direction);
			Terminate;
			}
	if (RoundInfo[StairsDecided] == 2)	Direction = RotateDirection(Direction, ToLEFT);

LiftCurrentHeight(ON, BlockCounter, Direction);


/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/


delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  2,  2, RoundInfo[CurrFloorHeight] + 32, 				TextureIs(FlatSECOtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	5, 	5,  5,  5, RoundInfo[CurrFloorHeight] + 64, 				TextureIs(FlatSECOtx), None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	2, 	2,  5,  5, RoundInfo[CurrFloorHeight] + 96, 				TextureIs(FlatSECOtx), None));


if (	(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_RAISE)	|	(RNG(false, true))	)
		{
/*
 _      ______  _________ ___
| | /| / / __ \/ ___/ __ `__ \
| |/ |/ / /_/ / /  / / / / / /
|__/|__/\____/_/  /_/ /_/ /_/
*/

							delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 1));
							delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 3));
							delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 7));
if (RNG(false, true))		delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 63));
if (RNG(false, true))		delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 56));
		}

LiftCurrentHeight(OFF, BlockCounter, Direction);
Deploying = false;
}









Script "DEPLOY_103" (int BlockCounter, int Direction)
{
int Tag, counter, i;
int ContainerType = OneBlock;
if (RoundInfo[InvertedStairs])
	if (RoundInfo[StairsDecided] == 1)
			{
			RoundInfo[StairsDecided] = 2;
			ACS_NamedExecute("DEPLOY_102", 0, BlockCounter, Direction);
			Terminate;
			}
	if (RoundInfo[StairsDecided] == 2)	Direction = RotateDirection(Direction, ToRIGHT);

LiftCurrentHeight(ON, BlockCounter, Direction);


/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/			MAIN
											-------------------------------------------------------------
*/

counter = 0;
while (counter < 8)
	{
	counter++;
	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	counter, 	counter,  1,  8, RoundInfo[PitFloorHeight], 	TextureIs(FlatFAILtx), 	None));
	}

	delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	3, 	6,  3,  6, RoundInfo[CurrFloorHeight] + 0, 	TextureIs(FlatBASEtx), None));


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
           __
  ___ ___ / /_   ___ ________ ___ _
 (_-</ -_) __/  / _ `/ __/ -_) _ `/
/___/\__/\__/   \_,_/_/  \__/\_,_/
											-------------------------------------------------------------
*/


Switch(RNG(false, true))
	{
	case false:		i = TextureIs(FlatSECOtx);	break;
	case true:		i = TextureIs(FlatICEDtx);	break;
	}
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	5,  2,  2, RoundInfo[CurrFloorHeight] + 32, 				TextureIs(FlatSECOtx), 	None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	4, 	5,  4,  5, RoundInfo[CurrFloorHeight] + 64, 				i, 						None));
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	7, 	7,  4,  5, RoundInfo[CurrFloorHeight] + 96, 				TextureIs(FlatSECOtx), 	None));



if (	(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_RAISE)	|	(RNG(false, true))	)
		{
/*
 _      ______  _________ ___
| | /| / / __ \/ ___/ __ `__ \
| |/ |/ / /_/ / /  / / / / / /
|__/|__/\____/_/  /_/ /_/ /_/
*/

		delay(	SetWorm 	(ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 18));
		}

if (RNG(false, true))		delay(	SetEnemy  (ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 0, DOESNT_MATTER, 		60	+ RandomRange(40)	));

LiftCurrentHeight(OFF, BlockCounter, Direction);
Deploying = false;
}






function void LiftCurrentHeight (int Segment, int BlockCounter, int Direction)
{
int i;
Switch(Segment)
	{
	CASE ON:
			Switch(RoundInfo[InvertedStairs])
				{
				CASE FALSE:
				break;

				CASE TRUE:
				RoundInfo[CurrFloorHeight] -= StairsHeight;

				Switch(Direction)
					{
					CASE ToLEFT:
/*					for (i = (EntryY); i <= BorderSegment(EntryY) + RoundInfo[OptEntranceY];  i++)
						{
						Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, ToRIGHT)) + i,			MoveInstantly, RoundInfo[CurrFloorHeight]);
						ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, ToRIGHT)) + i,  			TextureIs(FlatSECOtx));
						}
*/

					for (i = 0; i <= RoundInfo[OptEntranceY];  i++)
					SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, ToRIGHT), ToRIGHT, 	4, 	4 + i,  9,  9, RoundInfo[CurrFloorHeight], 			TextureIs(FlatSECOtx), None);
					break;


					CASE ToUP:
/*					for (i = BorderSegment(EntryX); i <= BorderSegment(EntryX) + RoundInfo[OptEntranceX];  i++)
						{
						Floor_MoveToValue	(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, ToRIGHT)) + i,			MoveInstantly, RoundInfo[CurrFloorHeight]);
						ChangeFloor			(B2S(ContainerInfo(InfoType_ORDER, 1, 1, BlockCounter, ToRIGHT)) + i,  			TextureIs(FlatSECOtx));
						}
*/

					for (i = RoundInfo[OptEntranceX]; i >= 0;  i--)
					SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, ToRIGHT), ToRIGHT, 	9, 	9,  5 + i,  5, RoundInfo[CurrFloorHeight], 			TextureIs(FlatSECOtx), None);
					break;
					}



				break;
				}
	break;



	CASE OFF:
			Switch(RoundInfo[InvertedStairs])
				{
				CASE FALSE:
				RoundInfo[CurrFloorHeight] += StairsHeight;
				break;

				CASE TRUE:
				break;
				}
	RoundInfo[InvertedStairs] = FALSE;
	RoundInfo[StairsDecided] = FALSE;
	break;
	}








RoundInfo[AddBorderEntryHeightX] = None;
RoundInfo[AddBorderEntryHeightY] = None;
}











Script "DEPLOY_501" (int BlockCounter, int Direction)
{
int ContainerType = OneBlock;
delay(	SetArea 		(area_FLOOR, 							ContainerInfo(InfoType_ORDER, ContainerType, 1, BlockCounter, Direction), Direction, 	0, 	9,  0,  9, ImpossibleNum, 		TextureIs(FlatWATEtx), SectorSpecial_FLOW));


/*
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "FLOOR6_1");

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 28),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 44),  "FLOOR6_1");

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 22),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 30),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 38),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 46),  "FLOOR6_1");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 54),  "FLOOR6_1");
*/
Deploying = false;
}

Script "DEPLOY_502" (int BlockCounter, int Direction)
{

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 4),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 12),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 20),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 28),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 35),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 33),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 32),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 16),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 9),  "RROCK20");


Deploying = false;
}

Script "DEPLOY_503" (int BlockCounter, int Direction)
{

ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 32),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 33),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 34),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 35),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 36),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 44),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 52),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 60),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 40),  "RROCK20");
ChangeFloor(TagAt (ContainerInfo(InfoType_ORDER, OneBlock, 1, BlockCounter, Direction), Direction, 49),  "RROCK20");


Deploying = false;
}





















/*

 ___________    ____  _______ .__   __. .___________.    _______.
|   ____\   \  /   / |   ____||  \ |  | |           |   /       |
|  |__   \   \/   /  |  |__   |   \|  | `---|  |----`  |   (----`
|   __|   \      /   |   __|  |  . `  |     |  |        \   \
|  |____   \    /    |  |____ |  |\   |     |  |    .----)   |
|_______|   \__/     |_______||__| \__|     |__|    |_______/


*/



//ZANDRONUM


script "EventScript" (int EventType, int Arg1, int Arg2) EVENT
{
	if (EventType == GAMEEVENT_ROUND_STARTS)
		{
			SetActivator(0, AAPTR_NULL);
			ACS_NamedExecute("EXE", 0);
		}



    if (EventType == GAMEEVENT_ACTOR_DAMAGED)
		{
			if (Arg1 > 0)
				{
				//SetActivator(PLAYER_TID + PlayerNumber(), AAPTR_DAMAGE_SOURCE);
				if (!(ClassifyActor(0) & ACTOR_GENERIC ))
				if (SetActivator(0, AAPTR_DAMAGE_SOURCE))
				if (ClassifyActor(0) & ACTOR_PLAYER )
					{
					PlayerScore[PlayerNumber()] += Arg1;
					SetPlayerScore(PlayerNumber(), SCORE_POINTS, PlayerScore[PlayerNumber()]);

					//TOASTY
				/*	if (Arg1 >= 100)
						{
						if (!PlayerToasty[PlayerNumber()])
							{
							ClientScript (PlayerNumber(), "Toasty", 0, 0, 0);
							PlayerToasty[PlayerNumber()] = RNG(12, 16);
							}
						else PlayerToasty[PlayerNumber()]--;
						}*/
					if (Arg1 >= 100)
						if (!RNG(0,32))
							ClientScript (PlayerNumber(), "Toasty", 0, 0, 0);
					}




/*
				if (Arg1 >= 100)	//Toasty
					{
					if (!PlayerToasty[PlayerNumber()])
						{
						//PrintBold(i:PlayerToasty[PlayerNumber()]);
						ClientScript (PlayerNumber(), "Toasty", 0, 0, 0);
						PlayerToasty[PlayerNumber()] = RNG(12, 16);
						}
					else PlayerToasty[PlayerNumber()]--;
					}
*/


				}
		}
/*
    if (EventType == GAMEEVENT_CHAT)
		{
			if (Arg1 > 0)
				{
				SetActivator(PLAYER_TID + PlayerNumber(), AAPTR_DAMAGE_SOURCE);

				PlayerScore[PlayerNumber()] += Arg1;
				SetPlayerScore(PlayerNumber(), SCORE_POINTS, PlayerScore[PlayerNumber()]);
				}
		}
*/


/*	idk doesnt work
	if (EventType == GAMEEVENT_PLAYERCONNECT)
		{
		//SetActivatorToPlayer(Arg1);
		//ClientScript	(Arg1, "CLIENTLOGIC", 0, 0, 0);
		NamedExecuteClientScript("CLIENTLOGIC", Arg1);
		}
*/
}

//ZDAEMON

function void ZDA_Dmg2PlayerScore (void)
{
   for (int p = 0; p < MaxPlayers;  p++)
     {
			PlayerScore[p] = GetPlayerInfo(p, PLAYERINFO_PTS_1);
    }
}



















/*

Script "Test_ShowBlocks" ENTER
{
if (IsNetworkGame()) terminate;
SetFont("smallfont");
int y, x;

While(true)

	{
	SetFont("ERFONT");




	HudMessageBold(


	s:BlockAt[0][0], s:"  ", s:BlockAt[0][1], s:"  ", s:BlockAt[0][2], s:"  ", s:BlockAt[0][3], s:"  ", s:BlockAt[0][4], s:"\n\n",
	s:BlockAt[1][0], s:"  ", s:BlockAt[1][1], s:"  ", s:BlockAt[1][2], s:"  ", s:BlockAt[1][3], s:"  ", s:BlockAt[1][4], s:"\n\n",
	s:BlockAt[2][0], s:"  ", s:BlockAt[2][1], s:"  ", s:BlockAt[2][2], s:"  ", s:BlockAt[2][3], s:"  ", s:BlockAt[2][4], s:"\n\n",
	s:BlockAt[3][0], s:"  ", s:BlockAt[3][1], s:"  ", s:BlockAt[3][2], s:"  ", s:BlockAt[3][3], s:"  ", s:BlockAt[3][4], s:"\n\n",
	s:BlockAt[4][0], s:"  ", s:BlockAt[4][1], s:"  ", s:BlockAt[4][2], s:"  ", s:BlockAt[4][3], s:"  ", s:BlockAt[4][4], s:"\n\n\n\n",
	i:AdventureInfo[0][adv_TYPE], s:"  ", i:AdventureInfo[1][adv_TYPE], s:"  ", i:AdventureInfo[2][adv_TYPE], s:"  ", i:AdventureInfo[3][adv_TYPE], s:"  ", i:AdventureInfo[4][adv_TYPE], s:"  ", i:AdventureInfo[5][adv_TYPE], s:"\n\n",
	s:"\cjMOOD  ", 	i:GAMEINFO[Mood],		i:GAMEINFO[Location], s:"\n\n",
	s:"\cjPLAYER's CP  ", 	i:PlayerCheckpoint[PlayerNumber()],		s:"\cj,    ROUND  ", 	i:RoundInfo[CurrentRound], s:"\n\n",
	s:"\ckHEIGHT  ", 			f:GetActorZ(0), s:"\n\n",
	s:"\ciCEILI HEIGHT    ",	f:GetActorCeilingZ	(PLAYER_TID), s:"\n",
	s:"\ciFLOOR HEIGHT    ",	f:GetActorFloorZ	(PLAYER_TID), s:"\n",

	s:"\cgDIFFICULTY  ",	i: AdventureInfo[RoundInfo[CUrrentRound]][adv_DIFFICULTY], s:"\n",
	s:"\cgROUNDS WEAPON IS ", s:ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_TEXT), s:"\n",
	s:"\cvVelocityX ", i:GetActorVelX(PLAYER_TID)>>16, s:"    VelocityY ", i:GetActorVelY(PLAYER_TID)>>16, s:"\n"

	;HUDMSG_PLAIN, 0, CR_UNTRANSLATED, 0.2, 0.7, 0.1);

	delay(1);
	}
}

*/


































/*

 __        _____ _   _ _   _ _____ ____        _   _    _    __  __ _____       _                   _
 \ \      / /_ _| \ | | \ | | ____|  _ \      | \ | |  / \  |  \/  | ____|     (_)_ __  _ __  _   _| |_
  \ \ /\ / / | ||  \| |  \| |  _| | |_) |     |  \| | / _ \ | |\/| |  _|       | | '_ \| '_ \| | | | __|
   \ V  V /  | || |\  | |\  | |___|  _ <      | |\  |/ ___ \| |  | | |___      | | | | | |_) | |_| | |_
    \_/\_/  |___|_| \_|_| \_|_____|_| \_\     |_| \_/_/   \_\_|  |_|_____|     |_|_| |_| .__/ \__,_|\__|
                                                                                       |_|

*/

/*
function bool LoggedIn (int PlayerNum)
{
bool Result;
str AccName = "";
if (PlayerIsLoggedIn(PlayerNum))
	{
	AccName = StrParam(s:GetPlayerAccountName(PlayerNum));
	}

if (StrLen(AccName) > 0) Result = true;	else Result = false;
//if (StrCmp(AccName, "") >= 0) Result = true;	else Result = false;
return Result;
}
*/


function void FillTheName (void)
{
int OldInputNameTurn = InputNameTurn;
int counter, LegendsNum, AddSpaces;
bool DecidedZAN, LongName;
str WinnerString = "";
InputNameTurn = 0;
str InitialName = "";


	if (GetPort() == Zandronum)
								{

									// Setting it for the first time ever

								BeginDBTransaction();

								if (PlayerIsLoggedIn(GAMEINFO[WinnerPlayerNum]))
									if (!StrLen(GetDBEntryString("PlayerInfo", StrParam(s:"id_", i:StrToNum(CurrentName[GAMEINFO[WinnerPlayerNum] + MaxPlayers]), s:"___MONUMENT"))))
										InitialName = StrParam(n:GAMEINFO[WinnerPlayerNum] + 1);

									else
										InitialName = GetDBEntryString("PlayerInfo", StrParam(s:"id_", i:StrToNum(CurrentName[GAMEINFO[WinnerPlayerNum] + MaxPlayers]), s:"___MONUMENT"));


								EndDBTransaction();



								}

	else 	InitialName = StrParam(n:GAMEINFO[WinnerPlayerNum] + 1);



InitialName = StripColors(InitialName);	 //Remove the colours
InitialName = StrToUpper(InitialName); // only upper letters
InitialName = StringNoEdgeSpaces(InitialName); // Remove the gaps at the start and the back

								if (GetPort() == Zandronum)		WinnerString = InitialName;

//Cleaning the Names and place -------


InputHeader = ((TempSTAGE - 1) * GAMEINFO[MaxNameChars]);
//InputHeader = (0 * GAMEINFO[MaxNameChars]); //DEBUG

		for (int a = InputHeader; 			a < InputHeader   +   GAMEINFO[MaxNameChars];  a++)
				{
				WinnerNames[a] = 32;
				//WinnerNames[InputHeader   +   GAMEINFO[MaxNameChars] + 1] = 33;
				}



// importing the name
While(counter < GAMEINFO[MaxNameChars])
	{


	Switch(GetPort())
	{
	CASE ZDaemon:
	Light_ChangeToValue(TIDRAM_WinnerNames + InputHeader + counter,  GetChar(InitialName, counter));
	WinnerNames[InputHeader + counter] = GetSectorLightLevel(TIDRAM_WinnerNames + InputHeader + counter);

	break;





	CASE Zandronum:	//Zan has 2 usages here: 	If logged in it will create a decorative Name, if not logged - Make a Normal Name ~Name
	WinnerNames[InputHeader + counter] = GetChar(WinnerString, counter);




	break;

	}






	//Replace bad chars
								if (WinnerNames[InputHeader + counter] == 92) 	WinnerNames[InputHeader + counter] = 39;  	/* \ */
								if (WinnerNames[InputHeader + counter] == 34) 	WinnerNames[InputHeader + counter] = 47;	/* " */
	if (GetPort() == ZDaemon)	if (WinnerNames[InputHeader + counter] == 126) 	WinnerNames[InputHeader + counter] = 45;	/* ~ */


	InputNameTurn++;
	counter++;
	}



	Switch(GetPort())
	{
			CASE ZDaemon: 	if (GetChar(InitialName, GAMEINFO[MaxNameChars]) 	> 0)										LongName = true;
							AddSpaces = GAMEINFO[MaxNameChars] - StrLen(InitialName); 					if (AddSpaces < 0) 	AddSpaces = 0;

			break;

			CASE Zandronum: if (GetChar(StrParam(s:WinnerString), GAMEINFO[MaxNameChars]) 			> 0) 					LongName = true;
							AddSpaces = GAMEINFO[MaxNameChars] - StrLen(StrParam(s:WinnerString)); 		if (AddSpaces < 0) 	AddSpaces = 0;
			break;
	}

// if USERNAME length > allowed, then make it a USERNA..
if (LongName)
	{
	WinnerNames[InputHeader + GAMEINFO[MaxNameChars] - 2] = 46;
	WinnerNames[InputHeader + GAMEINFO[MaxNameChars] - 1] = 46;
	}



// or if its too short add spaces
if (AddSpaces)
	{
	for (a = AddSpaces; a > 0;  a--)
	WinnerNames[GAMEINFO[MaxNameChars] - a] = 32;
	}




//return WinnerString;

}



function void FillTheNameDB (void)
{
str Monument = "";
if (GetPort() == Zandronum)
	{
	int counter = 0;	str WinnerString = "";
	while(counter < GAMEINFO[MaxNameChars])
		{
		WinnerString = StrParam(s:WinnerString, c:WinnerNames[InputHeader + counter]);
		counter++;
		}




	BeginDBTransaction();

	SetDBEntryString(StrParam(s:"Season", i:TempSEASON), 			StrParam(i:TempSTAGE, s:"___StageWinner_DATE" 			), StrParam(s: Strftime (SystemTime(), "%F", true)));

	Switch(PlayerIsLoggedIn(GAMEINFO[WinnerPlayerNum]))
			{
			CASE FALSE:		SetDBEntryString(StrParam(s:"Season", i:TempSEASON), 			StrParam(i:TempSTAGE, s:"___StageWinner_ID" 			), StrParam(s:"~", s:CurrentName[GAMEINFO[WinnerPlayerNum]]));
			break;

			CASE TRUE:
							SetDBEntry		(StrParam(s:"Season", i:TempSEASON), 			StrParam(i:TempSTAGE, s:"___StageWinner_ID" 			), StrToNum(CurrentName[GAMEINFO[WinnerPlayerNum] + MaxPlayers]));
							SetDBEntryString("PlayerInfo", StrParam(s:"id_", i:StrToNum(CurrentName[GAMEINFO[WinnerPlayerNum] + MaxPlayers]), s:"___MONUMENT"), WinnerString);
			break;
			}



	EndDBTransaction();
	}
}





Script SCRIPT_InputEnter (void)	// ENTER
{

if (InputNameTurn < MinAllowedInput)
		{
		//Print(s:"At least ", i:MinAllowedInput, s:" letters required!");
		DrawNotification(For_ActivatorOnly, StrParam(s:"At least ", i:MinAllowedInput, s:" letters required!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, noteFadeIn_None, noteHold_Short, noteFadeOut_Short);
		Terminate;
		}
GAMEINFO[InputNameTime] = BottomLine;
}



Script SCRIPT_InputBackspace (void)	// BACKSPACE
{
if (InputNameTurn <= 0) Terminate;
WinnerNames[InputHeader + InputNameTurn - 1] = 32;
InputNameTurn--;
}



Script SCRIPT_InputChar (int Char)	// BASIC CHAR
{
if ((Char == 32) && (InputNameTurn == 0))
		{
		//Print(s:"A name should start with a proper symbol");
		DrawNotification(For_ActivatorOnly, StrParam(s:"A name should start with a proper symbol"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, noteFadeIn_None, noteHold_Short, noteFadeOut_Short);
		Terminate;
		}


if (InputNameTurn >= GAMEINFO[MaxNameChars])
		{
		//Print(i:GAMEINFO[MaxNameChars], s:" letters allowed to input!");
		DrawNotification(For_ActivatorOnly, StrParam(i:GAMEINFO[MaxNameChars], s:" letters allowed to input!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, noteFadeIn_None, noteHold_Short, noteFadeOut_Short);
		Terminate;
		}

if (InputNameTurn > GAMEINFO[MaxNameChars] - 1) Terminate;
WinnerNames[InputHeader + InputNameTurn] = Char;
InputNameTurn++;
}







Script "BuyAccessory"	(int Product, int IsAutoBuy)	NET//Script SCRIPT_Buy	(int Product)
{
int Cost;
bool IsAbility;

if (GetCVAR("ER_DebugMode") == 3) 	Cost = 0;
else 								Cost = GetProductProperties(Product, 1);


//if (GetPort() == ZDaemon) Cost = Cost -1;	//no fucking idea


int Count = 	GetProductProperties(Product, 2);
int Skript = 	GetProductProperties(Product, 3);


int PlayerMoney = GetSectorLightLevel(TIDRAM_Money + PlayerNumber());

if (PlayerMoney >= Cost)
			{
			//Light_ChangeToValue(TIDRAM_Money + PlayerNumber(), PlayerMoney - Cost);
			//TakeInventory(Money, Cost);
			if ((Product >= id_MinAbility)	&& 	(Product <= id_MaxAbility))		{	IsAbility = TRUE;	Light_ChangeToValue(TIDRAM_Ability + PlayerNumber(), 0);	}				//	TakeInventory(Ability, MaxByte);	//Replace Ability
			Switch(IsAbility)
				{
				case False:		GiveInventory(ActorString(Product, as_CODE), Count);					break;
				case True:		Light_ChangeToValue(TIDRAM_Ability + PlayerNumber(), Count);			break;
				}


			RegisterPlayer(PlayerNumber(), -Cost, DOESNT_MATTER);
			DrawNotification(For_ActivatorOnly, StrParam(s:"You bought ", s:ActorString(Product, as_TEXT), s:"!"), 		notepose_SPECIAL, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "j", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
			Log(s:StrToUpper(StripColors(StrParam(n:0))), s:"\cj bought ", s:ActorString(Product, as_TEXT), s:".");		//n:0
			LocalAmbientSound("SFXBUY", 127);

			//if (Skript) ACS_NamedExecuteAlways(GetProductSkript(Skript), 0, PlayerNumber());
			if (Skript) 	ClientScript(PlayerNumber(), GetProductSkript(Skript), 0, 0, 0);

			}

else
			{
			DrawNotification(For_ActivatorOnly, StrParam(s:"Not enough money! Collect $", i:Cost - PlayerMoney, s:"!"), 		notepose_SPECIAL, notepara_ALIGN, ICON_Sad, StrParam(c:ICON_Sad), "j", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
			LocalAmbientSound("SFXCANCE", 127);
			}
if (IsAutoBuy)
	DrawNotification(For_ActivatorOnly, StrParam(s:"AUTO-BUY:"), 		notepose_EDGETOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_None), "c", "ERFONT",  OFF, ON, noteFadeIn_Short, noteHold_Short, noteFadeOut_Short);
}








/*
  __  __ ______  _____ _____         _____ ______  _____
 |  \/  |  ____|/ ____/ ____|  /\   / ____|  ____|/ ____|
 | \  / | |__  | (___| (___   /  \ | |  __| |__  | (___
 | |\/| |  __|  \___ \\___ \ / /\ \| | |_ |  __|  \___ \
 | |  | | |____ ____) |___) / ____ \ |__| | |____ ____) |
 |_|  |_|______|_____/_____/_/    \_\_____|______|_____/


*/







Script "MSG_MinLettersReq" (int Mins) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"At least ", i:Mins, s:" letters required!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, 0, 2.0, 0);
}


Script "MSG_ManyBlanks" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"Too many blank letters!"), 		notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_EXCLAMATION), "g", "ERFONT",  OFF, OFF, 0, 2.0, 0);
}




Script "MCR_KillWhileDeploying" (void)
{
while(true)
	{
										for (int b = 0; b < MaxPlayers;  b++)
												if((PlayerStatus(b) == ps_PLAYGROUND) && (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] == adventure_FLOW))
														{
														if 	(
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniStartpoint],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[MiniFinishpoint],	0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[FinishpointTAG],		0, 0, 0) == false) &&
															(CheckActorPosition(PLAYER_TID + b, pos_ByActorPos, 320, RoundInfo[StartpointTAG],		0, 0, 0) == false)
															)
															Thing_Damage(PLAYER_TID + b, InstantDeath, MOD_WATER);

														}
	delay(1);
	}

}




/*
  _____            _   _ _____   ____  __  __       ________      ________ _   _ _______ _____
 |  __ \     /\   | \ | |  __ \ / __ \|  \/  |     |  ____\ \    / /  ____| \ | |__   __/ ____|
 | |__) |   /  \  |  \| | |  | | |  | | \  / |     | |__   \ \  / /| |__  |  \| |  | | | (___
 |  _  /   / /\ \ | . ` | |  | | |  | | |\/| |     |  __|   \ \/ / |  __| | . ` |  | |  \___ \
 | | \ \  / ____ \| |\  | |__| | |__| | |  | |     | |____   \  /  | |____| |\  |  | |  ____) |
 |_|  \_\/_/    \_\_| \_|_____/ \____/|_|  |_|     |______|   \/   |______|_| \_|  |_| |_____/


*/

Script "MSG_WormsNotify" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"BE CAREFUL! WORMS ARE FLOATING IN THE WATER!"), notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
}

Script "MSG_BombNotify" (void) CLIENTSIDE
{
DrawNotification(For_ActivatorOnly, StrParam(s:"SURFACE SEEMS TO BE FRAGILE... MIND THE SAFE FLOORS!"), notepose_MID, notepara_ALIGN, ICON_EXCLAMATION, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
}





Script "RandomEvent"	(int Which)
{
int counter, Time, Direction, Deelay, w, i, A;

Switch(Which)
		{
		CASE DOESNT_MATTER:	//abort events here
			ReplaceTextures(TextureIs(FlatWATEtx), TextureIs(FlatBASEtx));
			ReplaceTextures(TextureIs(FlatBOMBtx), TextureIs(FlatBASEtx));
			ReplaceTextures(TextureIs(FlatWORMtx), TextureIs(FlatBASEtx));
			ReplaceTextures(TextureIs(FlatICEYtx), TextureIs(FlatBASEtx));
			ReplaceTextures(TextureIs(FlatMUDDtx), TextureIs(FlatBASEtx));
		break;



		CASE None:	//No events this round.

		if (AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE] != adventure_FLOW)
			ReplaceTextures(TextureIs(FlatWATEtx), TextureIs(FlatBASEtx));
			RoundInfo[WormsRestart] = TRUE;
			RoundInfo[SoilRestart] = TRUE;
		break;


		CASE event_BOMB:

				While(TRUE)
					{
					Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])	{ Case adventure_BOSS:	delay(SEC*15);	break;	Case adventure_MAZE:	Case adventure_LINEAR:	delay(SEC*60);	break;	}

					//AmbientSound("SFXBOMB", 127);
					for(w = 0; w < PlaygroundBlocks; w++)
											{
											RefreshSpotHeight(refreshspot_DEFAULT, TagAt (w + 1, ToRIGHT, 28));
											//SpawnSpotForced("MapSpot", TagAt (a + 1, ToRIGHT, 28), ACTORTID_AmbientWater, 0);
											ThingSound(TagAt (w + 1, ToRIGHT, 28), "SFXBOMB", 127);
											}

					Time = 13;
					counter = Time;
					while (counter > 0)
							{
							counter--;
							DrawNotification(For_Everyone, StrParam(s:"THE GROUND WILL COLLAPSE IN...", i:counter, s:"!"), notepose_MID, notepara_ALIGN, ICON_None, StrParam(c:ICON_HEADER_Clock + ((FixedDiv(Int2Fix(counter), Int2Fix(Time))* 100) >> 16)/10), "g", "ERFONT",  OFF, ON, 0.0, 1.0, 1.0);
							delay(SEC);
							}

					ReplaceTextures(TextureIs(FlatBASEtx), TextureIs(FlatBOMBtx));
					ReplaceTextures(TextureIs(FlatWATEtx), TextureIs(FlatBOMBtx));
					ReplaceTextures(TextureIs(FlatICEYtx), TextureIs(FlatBOMBtx));
					ReplaceTextures(TextureIs(FlatMUDDtx), TextureIs(FlatBOMBtx));

					Switch(AdventureInfo[RoundInfo[CurrentRound]][adv_TYPE])	{ Case adventure_BOSS:	delay(SEC*RNG(2,3));	break;	Case adventure_MAZE:	Case adventure_LINEAR:	delay(SEC*5);	break;	}

					ReplaceTextures(TextureIs(FlatBOMBtx), TextureIs(FlatBASEtx));
					RoundInfo[WormsRestart] = TRUE;
					RoundInfo[SoilRestart] = TRUE;
					}

		break;

		}
}





function void ClientScript	(int Client, str ScriptName, int arg1, int arg2, int arg3)
{
SetActivator(PLAYER_TID + Client);

if (ClientExist(Client))
	{
	Switch(GetPort())
		{
		Case ZDaemon:			Client_NamedExecute(Client, ScriptName, 0, 			arg1, arg2, arg3 );			break;
		Case Zandronum:			NamedExecuteClientScript(ScriptName, Client, 		arg1, arg2, arg3 );			break;
		Case GZDoom:			ACS_NamedExecute(ScriptName, 0, 					arg1, arg2, arg3 );			break;
		}
	}

SetActivator(0, AAPTR_NULL);
}



Script "PlayerScreenFade" (int color, int TimeHold, int TimeOut) CLIENTSIDE
{
ScreenFade(For_ActivatorOnly, 1.0, color, 0.0, TimeHold, TimeOut);
}


function void ScreenFade (int Who, int Alpha, int Color, int TimeIn, int TimeHold, int TimeOut)
{
str cl = "";

Switch(Color)
		{
		CASE CR_BLACK:		Color = ICON_BlackScreen;	cl = "\cm";		break;
		CASE CR_WHITE:		Color = ICON_WhiteScreen;	cl = "\cj";		break;
		CASE CR_RED:		Color = ICON_Slider;		cl = "\cr";		break;
		}

SetHUDSize(HUDX_FULLSCREEN, HUDY_FULLSCREEN, FALSE);		SetFont("ERICON");

Switch(GetPort())
	{
	CASE ZDaemon:
	CASE Zandronum:
		Switch(Who)
				{
				CASE For_ActivatorOnly:
				HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 1, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 2, CR_UNTRANSLATED, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 3, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessage(		s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 4, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				break;
				CASE For_Everyone:
				CASE For_ClientOnly:
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 1, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 2, CR_UNTRANSLATED, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 3, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 4, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				break;
				}
	break;

	CASE GZDoom:
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 0, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN -8),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 1, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN -8),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 2, CR_UNTRANSLATED, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN -8),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 3, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN -8),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 4, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN -8),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 5, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 6, CR_UNTRANSLATED, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 7, CR_UNTRANSLATED, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 8, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);
				HudMessageBold(	s:cl, c:Color;		HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_ScreenFade + 9, CR_UNTRANSLATED, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	TimeHold, TimeIn, TimeOut, Alpha);

	break;
	}



}









function int GetProductProperties (int Id, int Param)
{
int Cost, Count, Result, SkriptNum, Type, Currency;
//TYPE 0 - normal, 1 == special
//CUrrency 1 = Money, 2 = WinPoints
Switch(Id)
	{
	CASE id_Shotgun:			Cost = 5;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_Chaingun:			Cost = 10;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_SuperShotgun:		Cost = 15;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_Railgun:			Cost = 30;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_RocketLauncher:		Cost = 40;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_PlasmaRifle:		Cost = 50;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_BFG9000:			Cost = 100;		Count = 1;		Type = 0;	Currency = 1;	break;

	CASE id_Clip:				Cost = 2;		Count = 10;		Type = 0;	Currency = 1;	break;
	CASE id_ClipBox:			Cost = 4;		Count = 50;		Type = 0;	Currency = 1;	break;
	CASE id_Shell:				Cost = 2;		Count = 4;		Type = 0;	Currency = 1;	break;
	CASE id_ShellBox:			Cost = 4;		Count = 20;		Type = 0;	Currency = 1;	break;
	CASE id_RocketAmmo:			Cost = 2;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_RocketBox:			Cost = 8;		Count = 5;		Type = 0;	Currency = 1;	break;
	CASE id_Cell:				Cost = 4;		Count = 20;		Type = 0;	Currency = 1;	break;
	CASE id_CellPack:			Cost = 10;		Count = 100;	Type = 0;	Currency = 1;	break;
	CASE id_Backpack:			Cost = 35;		Count = 1;		Type = 0;	Currency = 1;	break;
	//if (GetPort() > ZDaemon)	SkriptNum = 3;												break;
	CASE id_Stimpack:			Cost = 2;		Count = 10;		Type = 0;	Currency = 1;	break;
	CASE id_Medkit:				Cost = 5;		Count = 25;		Type = 0;	Currency = 1;	break;
	CASE id_Soulsphere:			Cost = 50;		Count = 100;	Type = 0;	Currency = 1;	break;

	CASE id_AllMap:				Cost = 10;		Count = 1;		Type = 0;	Currency = 1;	break;

	CASE id_ArmorBonus:			Cost = 10;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_GreenArmor:			Cost = 25;		Count = 1;		Type = 0;	Currency = 1;	break;
	CASE id_BlueArmor:			Cost = 40;		Count = 1;		Type = 0;	Currency = 1;	break;

	CASE id_GenCam:

	Currency = 1;
	if (GetPort() == ZDaemon)	{	Cost = 0;		Count = 0;			Type = 0;	}
	else						{	Cost = 3;		Count = id_GenCam;	Type = 1;	}
	break;

	CASE id_SourceCode:
	Type = 1;
	Currency = 1;
	if (GetPort() == ZDaemon)	{	Cost = 9999;	Count = 0;				}
	else						{	Cost = MaxMoney + 1;	Count = 0;	/*	SkriptNum = 1;*/}
	break;


	CASE id_ChaseCam:
	Type = 1;
	Currency = 1;
	if (GetPort() == ZDaemon)	{	Cost = 9999;	Count = 0;				}
	else						{	Cost = 5;		Count = id_ChaseCam;	}
	break;

	CASE id_DroneCam:
	Type = 1;
	Currency = 1;
	if (GetPort() == ZDaemon)	{	Cost = 9999;	Count = 0;				}
	else						{	Cost = 25;		Count = id_DroneCam;	}
	break;

	CASE id_MoneyTransfer:
	Type = 1;
	Currency = 1;
/*	if (GetPort() == ZDaemon)	{	Cost = 9999;	Count = 0;					}
	else*/						{	Cost = 0;		Count = id_MoneyTransfer;	}
	break;

	CASE id_Advertisement:
	Type = 1;
	Currency = 1;
	//if (GetPort() == ZDaemon)	{	Cost = 0;																				Count = id_Advertisement;	}
	if (GetPort() == ZDaemon)	{	Cost = MaxMoney - GetSectorLightLevel(TIDRAM_Try)*4;	if (Cost < 0)	Cost = 0;		Count = id_Advertisement;	}
	else						{	Cost = 0;																				Count = id_Advertisement;	}
	break;

	CASE id_EnemyLocator:
	Type = 1;
	Currency = 1;
	/*if (GetPort() == ZDaemon)	{	Cost = 9999;	Count = 0;					}
	else*/						{	Cost = 0;		Count = id_EnemyLocator;	}
	break;

	}

Switch(Param)
	{
	CASE 1:	Result = Cost;			break;
	CASE 2: Result = Count;			break;
	CASE 3: Result = SkriptNum;		break;
	CASE 4: Result = Type;			break;
	CASE 5: Result = Currency;		break;
	}

return Result;
}






function str GetProductSkript (int SkriptNum)
{
str Result = "";
Switch(SkriptNum)
	{
	CASE 1: Result = "SourceCodeRequest";		break;
	CASE 2: Result = "SourceCodeRequest";		break;
	CASE 3: Result = "BackpackPickUp";			break;
	}
return Result;
}








Script "BackpackPickUp" (void)
{
SetAmmoCapacity("Clip", 		400);		GiveInventory("Clip", 			10);
SetAmmoCapacity("Shell", 		100);		GiveInventory("Shell", 			4);
SetAmmoCapacity("RocketAmmo", 	100);		GiveInventory("RocketAmmo", 	1);
SetAmmoCapacity("Cell", 		600);		GiveInventory("Cell", 			20);
}






function void EntryTeleportWarning (void)
{
int Alpha = FixedDiv(0.75, int2fix(JoinTime));
	Alpha = FixedMul(int2fix(JoinTime - GetSectorLightLevel(TIDRAM_JoinTimeLeft)), Alpha);
	//log(f:Alpha);
	ScreenFade(For_ClientOnly, Alpha, CR_RED, 0.0, 0.0, 0.25);
int Color; if (RNG(False, True)) Color = CR_RED;	else Color = CR_GOLD;


SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
SetFont("ERICON");
HudMessageBold(c:ICON_Exit;	HUDMSG_FADEOUT, 															HUDid_JOIN_ICON + ClientPlayerNumber(), 	Color, int2fix(X_MIDDLE_ICON - X_JOINTIMEOFFSET), 		int2fix(Y_MIDDLE_ICON), ClientMsgDelay, 0.25);
SetFont("ERFONT");
HudMessageBold(s:PrintClock(GetSectorLightLevel(TIDRAM_JoinTimeLeft) -1);	HUDMSG_FADEOUT, 			HUDid_JOIN_LETTER + ClientPlayerNumber(),	Color, int2fix(X_MIDDLE_LETTER - X_JOINTIMEOFFSET), 	int2fix(Y_MIDDLE_LETTER), ClientMsgDelay, 0.25);
SetFont("ERICON");
HudMessageBold(s:"aggggggggr\neiiiiiiiit\nchhhhhhhhs";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 				HUDid_JOIN_BACK + ClientPlayerNumber(),		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK - X_JOINTIMEOFFSET), 		int2fix(Y_MIDDLE_BACK), ClientMsgDelay, 0.25, 0.25);

}




Script "SourceCode" (void)
{
SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
SetFont("ERFONT");
print(s:"CHEATER XD");
}


#libdefine MaxProducts	26

function int GetProductCatalogue (int Num)
{
int Result;

Switch(Num)
	{
	CASE -1:	Result = id_None;				break;
	CASE 0:		Result = id_EnemyLocator;		break;
	CASE 1:		Result = id_ChaseCam;			break;
	CASE 2:		Result = id_DroneCam;			break;
	CASE 3:		Result = id_GenCam;				break;
	CASE 4:		Result = id_AllMap;				break;
	CASE 5: 	Result = id_Shotgun;			break;
	CASE 6: 	Result = id_SuperShotgun;		break;
	CASE 7: 	Result = id_Chaingun;			break;
	CASE 8: 	Result = id_Railgun;			break;
	CASE 9: 	Result = id_RocketLauncher;		break;
	CASE 10: 	Result = id_PlasmaRifle;		break;
	CASE 11: 	Result = id_BFG9000;			break;
	CASE 12: 	Result = id_ClipBox;			break;
	CASE 13: 	Result = id_ShellBox;			break;
	CASE 14:	Result = id_RocketBox;			break;
	CASE 15:	Result = id_CellPack;			break;
	CASE 16:	Result = id_RocketBox;			break;
	CASE 17:	Result = id_Backpack;			break;
	CASE 18:	Result = id_Stimpack;			break;
	CASE 19:	Result = id_Medkit;				break;
	CASE 20:	Result = id_Soulsphere;			break;
	CASE 21:	Result = id_ArmorBonus;			break;
	CASE 22:	Result = id_GreenArmor;			break;
	CASE 23:	Result = id_BlueArmor;			break;
	CASE 24:	Result = id_Advertisement;		break;
	CASE 25:	Result = id_MoneyTransfer;		break;
	//CASE 26:	Result = id_SourceCode;			break;
	}
return Result;
}
















/*



  ______  __       __   _______ .__   __. .___________.    _______. __   _______   _______
 /      ||  |     |  | |   ____||  \ |  | |           |   /       ||  | |       \ |   ____|
|  ,----'|  |     |  | |  |__   |   \|  | `---|  |----`  |   (----`|  | |  .--.  ||  |__
|  |     |  |     |  | |   __|  |  . `  |     |  |        \   \    |  | |  |  |  ||   __|
|  `----.|  `----.|  | |  |____ |  |\   |     |  |    .----)   |   |  | |  '--'  ||  |____
 \______||_______||__| |_______||__| \__|     |__|    |_______/    |__| |_______/ |_______|


*/


/*
for (int a = 0; a < 32787;  a++) {
  if (a == 11 || a == 22 || a ==33) {//this is your exception
    continue; //do nothing and progress with the loop
  }
  DoStuff(); //do the stuff you need here
}
*/

#libdefine	MaxValidHostNames					2

function str ValidHostName (int Index)
{
str Result = "";
Switch(Index)
	{
	case 1:	Result = " (ALPHA TESTING)";		break;
	case 2:	Result = " (FLOORS F!XED)";			break;
	}

return Result;
}




SCRIPT "CLIENTZDA" OPEN
{
int counter, i;
int consoleCheats			= GetCvar("sv_cheats");
str String = "";
delay(1);
while(!GetSectorLightLevel(TIDRAM_MapReset))
		{
		if (GetPort() == ZDaemon)
			{
			for (i = 0; i <= PlayerTopIndex();  i++)
				{
				if (ClientExist(i))		Client_NamedExecute(i, "CLIENTLOGIC", 0);
				}

			//EXCLUSIVITY
			if (Deploying)
			if (NetMode() > 1)
				{
				for (i = 1; i <= MaxValidHostNames;  i++)
					{
					String = StrParam(s:"[LA] ENDLESS RELENTLESS: live-generated survival adventures", s:ValidHostName(i));
					if (!StrICmp(GetCVarString("hostname"), String))		break;

					else
							{
							if (i >= MaxValidHostNames)
								{
								delay(SEC*(RNG(10, 20)));
								Printbold(s:"Generation error detected, restarting map...\n\n(BLOCK #", i:RNG(1, 25), s:", ", s:"X", i:RNG(-1408, 1408), s:"Y", i:RNG(-1408, 1408),s:")");
								delay(SEC*5);
								MapReset();
								break;
								}

							}
					}

				}


			}



		/*
		   ____ _   _ _____    _  _____ _____ ____    _
		  / ___| | | | ____|  / \|_   _| ____|  _ \  | |
		 | |   | |_| |  _|   / _ \ | | |  _| | | | | | |
		 | |___|  _  | |___ / ___ \| | | |___| |_| | |_|
		  \____|_| |_|_____/_/   \_\_| |_____|____/  (_)
		*/
		if (GetPort() == Zandronum)
			if (IsNetworkGame())
				if ((consoleCheats != GetCvar("sv_cheats"))	 || (GetCvar("sv_cheats")) || (GetCvar("ER_reset")))
					{
					BeginDBTransaction();
					//remove money
					counter = 0;
					while(counter <= ServerInfo[RegisteredPlayers])
								{
								i = 0;
								while (i < MaxPortNameCharsZAN)
									{
									MoneyNAME[counter * MaxPortNameCharsZAN + i] = None;
									i++;
									}
								SetDBEntryString(	"PlayerInfo",	StrParam(s:"id_", i:counter, s:"___ACCOUNT"), 	""	);
								SetDBEntryString(	"PlayerInfo", 	StrParam(s:"id_", i:counter, s:"___FLAG"), 		"-1");
								SetDBEntry(			"PlayerInfo", 	StrParam(s:"id_", i:counter, s:"___MONEY"), 	0	);
								SetDBEntry(			"PlayerInfo", 	StrParam(s:"id_", i:counter, s:"___FLAG_cost"), 0	);

								counter++;
								}

					ServerInfo[RegisteredPlayers] = None;
					SetDBEntry("ServerInfo", "RegisteredPlayers", None);
					EndDBTransaction();
					if (!GetCvar("ER_reset"))	ServerInfo[CHEATED] = TRUE;
					ConsoleCommand("ER_reset 0");
					ServerInfo[STAGE] = FALSE;
					ServerInfo[SEASON] = FALSE;
					ServerInfo[TRY] = FALSE;

					//remove season winners
					counter = 0;
					While (counter <= MaxStages)
						{
						counter++;
						SetDBEntry		(StrParam(s:"Season", i:ServerInfo[SEASON]),	StrParam(i:counter, s:"___StageWinner_ID"	), -1);


						i = 0;
							While(i < GAMEINFO[MaxNameChars])
								{
								WinnerNames[(counter - 1)*GAMEINFO[MaxNameChars] + i] = 0;
								i++;
								}
						}


					}




		/*
		  ____  _____ ____ ___ ____ _____ _____ ____      ____  _        _ __   _______ ____  ____
		 |  _ \| ____/ ___|_ _/ ___|_   _| ____|  _ \    |  _ \| |      / \\ \ / / ____|  _ \/ ___|
		 | |_) |  _|| |  _ | |\___ \ | | |  _| | |_) |   | |_) | |     / _ \\ V /|  _| | |_) \___ \
		 |  _ <| |__| |_| || | ___) || | | |___|  _ <    |  __/| |___ / ___ \| | | |___|  _ < ___) |
		 |_| \_\_____\____|___|____/ |_| |_____|_| \_\   |_|   |_____/_/   \_\_| |_____|_| \_\____/

		*/

		counter = 0;
		while(counter < MaxPlayers)
			{
			if (ClientExist(counter)) CurrentName[counter] = StrParam(n:counter + 1);		else	{CurrentName[counter] = "";			CurrentName[counter + MaxPlayers] = "-1";	}
			RegisterPlayer(counter, FALSE, DOESNT_MATTER);
			counter++;
			}

		delay(SEC);
		if(GetPort() == ZDaemon)	if (PlayerStatus(-1) > ps_DEAD)		if(GAMEINFO[AbsoluteTime] > 60)		if(!GetSectorLightLevel(TIDRAM_CantJoinZDA))		Light_ChangeToValue(TIDRAM_CantJoinZDA, TRUE);
		GAMEINFO[AbsoluteTime]++;

		//if(GetSectorLightLevel(MGRAM_Sequence) > 0)			Light_ChangeToValue(MGRAM_Sequence, GetSectorLightLevel(MGRAM_Sequence) - 1);
		}
}






SCRIPT "CLIENTZAN" OPEN CLIENTSIDE
{
delay(1);

	// because there was a 1 tic delay GAMEINFO[PortIs] should be above 0 by now;
	if (!GAMEINFO[PortIs]) // // This line will only work in Zandronum multiplayer for each connecting player
			{
			SetActivatorToPlayer(ClientPlayerNumber());
			ACS_NamedExecute("CLIENTLOGIC", 0);
			ACS_NamedExecute("CLIENTONCE", 0);
			ACS_NamedExecute("UACCOUNT", 0);
			}

	//and this will work in Zandronum singleplayer and zdaemon but there is no action for it here
	if (GetPort() == GZDoom)		Terminate;
	if (GetPort() == Zandronum)	if (!IsNetworkGame()) 			{

																SetActivatorToPlayer(ClientPlayerNumber());
																ACS_NamedExecute("CLIENTLOGIC", 0);

																}
}

/*
Script "Continue_CLIENTLOGIC" (int PlayerNum) DISCONNECT
{
	if (GetPort() == Zandronum)
    if(PlayerIsSpectator(PlayerNum))
    {
        //Spectator
        NamedExecuteClientScript("CLIENTLOGIC", PlayerNum, 0, 0, 0);
    }
}
*/

function void ClientScreen (int TURN)
{
int img;

Switch(TURN)
		{
		CASE ON:		img = ICON_BlackScreen;		break;
		CASE OFF:		img = ICON_None;			break;
		}

SetHUDSize(HUDX_FULLSCREEN, HUDY_FULLSCREEN, FALSE);		SetFont("ERICON");


		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback1, CR_BLACK, int2fix(X_FULLSCREEN - 16), 	int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback2, CR_BLACK, int2fix(X_FULLSCREEN - 8), 	int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback3, CR_BLACK, int2fix(X_FULLSCREEN), 		int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback4, CR_BLACK, int2fix(X_FULLSCREEN + 8), 	int2fix(Y_FULLSCREEN),  	0.05);
		HudMessage(		c:img;		HUDMSG_PLAIN, HUDid_MGback5, CR_BLACK, int2fix(X_FULLSCREEN + 16), 	int2fix(Y_FULLSCREEN),  	0.05);
}













/*

function int GetCellProperty (int Which, int Cell)
{
int Result;
Switch(Which)
	{
	CASE gcp_PLAYER:	Result = GetSectorLightLevel(MGRAM_Player 	+ Cell);
	CASE gcp_UNIT:		Result = GetSectorLightLevel(MGRAM_Unit 	+ Cell);
	CASE gcp_POWER:		Result = GetSectorLightLevel(MGRAM_Power 	+ Cell);
	CASE gcp_SALE:		Result = GetSectorLightLevel(MGRAM_Sale		+ Cell);
	}

return Result;
}


function int GetSliderSpeed (int Power)
{
int Result;

if 				(Power <  90)								Result = 1;
else if 	(	(Power >= 90)	&&	(Power <180)	)		Result = 2;
else if 	(	(Power >=180)	&&	(Power <270)	)		Result = 3;
else if 	(	(Power >=270)	&&	(Power <360)	)		Result = 4;
else if 	(	(Power >=360)	&&	(Power <450)	)		Result = 5;
else if 	(	(Power >=450)	&&	(Power <640)	)		Result = 6;
else														Result = 7;


return Result;
}

*/
/*
function int GetUnitProperty (int Which, int Cell)
{
int Result;
Switch(Which)
	{
	CASE gcp_PLAYER:	Result = GetSectorLightLevel(MGRAM_Player 	+ Cell);
	CASE gcp_UNIT:		Result = GetSectorLightLevel(MGRAM_Unit 	+ Cell);
	CASE gcp_POWER:		Result = GetSectorLightLevel(MGRAM_Power 	+ Cell);
	CASE gcp_SALE:		Result = GetSectorLightLevel(MGRAM_Sale		+ Cell);
	}

return Result;
}

*/

function void ClientCall (str ScriptName, int arg1, int arg2, int arg3)
{
Switch(GetPort())
	{
	Case ZDaemon:			Server_NamedExecuteAlways(ScriptName, 0, 	arg1, arg2, arg3);					break;
	Case Zandronum:			NamedRequestScriptPuke(ScriptName, 			arg1, arg2, arg3);					break;
	Case GZDoom:			ACS_NamedExecute(ScriptName, 0, 			arg1, arg2, arg3);					break;
	}
}

//----------------------------------------------------------------------
//----------------------------------------------------------------------
function int combixxx (int Curr)
{
int Result, Button;

Switch(Curr)
	{
	CASE 0: 	Button = BT_FORWARD; 		break;
	CASE 1: 	Button = BT_FORWARD; 		break;
	CASE 2: 	Button = BT_BACK; 			break;
	CASE 3: 	Button = BT_BACK; 			break;
	CASE 4: 	Button = BT_MOVELEFT; 		break;
	CASE 5: 	Button = BT_MOVERIGHT; 		break;
	CASE 6: 	Button = BT_MOVELEFT; 		break;
	CASE 7: 	Button = BT_MOVERIGHT; 		break;
	CASE 8: 	Button = BT_SHOWSCORES; 	break;
	CASE 9: 	Button = BT_USE; 			break;
	CASE 10: 	Button = BT_CROUCH; 		break;
	}

/*Switch(Which)
	{
	CASE 0: */Result = Button;/* break;
	CASE 1: Result = Curr;	 break;
	}
*/
return Result;
}



//----------------------------------------------------------------------
//----------------------------------------------------------------------








function int GetClientSpectateStatus (int ClientPlayerNum)
{
int Result;

Switch(GetPort())
	{
	CASE ZDaemon:
	CASE Zandronum:
	Result = PlayerIsSpectator(ClientPlayerNum);
	break;

	CASE GZDoom:
	Result = FALSE;
	}
return Result;
}




function int ClientPlayerNumber (void)
{
int Result;

Switch(GetPort())
	{
	CASE ZDaemon:
	CASE Zandronum:
	Result = ConsolePlayerNumber();
	break;

	CASE GZDoom:
	Result = PlayerNumber();
	}
return Result;
}




function int GetShopSelection (int Pitch, int Max)
{
Pitch = Pitch + MaxClientPitch;
int counter, Num;
int Segment = (MaxClientPitch*2)/Max;


while(counter < Max)
	{

	if (Pitch <= 0) break;		//0


	if ((Pitch >= Segment*counter) && (Pitch < Segment*(counter + 1)))	break;
	counter++;
	}
if (counter >= Max) counter = Max - 1;
return counter;
}



//--------------------------------------------------------------------------------

#libdefine MaxTransferProducts	10

function int GetTransferCatalogue (int Num)
{
int Result;
Result = Num*4;
return Result;
}



function int GetAddColors (int Num)
{
int Result;
Switch(Num)
	{
	CASE 1: 	Result =	CR_BRICK;		break;
	CASE 2: 	Result =	CR_TAN;			break;
	CASE 3: 	Result =	CR_GRAY;		break;
	CASE 4: 	Result =	CR_GREEN;		break;
	CASE 5: 	Result =	CR_BROWN;		break;
	CASE 6: 	Result =	CR_GOLD;		break;
	CASE 7: 	Result =	CR_GRAY;		break;
	CASE 8: 	Result =	CR_GRAY;		break;
	CASE 9: 	Result =	CR_GRAY;		break;
	CASE 10: 	Result =	CR_GRAY;		break;
	CASE 3: 	Result =	CR_GRAY;		break;
	}
return Result;
}

//-------------------------------------------------------















Script "Client_ExitShop" (int Password) NET		{	if (!PasswordMatch(Password))	Terminate;		SetActorPitch(PLAYER_TID + PlayerNumber(), 0);}






Script "TransferMoney" (int Password, int MoneyAmmount, int TargetNum) NET
{
if (!PasswordMatch(Password))	Terminate;
int FinalMoney = MoneyAmmount - MoneyAmmount/MoneyTransferFeeInt;
//log(s:"A ", i:MoneyAmmount, s:"B ", i:TargetNum);
if (GetSectorLightLevel(TIDRAM_Money + PlayerNumber()) >= MoneyAmmount)
	{
	RegisterPlayer(PlayerNumber(),	-MoneyAmmount, DOESNT_MATTER);
	RegisterPlayer(TargetNum, 		FinalMoney, DOESNT_MATTER);
	//GiveActorInventory(PLAYER_TID + TargetNum, Money, FinalMoney);
	DrawNotification(For_ActivatorOnly, StrParam(s:"You've transfered $", i:FinalMoney, s:" to ", n:TargetNum + 1, s:"."), 		notepose_BOT, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "f", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
	ClientScript(TargetNum, "ReceivedMoney", PlayerNumber(), MoneyAmmount, TargetNum);
	LocalAmbientSound("SFXBUY", 127);
	}
}



Script "ReceivedMoney" (int PlayerNum, int MoneyAmmount, int TargetNum) CLIENTSIDE
{
AmbientSound("SFXBUY", 127);
DrawNotification(For_ActivatorOnly, StrParam(s:"You've received $", i:MoneyAmmount, s:" from ", s:StripColors(StrParam(n:PlayerNum + 1)), s:"!"), 		notepose_BOT, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "f", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
}






/*
function int AbilityIs (void)
{
int Result;

if (CheckInventory(ActorString(id_ChaseCam, as_CODE)))	Result = id_ChaseCam;
if (CheckInventory(ActorString(id_DroneCam, as_CODE)))	Result = id_DroneCam;

return Result;
}
*/

/*
function bool CarriesAbility (int Comparable)
{
int Result, Carries, counter;


		if (CheckInventory(ActorString(id_ChaseCam, as_CODE)))	Carries = id_ChaseCam;
else	if (CheckInventory(ActorString(id_DroneCam, as_CODE)))	Carries = id_DroneCam;

if (Carries >= id_minAbility)
	{
	counter = id_minAbility;
	while (counter <= id_maxAbility)
		{
			if (Counter != Carries)
				if (CheckInventory(ActorString(counter, as_CODE)))	{Result = TRUE;		break;}

		counter++;
		}
	}



return Result;
}
*/


function bool CarriesAbility (int Comparable, int PlayaNum)
{
int Result;


//if (CheckInventory(Ability) != Comparable)	Result = TRUE;
if (GetSectorLightLevel(TIDRAM_Ability + PlayaNum)	 != Comparable)		Result = TRUE;

return Result;
}


function int RandomMarkerColor (void)
{int Result;	Switch(RNG(0,2))	{CASE 0:	Result = CR_YELLOW;	break;		CASE 1:	Result = CR_ORANGE;	break;		CASE 2:	Result = CR_BRICK;	break;}	return Result;}



function void LogInNotification (void)
{
	DrawNotification(For_ActivatorOnly, StrParam(s:"YOU NEED TO LOG IN TO SAVE YOUR MONEY, STATS AND VICTORIES!"), 				notepose_TOP,	notepara_ALIGN, ICON_EXCLAMATION,	StrParam(c:ICON_Exclamation),			"q", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
	DrawNotification(For_ActivatorOnly, StrParam(s:"Go to  ->  OPTIONS  ->  ''RELENDLESS''   for instructions."),				notepose_MID,	notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 					"q", "ERFONT",  OFF,  OFF, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);

/*
	DrawNotification(For_ActivatorOnly, StrParam(s:"YOU NEED TO LOG IN TO SAVE YOUR MONEY, STATS AND VICTORIES!"), 				notepose_SPECIAL,	notepara_ALIGN, ICON_EXCLAMATION,	StrParam(c:ICON_Exclamation),			"q", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
	DrawNotification(For_ActivatorOnly, StrParam(s:"Register an account at   HTTP://AUTH.ZANDRONUM.COM/REGISTER"),				notepose_TOP,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"d", "ERFONT",  ON,  OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
	DrawNotification(For_ActivatorOnly, StrParam(s:"Then, type this command in console to enable auto-logging:"),				notepose_MID,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"q", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
	DrawNotification(For_ActivatorOnly, StrParam(s:"er_account \"", s:"login     YourUsername    YourPassword\""),				notepose_BOT,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"d", "ERFONT",  ON,  OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
	DrawNotification(For_ActivatorOnly, StrParam(s:"with upper and lowercase letters from your login and password!"),		notepose_VBOT,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"q", "ERFONT",  OFF,  OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);

*/

	}

//DrawNotification(For_ActivatorOnly, StrParam(s:"Bind a key via console command to automate logging:"),						notepose_MID,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"q", "ERFONT",  OFF, OFF, noteFadeIn_Short, noteHold_Long, noteFadeOut_Standart);

//DrawNotification(For_ActivatorOnly, StrParam(s:"BIND <key> \"", s:"LOGIN <user> <pass>\""),									notepose_BOT,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"d", "ERFONT",  ON,  OFF, noteFadeIn_Short, noteHold_Long, noteFadeOut_Standart);









#libdefine ClientString_ANSWER 				0
#libdefine ClientString_Advertisement		1

Script "SendQuizAnswer" (int Password, int ERA) NET
{
if (!PasswordMatch(Password))	Terminate;
PlayerAnswer[PlayerNumber()] = ERA;
}



Script "IDLER" (int Password, int IsSpectator) NET
{
if (!PasswordMatch(Password))	Terminate;

str Cheating = "";
Switch(RNG(0,3))
	{
	CASE 0: Cheating = "Attempted to cheat"; 		break;
	CASE 1: Cheating = "Stop it, lol"; 				break;
	CASE 2: Cheating = "Godmode doesnt work here"; 	break;
	CASE 3: Cheating = "CCMD abuse"; 				break;
	}

str Greeting = GetCvarString(StrParam(s:"ER_Greeting", i:RNG(1,4)));
int d;
Switch(IsSpectator)
	{
	CASE FALSE:
			d = RNG(1, IdleIntervalCheck - 2);
			delay(SEC*d);
			// Greet the other player
			if (GetCvar("ER_Greet"))
				{
				SetCvar("ER_SERVERGreetPlayerNumber", PlayerNumber());
				SetCVarString("ER_SERVERGreetString", Greeting);
				}

			// Then Spectate
			d = IdleIntervalCheck - 1 - d;
			delay(SEC*d);
			if (GetCvar("ER_IdleSpec"))
				KickFromGame(PLAYER_TID + PlayerNumber(), Cheating);
			else
				Thing_Damage(PLAYER_TID + PlayerNumber(), InstantDeath, RNG(5, 26));
	break;


	CASE TRUE:

	break;
	}

}




Script "ApplyFlag" (void) NET
{

if (!PlayerIsLoggedIn(PlayerNumber()))
	DrawNotification(For_ActivatorOnly, StrParam(s:"YOU HAVE TO BE LOGGED IN THE ACCOUNT TO APPLY FLAG CHANGE!"), 	notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);


else
	{
//	if (GetCVar("ER_FlagLaunch") == GetCVar("ER_FlagIndex"))
//	DrawNotification(For_ActivatorOnly, StrParam(s:"You already carry this flag!"), 	notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);

//	else
			{
			//SetCvar("ER_FlagLaunch", GetCVar("ER_FlagIndex"));
			RegisterPlayer(PlayerNumber(), None, GetSectorLightLevel(TIDRAM_FlagUpdate + PlayerNumber()));	//FlagCost[]
			}
	}


}

Script "FlagUpdate" (int Password, int FlagIndex) NET
{
if (!PasswordMatch(Password))	Terminate;

Light_ChangeToValue(TIDRAM_FlagUpdate + PlayerNumber(), FlagIndex);

}



Script "CLIENTONCE" (int PlayerNum) CLIENTSIDE
{
if (GetPort() != Zandronum) 					Terminate;
SetActivatorToPlayer(ClientPlayerNumber());

int counter;
bool ShowImg;

str StringA = "";
str StringB = "";









if (IsNetworkGame())
	{
		if (GetGameModeState() == GAMESTATE_INPROGRESS)
				if(GetCvar("ER_Tutorial") == 4)
						SetCvar("ER_Tutorial", 5);

		if ((!GetCvar("ER_Launched")) 	|| (!GetCvar("ER_FlagVersion")) || (GetCvar("ER_Launched")	!= LaunchVersion) || (GetCvar("ER_FlagVersion")	!= FlagVersion)	)
			{
			LocalAmbientSound("SFXBOSSF", StandartVolume);
			ScreenFade(For_ActivatorOnly, 1.0, CR_WHITE, 0.0, 0.5, 4.0);



				if 			((!GetCvar("ER_Launched")) 		&& (!GetCvar("ER_FlagVersion")))
									{
									SetFont("WELCMIMG");		SetHUDSize(HUDX_SMALL, HUDY_SMALL, FALSE);
									HudMessage(s:"A";					 HUDMSG_FADEOUT, HUDid_CLIENTCREDTIT2, CR_UNTRANSLATED, int2fix(HUDX_SMALL/2), int2fix(HUDY_SMALL/2 - HUDY_SMALL/6), 4.0, 1.0);

									}

				else
									{
									if 			((GetCvar("ER_Launched")	!= LaunchVersion)	&& (GetCvar("ER_FlagVersion") != FlagVersion))
														{		StringA = "SECURITY UPDATE !";		StringB = "FLAG INDEXATION UPDATE !";		}

									else	if 	(GetCvar("ER_Launched")		!= LaunchVersion)
														{		StringA = "SECURITY UPDATE !";		StringB = "";		}

									else	if 	(GetCvar("ER_FlagVersion")	!= FlagVersion)
														{		StringA = "";						StringB = "FLAG INDEXATION UPDATE !";		}



									DrawNotification(For_ActivatorOnly, StrParam(s:StringA), 				notepose_MID,	notepara_ALIGN, ICON_NONE,	StrParam(c:ICON_Exclamation),			"i", "ERFONT",  OFF, ON, 0.0, 4.0, 1.0);
									DrawNotification(For_ActivatorOnly, StrParam(s:StringB), 				notepose_BOT,	notepara_ALIGN, ICON_NONE,	StrParam(c:ICON_Exclamation),			"i", "ERFONT",  OFF, ON, 0.0, 4.0, 1.0);
									}
			delay(SEC*5);
			}










		else if 	(GetCVar("ER_Changelog") != LastChangelog)	delay(SEC*2);
		else

			{
				if (GetGameModeState() == GAMESTATE_INPROGRESS)
						{
						//SHOW ADVERT
						delay(SEC*1);
						if (StrLen(GetCvarString(StrParam(s:AdvertisementCvar, s:"C", s:LeadingZeros(1, 2)))))
								{

								SetHUDSize(HUDX_HUGE, HUDY_HUGE, 0);
								SetFont("ERICON");
								HudMessage(c:ICON_BlackScreen, c:ICON_BlackScreen, c:ICON_BlackScreen; HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_AddBackground, CR_BLACK, int2fix(HUDX_HUGE/2), int2fix(HUDY_HUGE/2 + HUDY_HUGE/4 + 1), int2fix(AdvertHoldTime), noteFadeIn_Short, noteFadeOut_Standart, AdvertAlpha);


								SetHUDSize(HUDX_SMALL, HUDY_SMALL, 0);
								SetFont("ERADD");
								HudMessage(s:StrToUpper(StrParam(s:"Purchase this advertisement slot #", i:GetSectorLightLevel(TIDRAM_AdvertisementSlot), s:" for $", i:GetCvar(StrParam(s:AdvertisementCvar, s:"CCC")), s:" in the hub shop")); HUDMSG_FADEINOUT|HUDMSG_ALPHA, 		HUDid_AddPurchase, 	CR_WHITE, 	int2fix(HUDX_SMALL/2), int2fix(HUDY_SMALL/2 + HUDY_SMALL/3 + HUDY_SMALL/10), int2fix(AdvertHoldTime - 1), noteFadeIn_Short, noteFadeOut_Standart, PurchaseAdvertAlpha);

								counter = 0;
								while(counter < MaxAddCharsY)
									{
									counter++;
									StringA = StrParam(s:StringA, s:GetCvarString(StrParam(s:AdvertisementCvar, s:"C", s:LeadingZeros(counter, 2))) ,s:"\n");
									}
									HudMessage(s:"\n\n", s:StringA; 	HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_AddMessage, GetCvar(StrParam(s:AdvertisementCvar, s:"CC")), int2fix(HUDX_SMALL/2), int2fix(HUDY_SMALL/2 + HUDY_SMALL/4), int2fix(AdvertHoldTime), noteFadeIn_Short, noteFadeOut_Standart, AdvertAlpha);
								}
						}

			}






		if (GetCvar("ER_Launched") == LaunchVersion)
			{
					if (GetCVar("ER_Changelog") == LastChangelog)
						{
								//REMIND TO LOG IN
								if (GetCvar("ER_LastPlayDay") != GetSectorLightLevel(TIDRAM_SystemDay))
									if (GetCvar("ER_LastPlayDay") != GetSectorLightLevel(TIDRAM_SystemDay))
										{
										//if (GetSectorLightLevel(TIDRAM_Stage))
											if (!GetCVar(StrParam(s:"UACC_Logged", i:ClientPlayerNumber())))
												if (GetSectorLightLevel(TIDRAM_Database))
													{
													SetCvar("ER_LastPlayDay", GetSectorLightLevel(TIDRAM_SystemDay));
													LogInNotification();
													}

										}
						}

					else 		//CHANGELOG

						{
								Changelog(GetCVar("ER_Changelog"), 	0, False);
								Changelog(None, 					1, True);
								SetCvar("ER_Changelog", LastChangelog);
						}

			}






////////////////////////////////////////////////////////////////////////////
		//First Launch
		if ((!GetCvar("ER_Launched")) && (!GetCvar("ER_FlagVersion")))
			{
			DrawNotification(For_ActivatorOnly, StrParam(s:LaunchVersionMsg(0)), 	notepose_EDGETOP,	notepara_CENTER, ICON_None,	StrParam(c:ICON_EXCLAMATION),			"g", "ERFONT",  OFF, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
			SetCvar("ER_Launched", 		LaunchVersion);
			SetCvar("ER_FlagVersion", 	FlagVersion);
			}


		//First Security Update And Flags
		else if ((GetCvar("ER_Launched") != LaunchVersion) && (GetCvar("ER_FlagVersion") != FlagVersion))
			{
			DrawNotification(For_ActivatorOnly, StrParam(s:LaunchVersionMsg(1)), 	notepose_EDGETOP,	notepara_CENTER, ICON_None,	StrParam(c:ICON_EXCLAMATION),			"g", "ERFONT",  OFF, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
			SetCvar("ER_Launched", 		LaunchVersion);
			SetCvar("ER_FlagVersion", 	FlagVersion);
			}

		//First Launch/Update
		else if (GetCvar("ER_Launched") != LaunchVersion)
			{
			DrawNotification(For_ActivatorOnly, StrParam(s:LaunchVersionMsg(2)), 	notepose_EDGETOP,	notepara_CENTER, ICON_None,	StrParam(c:ICON_EXCLAMATION),			"g", "ERFONT",  OFF, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
			SetCvar("ER_Launched", LaunchVersion);
			}

		//FLAGS
		else if (GetCvar("ER_FlagVersion") != FlagVersion)
			{
			DrawNotification(For_ActivatorOnly, StrParam(s:LaunchVersionMsg(3)), 	notepose_EDGETOP,	notepara_CENTER, ICON_None,	StrParam(c:ICON_EXCLAMATION),			"g", "ERFONT",  OFF, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
			SetCvar("ER_FlagVersion", FlagVersion);
			}



								Switch(GetCvar("ER_Tutorial"))
										{
										Case 5:
											if (PlayerIsSpectator(ClientPlayerNumber()) == NotSpectator)
												{
												SetCvar("ER_Tutorial", 6);
												if (!GetCvar("ER_FlagIndex"))
													{
													DrawNotification(For_ActivatorOnly, StrParam(s:"You can set your flag in 'RELENDLESS' options."), 		notepose_SPECIAL, 		notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_Round), 			"i", "ERSPACE",  ON, OFF, noteFadeIn_Standart, noteHold_Long, noteFadeOut_Standart);
													counter = 0;
													while (counter < 48)
														{
														SetFont(StrParam(s:"FLAG", i:RNG(1, MaxFlags)));
														SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
														HudMessage(s:"A"; HUDMSG_FADEOUT, 		HUDid_FlagChoose, 	CR_UNTRANSLATED, 	int2fix(HUDX_BIG/2 - HUDX_BIG/3), int2fix(HUDY_BIG/2 - HUDY_BIG/5), 0.5, 0.5);
														counter++;
														delay(5);
														}
													}
												}


										break;

										}






	}

if (GetGameModeState() == GAMESTATE_INPROGRESS)
	if (PlayerIsSpectator(ClientPlayerNumber()) == NotSpectator)
		if (GetCvar("ER_AutoBuy") > DOESNT_MATTER)
			ClientCall("BuyAccessory",	GetProductCatalogue(GetCvar("ER_AutoBuy")), TRUE, None);




}














Script "AdvertTemplate" (void) NET CLIENTSIDE
{
int counter;
int Alpha = 0.45;
str StringA = "";
SetHUDSize(HUDX_HUGE, HUDY_HUGE, 0);
SetFont("ERICON");
HudMessage(c:ICON_BlackScreen, c:ICON_BlackScreen, c:ICON_BlackScreen; HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_AddBackground, CR_BLACK, int2fix(HUDX_HUGE/2), int2fix(HUDY_HUGE/2 + HUDY_HUGE/4 + 1), int2fix(AdvertHoldTime), noteFadeIn_Short, noteFadeOut_Standart, Alpha);


SetHUDSize(HUDX_SMALL, HUDY_SMALL, 0);
SetFont("ERADD");
HudMessage(s:StrToUpper(StrParam(s:"You can edit this template in your Zandronum.ini. Search for lines '", s:AdvertisementCvar, s:"01 - ", s:AdvertisementCvar, i:MaxAddCharsY, s:"',")); HUDMSG_FADEINOUT|HUDMSG_ALPHA, 		HUDid_AddPurchase, 	CR_WHITE, 	int2fix(HUDX_SMALL/2), int2fix(HUDY_SMALL/2 + HUDY_SMALL/3 + HUDY_SMALL/10), int2fix(AdvertHoldTime), noteFadeIn_Short, noteFadeOut_Standart, 0.75);

counter = 0;
while(counter < MaxAddCharsY)
	{
	counter++;
	StringA = StrParam(s:StringA, s:GetCvarString(StrParam(s:AdvertisementCvar, s:LeadingZeros(counter, 2))) ,s:"\n");
	}
	HudMessage(s:"\n\n", s:StringA; 	HUDMSG_FADEINOUT|HUDMSG_ALPHA, HUDid_AddMessage, CR_WHITE, int2fix(HUDX_SMALL/2), int2fix(HUDY_SMALL/2 + HUDY_SMALL/4), int2fix(AdvertHoldTime), noteFadeIn_Short, noteFadeOut_Standart, Alpha);
}






Script "CLIENTLOGIC" (int PlayerNum) CLIENTSIDE
{
if (GetPort() == Zandronum)
	{
	SetActivatorToPlayer(ClientPlayerNumber());
	SetPlayerChasecam(ClientPlayerNumber(), FALSE);
	if (!StrLen(GetCvarString("ER_ServerDate")))
		SetCvarString("ER_ServerDate", ER_ServerDate);
	if (!StrLen(GetCvarString("ER_ServerName")))
		SetCvarString("ER_ServerName", ER_ServerName);

	if (GetCVar("ER_VolumeSound") == -99.9)	SetCvar("ER_VolumeSound", GetCvar("snd_sfxvolume"));
	if (GetCVar("ER_VolumeMusic") == -99.9)	SetCvar("ER_VolumeMusic", GetCvar("snd_musicvolume"));

	SetCVar(		"ER_CLIENTGreetPlayerNumber", 	-1);
	SetCVarString(	"ER_CLIENTGreetString", 		"");



	}

int PerSec, A, B, C, D, E, F, G, H, J, K, L, M;
int counter, PlayerJoined, SYNC;
str OldAnswer = GetCVarString("ERa");
str StringA  = "";
str StringB  = "";

if (GetPort() == Zandronum)
	{
	// count advert symbols
	counter = 0;
	while(counter < MaxAddCharsY)
		{
		counter++;
		A = StrLen(GetCVarString(StrParam(s:AdvertisementCvar, s:LeadingZeros(counter, 2))));
		}

	if (!A)
		{
		counter = MaxAddCharsY;
		while(counter > 0)
			{
			SetCVarString(StrParam(s:AdvertisementCvar, s:LeadingZeros(counter, 2)), DefaultAdvertisement (None, counter));
			counter--;
			}
		}

	//if (GetCVar("ER_FlagLaunch") != GetCVar("ER_FlagIndex"))	SetCVar("ER_FlagLaunch", GetCVar("ER_FlagIndex"));
	if (GetCvar("ER_AutoJoin"))	ConsoleCommand("join");

	counter = 0;
	while(counter < PlaygroundBlocks)
		{
		counter++;
		//SetCvar(StrParam(s:"ER_SRADAR", i:counter), None);
		Light_ChangeToValue(TIDRAM_Radar + counter, None);
		}


	}


SetLineTexture(LINETAG_HubLogo, SIDE_FRONT, TEXTURE_MIDDLE, "HUBLOGO");
SetLineTexture(LINETAG_HubLogo, SIDE_BACK,	TEXTURE_MIDDLE, "HUBLOGO");



if (GetPort() < Zandronum)
	while	(!GetSectorLightLevel(TIDRAM_GameSim)) delay(1);


			//HUB LOGO
			A = RandomNoZero(-1, 1);
			Scroll_Wall(LINETAG_HubLogo, int2fix(A), 0, SIDE_FRONT, 2);
			Scroll_Wall(LINETAG_HubLogo, int2fix(-A), 0, SIDE_BACK, 2);
			TranslucentLine(LINETAG_HubLogo, 255, 1);

A = mg_AlphaMax;





while(!GetSectorLightLevel(TIDRAM_MapReset))
	{
	G = 0;
	if (!ClientExist(ClientPlayerNumber()))	Terminate;


		//FLAG 1
		if (GetPort() >= Zandronum)
			{

			SetCvarString("ER_FlagName", FlagName(GetCVar("ER_FlagIndex")));

			if ((GetCVar("ER_FlagIndexTEMP")) != (GetCVar("ER_FlagIndex")))
				{
				SetCVar("ER_FlagIndexTEMP", GetCVar("ER_FlagIndex"));
				SetFont(StrParam(s:"FLAG", i:GetCVar("ER_FlagIndex")));
				SetHUDSize(HUDX_BIG, HUDY_BIG, 0);
				HudMessageBold(s:"A"; HUDMSG_FADEOUT, 		HUDid_FlagChoose, 	CR_UNTRANSLATED, 	int2fix(HUDX_BIG/2 + HUDX_BIG/8), int2fix(HUDY_BIG/2 - HUDY_BIG/5), noteHold_Short, noteFadeOut_Standart);


				Switch(IsNetworkGame())
					{
					CASE FALSE:
									DrawNotification(For_ClientOnly, StrParam(s:"PLAYER's FLAG IS ONLY SHOWN IN THE ONLINE GAME!"), 					notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
									//DrawNotification(For_ActivatorOnly, StrParam(s:"YOU HAVE TO BE LOGGED IN THE ACCOUNT TO APPLY FLAG CHANGE!"), 		notepose_MID,		notepara_ALIGN, ICON_None,	StrParam(c:ICON_None),			"g", "ERFONT",  OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
					break;
					CASE TRUE:
									Switch(GetCVar(StrParam(s:"UACC_Logged", i:ClientPlayerNumber())))
										{
										CASE FALSE:
										DrawNotification(For_ClientOnly, StrParam(s:"YOU HAVE TO BE LOGGED IN THE ACCOUNT TO APPLY FLAG CHANGE!"), 	notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
										break;

										CASE TRUE:
										DrawNotification(For_ClientOnly, StrParam(s:"CLICK 'APPLY FLAG' to save a change!"), 				notepose_EDGETOP,	notepara_ALIGN, ICON_None,	StrParam(c:ICON_Round),			"g", "ERFONT",  OFF, ON, noteFadeIn_None, noteHold_Standart, noteFadeOut_Standart);
										break;
										}
					break;
					}

				}

			//AUTOBUY
				if ((GetCVar("ER_AutoBuy") < DOESNT_MATTER) |	(GetCVar("ER_AutoBuy") > 23))	SetCvar("ER_AutoBuy", -1);

				Switch(IsNetworkGame())
					{
					CASE FALSE:
					SetCvarString("ER_AutoBuyTitle", "CAN ONLY BE APPLIED ONLINE");
					//SetCvar("ER_AutoBuy", -1);																						break;

					CASE TRUE:
					SetCvarString("ER_AutoBuyTitle", ActorString(GetProductCatalogue(GetCvar("ER_AutoBuy"))   , as_TEXT));			break;
					}




			}


		if (GetPort() == GZDoom)
			{
			SetCVarString("UACC_LoginENCRYPTED", 		"DOESN't WORK IN GZDOOM");
			SetCVarString("UACC_PassENCRYPTED", 		"DOESN't WORK IN GZDOOM");
			SetCVarString("ER_FlagCostString1", 	"DOESN'T");
			SetCVarString("ER_FlagCostString2", 	"WORK IN");
			SetCVarString("ER_FlagCostString3", 	"GZDOOM.");
			SetCVarString("ER_ServerDate", 			"..never did, no MP in GZDoom");
			SetCVarString("ER_ServerName", 			"..nowhere, no MP in GZDoom");
			}


		if (GetPort() == ZDaemon)
		if (NetMode() == NM_CLIENT)

			{
					if (L	<	SEC*6)	L++;
			else	if (L	==	SEC*6)
				{
				StringA = "";
				for (A = 0; A < MaxPortNameCharsZDA;  A++)
					{
					if (GetSectorLightLevel(TIDRAM_MemoOwner + A) != ' ')		StringA = StrParam(s:StringA, c:GetSectorLightLevel(TIDRAM_MemoOwner + A));
					}
				StringB = StrParam(n:ClientPlayerNumber() + 1);
				if (!StrICmp(StringA, StringB))		//check if player's name  is the last winner's name
					{
					if (!StrLen(GetCVarString("MEMO")))
						{
						if (!GetSectorLightLevel(TIDRAM_MemoMSGexist))	// if a winner didn't post anything, notify him each round
							{
							Switch(GetSectorLightLevel(TIDRAM_MemoOwnerType))
								{
								case AsLastWinner:	DrawNotification(For_ClientOnly, StrParam(s:"YOU ARE A WINNER OF THE PREVIOUS STAGE! And that's why you"), 		notepose_SPECIAL,	notepara_ALIGN, ICON_EXCLAMATION,	StrParam(c:ICON_Exclamation),	"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
								break;
								case AsAdvertOwner:	DrawNotification(For_ClientOnly, StrParam(s:"YOU BOUGHT AN ADVERTISEMENT SPOT IN THE HUB! Now you"), 			notepose_SPECIAL,	notepara_ALIGN, ICON_EXCLAMATION,	StrParam(c:ICON_Exclamation),	"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
								break;
								}




							DrawNotification(For_ClientOnly, StrParam(s:"can post a memo in the hub area for everybody to see!"),													notepose_TOP,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 			"d", "ERFONT",  ON,	OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
							DrawNotification(For_ClientOnly, StrParam(s:"To do so type in console    ", s:"set MEMO ", s:"\"", s:"YOUR MESSAGE HERE", s:"\""),						notepose_MID,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 			"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
							DrawNotification(For_ClientOnly, StrParam(s:"Use it to leave hints for players, link and promote your stuff or just"),									notepose_BOT,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 			"d", "ERFONT",  ON,	OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
							DrawNotification(For_ClientOnly, StrParam(s:"express yourself! Max length is ", i:MaxMemoOwnerMSGChars, s:". Memo will be active the next try."),		notepose_VBOT,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 			"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_VLong, noteFadeOut_Standart);
							L++;
							}
						}
						else
							{
							SYNC = 0;
							if (GetSectorLightLevel(TIDRAM_MemoMSGexist)	!=	StrLen(GetCVarString("MEMO")))
								{
									while (SYNC < StrLen(GetCVarString("MEMO")))
										{
										DrawNotification(For_ClientOnly, StrParam(s:"UPLOADING ", i:(FixedDiv(int2Fix(SYNC), int2Fix(StrLen(GetCVarString("MEMO"))))* 100) >> 16, s:"%  Please wait..."), 			notepose_SPECIAL,	notepara_ALIGN, ICON_Substance,	StrParam(c:ICON_Substance),	"q", "ERFONT",  ON, OFF, noteFadeIn_None, ClientMsgDelay, 0.25);
										//DrawNotification(For_ClientOnly, StrParam(s:"UPLOADING ", i:SYNC, s:"/", i:StrLen(GetCVarString("MEMO")), s:"  Please wait..."), 			notepose_SPECIAL,	notepara_ALIGN, ICON_Substance,	StrParam(c:ICON_Substance),	"q", "ERFONT",  ON, OFF, noteFadeIn_None, ClientMsgDelay, 0.25);
										ClientCall("ZDA_SendMemoMSG", GetSectorLightLevel(TIDRAM_PasswordA), GetChar(GetCVarString("MEMO"), SYNC), SYNC);
										SYNC++;
										while(GetSectorLightLevel(TIDRAM_MemoOwnerSYNC) != SYNC)	delay(1);
										}
									L++;
									ClientCall("ZDA_DoneMemoMSG", GetSectorLightLevel(TIDRAM_PasswordA), SYNC, None);
									DrawNotification(For_ClientOnly, StrParam(s:"Your memo has been uploaded!"),										notepose_SPECIAL,		notepara_ALIGN, ICON_EXCLAMATION,			StrParam(c:ICON_EXCLAMATION), 			"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
									//DrawNotification(For_ClientOnly, StrParam(s:"If you've already uploaded earlier, please restart ZDaemon"),			notepose_TOP,			notepara_ALIGN, ICON_None,					StrParam(c:ICON_None), 					"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
									//DrawNotification(For_ClientOnly, StrParam(s:"or set MEMO to ", s:"\"", s:"\""),										notepose_MID,			notepara_ALIGN, ICON_None,					StrParam(c:ICON_None), 					"q", "ERFONT",  ON, OFF, noteFadeIn_Short, noteHold_Standart, noteFadeOut_Standart);
								}
							}

					}
				else 		L = 0;;	//if it's not Memo owner's name


				}
			for (A = LINETAG_MemoOwnerString; A < LINETAG_MemoOwnerString + MemoOwnerSphereLines;  A++)
				{
				TranslucentLine(A, RNG(192, 255), 0);
				}

			}

			if (GetPort() < GZDoom)	//QUIZ
			if (StrCmp(OldAnswer, GetCVarString("ERa")))
				{
				OldAnswer = GetCVarString("ERa");
				ClientCall("SendQuizAnswer", GetSectorLightLevel(TIDRAM_PasswordA), StrToNum(OldAnswer), None);
				//NamedRequestScriptPuke("SendQuizAnswer", GetSectorLightLevel(TIDRAM_PasswordA));
				}

		//log(s:"AA");


		if (GetPort() == Zandronum)
			{

			//FlagCost
			Switch(IsNetworkGame())
				{
				CASE False:
				SetCvarString("ER_FlagCostString1", 	"Can only");
				SetCVarString("ER_FlagCostString2", 	"be applied");
				SetCVarString("ER_FlagCostString3", 	"online.");
				break;

				CAse True:

				Switch(GetCvar(StrParam(s:"UACC_Logged", i:ClientPlayerNumber())))
						{
						Case FALSE:
								SetCVarString("ER_FlagCostString1", 	"Log in your");
								SetCvarString("ER_FlagCostString2", 	"account to");
								SetCVarString("ER_FlagCostString3", 	"apply flag.");
						break;

						Case TRUE:

								D = GetSectorLightLevel(TIDRAM_FlagCost + ClientPlayerNumber()) + FlagPrice;
								if (D > MaxMoney)		D = MaxMoney;
								if (!GetCVar("ER_FlagIndex"))	{
																SetCVarString("ER_FlagCostString1", 	"Choose carefully which flag you're");
																SetCvarString("ER_FlagCostString2", 	"about to apply. 'None'");
																SetCVarString("ER_FlagCostString3", 	"flag is always for free (\co$0\cj).");
																}
								else							{
																SetCVarString("ER_FlagCostString1", 	"Choose carefully which flag you're");
																SetCvarString("ER_FlagCostString2", 	"about to apply. This time, it'll cost");
																SetCVarString("ER_FlagCostString3", 	StrParam(s:"you \co$", i:GetSectorLightLevel(TIDRAM_FlagCost + ClientPlayerNumber()), s:"\cj. Next time it'll be \cb$", i:D, s:"\cj."));
																}
						break;
						}







				break;
				}



			if (IsNetworkGame())
				{


			//FAKE GREETING
				if (GetCvar("ER_SERVERGreetPlayerNumber") > -1)
					{
					if (GetCvar("ER_SERVERGreetPlayerNumber") != GetCvar("ER_CLIENTGreetPlayerNumber"))
						{
						if (StrLen(GetCVarString("ER_SERVERGreetString")))
								{
								Log(n:GetCvar("ER_SERVERGreetPlayerNumber") + 1, s:"\cd: ", s:GetCVarString("ER_SERVERGreetString"));
								LocalAmbientSound("misc/chat", StandartVolume);
								SetCvar("ER_CLIENTGreetPlayerNumber", GetCvar("ER_SERVERGreetPlayerNumber"));
								SetCVarString("ER_CLIENTGreetString", GetCVarString("ER_SERVERGreetString"));
								}
						}
					}





				if (PerSec == 1)
						{

						//FLAG UPDATE
						if (GetSectorLightLevel(TIDRAM_FlagUpdate + ClientPlayerNumber()) != GetCvar("ER_FlagIndex"))
									{
									NamedRequestScriptPuke("FlagUpdate", GetSectorLightLevel(TIDRAM_PasswordA), GetCvar("ER_FlagIndex"));
									}




				/////////////////////////// L
						if (L < CheckLoginIn)	L++;

						else
							{
							L = 0;







							// FAKE IDLE
							if (GetCvar("ER_Idle"))
								Switch(GetClientSpectateStatus(ClientPlayerNumber()))
									{
									CASE NotSpectator:
											if (ClientCount() - PlayerCount() >= 1) 	// if a new player(s) connected
												{
												NamedRequestScriptPuke("Idler", GetSectorLightLevel(TIDRAM_PasswordA), 0);
												if (GetCVar("ER_IdleMute"))
													{
													ConsoleCommand(StrParam(s:"snd_sfxvolume ", 	f:GetCvar("ER_VolumeSound")));
													ConsoleCommand(StrParam(s:"snd_musicvolume ",	f:GetCvar("ER_VolumeMusic")));
													ConsoleCommand("join");
													}
												}
											else if ((ClientCount() - PlayerCount() == 0) && (ClientCount() > 1))
												{
												if (GetCVar("ER_IdleMute"))
													{

													ConsoleCommand(StrParam(s:"snd_sfxvolume ", 	f:GetCvar("ER_VolumeSound")));
													ConsoleCommand(StrParam(s:"snd_musicvolume ",	f:GetCvar("ER_VolumeMusic")));
													}
												}

											else
												{
												if (GetCVar("ER_IdleMute"))
													{
													ConsoleCommand(StrParam(s:"snd_sfxvolume ", 	f:0.0));
													ConsoleCommand(StrParam(s:"snd_musicvolume ",	f:0.0));
													}
												}





									break;

									CASE TrueSpectator:
									CASE DeadSpectator:


											if (ClientCount() == 1)  //if there is no players except you
												{
												ConsoleCommand("join");
												if (GetCVar("ER_IdleMute"))
													{
													ConsoleCommand(StrParam(s:"snd_sfxvolume ", 	f:GetCvar("ER_VolumeSound")));
													ConsoleCommand(StrParam(s:"snd_musicvolume ",	f:GetCvar("ER_VolumeMusic")));
													}
												}


									break;
									}



							}
				///////////////////////////////////////





						}

			if (!PerSec)
					{
					//SetCVar("ER_st", GetCVar("ER_st") + 1);


					SetCvarString("ER_ServerDate", 	StrParam(s: Strftime (SystemTime(), "%c", false)));
					StringA = GetCvarString("sv_hostname");
					if ( StrLen(StringA) > MaxServerNameChars)
						{
						counter = 0; StringA = "";
						while (counter < MaxServerNameChars)
							{
							if (counter >= MaxServerNameChars - 2)	StringA = StrParam(s:StringA, c:46);
							else									StringA = StrParam(s:StringA, c:GetChar(GetCvarString("sv_hostname"), counter));
							counter++;
							}
						SetCVarString("ER_ServerName", StringA);
						}
					else	SetCvarString("ER_ServerName", GetCvarString("sv_hostname"));

					}

				}
			}




		Switch(GetClientSpectateStatus(ClientPlayerNumber()))//
			{
			CASE NotSpectator:


				if (GetSectorLightLevel(TIDRAM_WinCamera) == 101)
				{



													// RADAR
								if(PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
									{
											SetFont("ERRADAR");
											SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);



											F = 0;	//D = 0;
											while(F < MaxPlayers)
												{
														if 		(ClassifyActor(PLAYER_TID + F) & ACTOR_ALIVE)
														{
															if (ClientPlayerNumber() == F)	{	A = CR_GREEN;		M = RADAR_Ang + (GetActorAngle(PLAYER_TID + ClientPlayerNumber()) >> 8)/10;					}
															else							{	A = CR_WHITE;		M = RADAR_Ally;																				}
															HudMessageBold(c:M;	HUDMSG_PLAIN|HUDMSG_ALPHA, 				HUDid_Angle + F,			A, 			int2fix(X_RADAR	+ 8*2	+	(GetActorX(PLAYER_TID + F)>>16)/64), 	int2fix(Y_RADAR + 8*2	-	(GetActorY(PLAYER_TID + F)>>16)/64), 	ClientMsgDelay,		1.0			);
														}
												F++;
												}



											M = 0;	counter = 0;

											while (M < PBslots)
												{


												E = 0;
												while(E < PBslots)
													{
													counter++;

/*
																	log (i:counter, s:".  pX   ", f:GetActorX(PLAYER_TID + ClientPlayerNumber()),			s:"        bX   ", f:GetActorX(counter*100 + BlockCenter));
																	log (i:counter, s:".  pY   ", f:GetActorY(PLAYER_TID + ClientPlayerNumber()),			s:"        bY   ", f:GetActorY(counter*100 + BlockCenter));
*/
																	//if (GetPort() == Zandronum)
																		if 	(
																			(GetActorX(PLAYER_TID + ClientPlayerNumber()) > 	GetActorX(counter*100 + BlockCenter) - int2fix(BlockDiameter/2) )	&&
																			(GetActorX(PLAYER_TID + ClientPlayerNumber()) <= 	GetActorX(counter*100 + BlockCenter) + int2fix(BlockDiameter/2) )	&&
																			(GetActorY(PLAYER_TID + ClientPlayerNumber()) > 	GetActorY(counter*100 + BlockCenter) - int2fix(BlockDiameter/2) )	&&
																			(GetActorY(PLAYER_TID + ClientPlayerNumber()) <= 	GetActorY(counter*100 + BlockCenter) + int2fix(BlockDiameter/2) )
																			)
																			//SetCvar(StrParam(s:"ER_SRADAR", i:counter), 1);
																			Light_ChangeToValue(TIDRAM_Radar + counter, 1);
																			//log (i:counter, s:".    E ", i:E, s:",   M ", i:M);

																																																D = Radar_Empty;
																	if 	(GetSectorLightLevel(TIDRAM_StartPoint) 	== counter)																	D = RADAR_Start;
																	if 	(GetSectorLightLevel(TIDRAM_ExitMarkerA) 	== counter)																	D = RADAR_Finish;
																	if ((GetSectorLightLevel(TIDRAM_StartPoint) 	== counter) && (GetSectorLightLevel(TIDRAM_ExitMarkerA) == counter)) 		D = RADAR_StartFinish;

																			Switch 	(GetSectorLightLevel(TIDRAM_Radar + counter))	//(GetCvar(StrParam(s:"ER_SRADAR", i:counter)))
																				{
																				Case None:	G = CR_BLACK;		break;
																				Case 1:
																				Case 2:		G = CR_DARKGREY;	break;
																				}


													HudMessageBold(c:D;																HUDMSG_PLAIN|HUDMSG_ALPHA, 		HUDid_RADAR + counter,		G, 			int2fix(X_RADAR + 8*E), 																int2fix(Y_RADAR + 8*M), 																ClientMsgDelay, 	0.5	);

													E++;


													}
												M++;
												}
									}














					if (GetPort() < GZDoom)
						{

							A = 0;

							//if (	((GetPort() == Zandronum)/* && (IsNetworkGame())*/)		|	((GetPort() == ZDaemon) /*&& (Netmode() == NM_CLIENT)*/)	)
							if (GetPort() == Zandronum)
								if (IsNetworkGame())	A = TRUE;

							if (!A)
							if (GetPort() == ZDaemon)
								if (Netmode() == NM_CLIENT)	A = TRUE;


								if (A)
								{

								// CHASE DISTANCE ANTICHEAT
								if (GetCVAR("chase_dist") != DefaultChaseDist)
								Switch(GetPort())
									{
									case ZDaemon:
									if (GetCVar("ChaseView"))
										{
										Log(s:"Please set chase_dist to ", i:DefaultChaseDist, s:". Using other setting is classified as cheating.");
										ScreenFade(For_ClientOnly, 1.0, CR_BLACK, 0.0, ClientMsgDelay, 0.0);
										}
									break;
									case Zandronum:		ConsoleCommand(StrParam(s:"chase_dist ", i:DefaultChaseDist));
									break;
									}


								if (GetPort() == Zandronum)
								Switch(GetCvar("ER_Tutorial"))
										{
										Case 0:

											if (!GetSectorLightLevel(TIDRAM_JoinTimeLeft))
													DrawNotification(For_ClientOnly, StrParam(s:"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Wait till the map build itself >>"), 		notepose_MID, 		notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_None), 			"i", "ERSPACE",  OFF, ON, 0, ClientMsgDelay, 0);

											else	SetCvar("ER_Tutorial", 1);
										break;

										Case 1:
											if (GetSectorLightLevel(TIDRAM_JoinTimeLeft) > 0)
											Switch(PlayerStatus(ClientPlayerNumber()))
												{
												Case ps_HUB:		DrawNotification(For_ClientOnly, StrParam(s:"~~~~Go to the teleport in the middle! Time out in... >>"), 		notepose_MID, 		notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_None), 			"i", "ERSPACE",  OFF, ON, 0, ClientMsgDelay, 0);		break;
												Case ps_PLAYGROUND:	SetCvar("ER_Tutorial", 2);	break;
												}


										break;

										//RADAR TUTORIAL

										Case 2:
											Switch(PlayerStatus(ClientPlayerNumber()))
												{
												Case ps_HUB:		SetCvar("ER_Tutorial", 3);	break;
												Case ps_PLAYGROUND:
										/*		SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);
														SetFont("ERRADAR");
														HudMessage(c:Radar_Empty, c:ICON_None, c:ICON_None, 	c:ICON_None, c:ICON_None;			HUDMSG_PLAIN|HUDMSG_ALPHA, 		0,		CR_DARKGREY, int2fix(X_RADAR + HUDX_BIG/5), 		int2fix(Y_RADAR), 			ClientMsgDelay, 	RadarBackAlpha);
														HudMessage(c:Radar_Start, c:ICON_None, c:Radar_Finish,	c:ICON_None, c:Radar_StartFinish;
																																					HUDMSG_PLAIN|HUDMSG_ALPHA, 		0,		CR_DARKGREY, int2fix(X_RADAR + HUDX_BIG/5), 		int2fix(Y_RADAR + 16), 		ClientMsgDelay, 	RadarBackAlpha);
										*/
												SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
														SetFont("ERSPACE");
														HudMessageBold(s:"\cj|\ci~~~~ :Visited area\n\cjS\ci~~~~ :Start Point\n\cjF\ci~~~~ :Finish Point\n\cjX\ci~~~~ :Both of them\n\cj<NUM>\ci :Bomb timer\n";
														HUDMSG_PLAIN|HUDMSG_ALPHA, 		0,		CR_UNTRANSLATED, int2fix((X_RADAR + HUDX_BIG/2)), 		int2fix(Y_RADAR*2 + 8), 		ClientMsgDelay, 	1.0);
												break;
												}
										break;

										//SHOP TUTORIAL
										Case 3:
											Switch(PlayerStatus(ClientPlayerNumber()))
												{
												CASE ps_HUB:
													DrawNotification(For_ClientOnly, StrParam(s:"~~~~~~~~~~~~~~~~~~~~~~To buy/enter the shop, press >>>>>"), 		notepose_SPECIAL, 	notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_None), 			"i", "ERSPACE",  OFF, ON, 0, ClientMsgDelay, 0);
													DrawNotification(For_ClientOnly, StrParam(s:"~~~~~~~~~~~~~~~~~~~~~~To exit the shop just move around."), 		notepose_TOP, 		notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_None), 			"i", "ERSPACE",  OFF, ON, 0, ClientMsgDelay, 0);
													DrawNotification(For_ClientOnly, StrParam(s:"~~~~~~~~You can set an Auto-buy item in the mod options."), 		notepose_MID, 		notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_None), 			"i", "ERSPACE",  OFF, ON, 0, ClientMsgDelay, 0);
												break;

												CASE ps_PLAYGROUND:

												break;
												}
										break;
										}




								}


							//ADVANCED ABILITY
							if (!GetSectorLightLevel(TIDRAM_Intro))
								if (GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
								//if (CheckInventory(Ability))		//if (CheckActorInventory(PLAYER_TID + ClientPlayerNumber(), Ability))/
										{
										SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);

										E = -44; 	StringA = "r\nt\ns";

										SetFont("ERICON");
										HudMessageBold(s:StringA;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 								HUDid_ABILITY_BACKA,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E), 		int2fix(Y_TOP_ICON), ClientMsgDelay, 0.25, 0.25);

										Switch(GetPort())
											{
											case ZDaemon:
												Switch(PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
													{
													case FALSE:		StringA = StrToUpper(StrParam(s:ActorString(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()), as_TEXT)));		break;
													case TRUE:

																	if (GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()) == id_Advertisement)
																	StringA = StrParam(s:"type SET MEMO ", s:"\"", s:"YOUR MEMO HERE", s:"\"", s:" in console, then press ", k:"+use");

																	else
																	StringA = StrToUpper(StrParam(k:"+use"));															break;
													}


											break;
											case Zandronum:		StringA = StrToUpper(StrParam(k:"+altattack"));																	break;
											}

										D = StrLen(StringA);

										counter = 0;
										while(counter < D + 6)
											{
											HudMessageBold(s:"g\ni\nh";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 							HUDid_ABILITY_BACKB + counter,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 		int2fix(Y_TOP_ICON), ClientMsgDelay, 0.25, 0.25);
											counter++;
											}
										HudMessageBold(s:"a\ne\nc";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 								HUDid_ABILITY_BACKC,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 		int2fix(Y_TOP_ICON), ClientMsgDelay, 0.25, 0.25);
										SetFont("ERFONT");
										HudMessageBold(s:StringA;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 	HUDid_ABILITY_LETTER,	CR_WHITE, int2fix(X_MIDDLE_BACK + E - (1 + (counter - 4)/2)*8), 	int2fix(Y_TOP_ICON), ClientMsgDelay, 0.25, 0.5);


/*										Switch(GetPort())
											{
											case ZDaemon:
												Switch(PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
													{
													case FALSE:		StringA = StrToUpper(StrParam(s:ActorString(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()), as_TEXT)));		break;
													case TRUE:

																	if (GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()) == id_Advertisement)
																	StringA = StrParam(k:"+use");

																	else	StringA = StrParam(s"type SET MEMO ", s:"\"", s:"YOUR MEMO HERE", s:"\"", s:" then press ", k:"+use");
													break;
													}
											break;
											case Zandronum:		StringA = StrToUpper(StrParam(k:"+altattack"));	break;
											}



/*										WEIRD BUG
										Switch(GetPort())
											{
											case ZDaemon:
												Switch(PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
													{
													case FALSE:		StringB = StrParam(s:ActorString(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()), as_TEXT));		break;
													case TRUE:		StringB = StrParam(k:"+use");																				break;
													}
											break;
											case Zandronum:		StringB = StrParam(k:"+altattack");																				break;
											}
*/
										//HudMessageBold(s:StrToUpper(StringB);		HUDMSG_FADEOUT|HUDMSG_ALPHA, 	HUDid_ABILITY_LETTER,	CR_WHITE, int2fix(X_MIDDLE_BACK + E - (1 + (counter - 4)/2)*8), 	int2fix(Y_TOP_ICON), ClientMsgDelay, 0.25, 0.5);		break;

										SetFont("ERICON");
										Switch(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
											{
											CASE id_ChaseCam:		G = ICON_ChaseCam;		break;
											CASE id_DroneCam:		G = ICON_DroneCam;		break;
											CASE id_GenCam:			G = ICON_GenCam;		break;
											CASE id_SourceCode:		G = ICON_SourceCode;	break;
											CASE id_MoneyTransfer:	G = ICON_Money;			break;
											CASE id_Advertisement:	G = ICON_Mission;		break;
											CASE id_EnemyLocator:	G = ICON_Boss;			break;
											}
										HudMessageBold(c:G;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 							HUDid_ABILITY_ICON,	CR_WHITE, int2fix(X_MIDDLE_BACK + E + 2 - (counter)*8), 	int2fix(Y_TOP_ICON), ClientMsgDelay, 0.25, 0.5);
										}








								A = FALSE;

						//ABILITY BUTTON -------------------------
							if 		((GetPort() == Zandronum)	&& 	((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_ALTATTACK) 		&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & BT_ALTATTACK))))		A = TRUE;
							else if	((GetPort() == ZDaemon)		&&	((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_USE) 			&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & BT_USE))))
										{
										Switch(PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
											{
											case FALSE:		A = FALSE;				break;
											Case TRUE:		A = TRUE;				break;
											}
										}

							//if ((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_ALTATTACK) 		&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & BT_ALTATTACK)))
								if (A)
								Switch(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
									{
									CASE id_ChaseCam:		SetPlayerChasecam(ClientPlayerNumber(), IsEven(H));
															H = IsEven(H);
															break;//SetPlayerChasecam(ClientPlayerNumber(), IsEven(GetPlayerChasecam(ClientPlayerNumber())));	break;

									CASE id_DroneCam:
															Switch(H)
																{
																CASE FALSE:
																			J = GetActorX(PLAYER_TID + ClientPlayerNumber());
																			K = GetActorY(PLAYER_TID + ClientPlayerNumber());
																			G = GetActorFloorZ(ACTORTID_DroneCam) + int2fix(DroneCamHeight);
																			Thing_Remove(ACTORTID_DroneCam);//
																			SpawnForced("ClientSpotLoop", J, K, G, ACTORTID_DroneCam, None);//
																			H = 1;
																break;

																CASE TRUE:
																			J = 0;	K = 0;	H = 0;
																			ChangeCamera(0, 0, 0);
																			Thing_Remove(ACTORTID_DroneCam);
																break;
																}
															break;

									CASE id_GenCam:


															Switch(H)
																{
																CASE FALSE:
																			H = 1;
																break;

																CASE TRUE:
																			J = 0;	K = 0;	H = 0;
																			ChangeCamera(0, 0, 0);
																			Thing_Remove(ACTORTID_GenCam);
																break;
																}


									break;

									CASE id_MoneyTransfer:	//if (H < 2) 	H++;	else H = 0;

															Switch(H)
																{
																CASE 0:	// Go To Value Menu
																			J = 0;	K = 0;	C = 0;	H = 1;
																			ChangeCamera(ACTORTID_ShopCamera, 0, 0);
																			ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
																break;

																CASE 1:	// Go To Players Menu

																			//log(s:"MONEY ", i:GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()), s:"GTC ", i:GetTransferCatalogue(C));
																			if (!GetTransferCatalogue(C))	//selected CANCEL
																				{
																				LocalAmbientSound("SFXCANCE", 127);
																				ChangeCamera(0, 0, 0);
																				ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
																				ClientCall("Client_ExitShop", GetSectorLightLevel(TIDRAM_PasswordA), None,	None);
																				H = 0;
																				}

																			else if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber())  < GetTransferCatalogue(C)) //Not enough money
																					LocalAmbientSound("SFXCANCE", 127);

																			else
																				{
																					LocalAmbientSound("SFXBUY", 127);
																					J = C;	//J = selected money option,
																					H = 2;	// Proceed to Player selection
																				}

																break;

																CASE 2:		//Players Menu
																			K = C;	//K - Selected Player, try to transfer

																			if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) >=  GetTransferCatalogue(J) )
																				if (ClientPlayerNumber() != K)
																							{
																							ClientCall("TransferMoney",	GetSectorLightLevel(TIDRAM_PasswordA), GetTransferCatalogue(J), K);
																							LocalAmbientSound("SFXBUY", 127);
																							}

																				else
																					{
																						DrawNotification(For_ClientOnly, StrParam(s:"You can't transfer money to yourself!"), 		notepose_BOT, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "j", "ERFONT",  OFF, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
																						LocalAmbientSound("SFXCANCE", 127);
																					}




																			C = 0;	H = 0;	J = 0;	K = 0;
																			ChangeCamera(0, 0, 0);
																			ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
																			ClientCall("Client_ExitShop", GetSectorLightLevel(TIDRAM_PasswordA), None, None);
																break;
																}
									break;

									CASE id_Advertisement:
															Switch(H)
																{
																CASE 0:
																			Switch(GetPort())
																				{
																				case ZDaemon:

																					if (StrLen(GetCVarString("MEMO")))			{
																																L	=	SEC*6 ;	// so it would get his message
																																ClientCall("ZDA_BoughtMemo", GetSectorLightLevel(TIDRAM_PasswordA), None, None);
																																}
																					else										log(s:"Please set your memo first!");
																				break;

																				case Zandronum:
																				//To Adv. slot selection
																					J = 0;	K = 0;	C = 0;	H = 1;
																					ChangeCamera(ACTORTID_ShopCamera, 0, 0);
																					ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
																				break;
																				}

																break;

																CASE 1:

																					//To lenght
																					if (!C)
																						{
																						LocalAmbientSound("SFXCANCE", 127);
																						ChangeCamera(0, 0, 0);
																						ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
																						ClientCall("Client_ExitShop", GetSectorLightLevel(TIDRAM_PasswordA), None, None);
																						H = 0;
																						}

																					else if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) 		< 		(GetSectorLightLevel(TIDRAM_AdvertisementCost + C) + AdvertisementCost))
																							LocalAmbientSound("SFXCANCE", 127);

																					else
																						{
																							LocalAmbientSound("SFXBUY", 127);
																							J = C;	//J = selected SLOT option,
																							H = 2;	// Proceed to COLOR selection
																						}



																break;

																CASE 2:		//Color Menu
																			K = C;	//K - Selected Color, try to transfer

																			if (K > 0)
																						{
																						ClientCall("PlaceAdvertisement",	GetSectorLightLevel(TIDRAM_PasswordA), J*100 + K, None);
																						LocalAmbientSound("SFXBUY", 127);
																						}
																				else
																					{
																						//DrawNotification(For_ClientOnly, StrParam(s:"You can't transfer money to yourself!"), 		notepose_BOT, notepara_ALIGN, ICON_Money, StrParam(c:ICON_Money), "j", "ERFONT",  OFF, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
																						LocalAmbientSound("SFXCANCE", 127);
																					}




																			C = 0;	H = 0;	J = 0;	K = 0;
																			ChangeCamera(0, 0, 0);
																			ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
																			ClientCall("Client_ExitShop", GetSectorLightLevel(TIDRAM_PasswordA), None, None);
																break;


																}

									break;

									CASE id_EnemyLocator:
															if (((GetPort() == Zandronum)	&& (GetCVar(StrParam(s:"UACC_Logged", i:ClientPlayerNumber()))))	|		(GetPort() == ZDaemon))
																{
																if (PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
																	{
																	if (GetSectorLightLevel(TIDRAM_EnemyCount))
																		{
																		if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber())  >= GetEnemyLocatorCost())
																			{





																			Switch(GetPort())
																				{
																				case ZDaemon:			ClientCall("EnemyLocator", 				GetSectorLightLevel(TIDRAM_PasswordA), ClientPlayerNumber(), None);			break;
																				case Zandronum:			ACS_NamedExecute("EnemyLocator", None,	GetSectorLightLevel(TIDRAM_PasswordA), ClientPlayerNumber(), None);			break;
																				}

																			ClientCall("Script_RegisterPlayer", 	GetSectorLightLevel(TIDRAM_PasswordA), -GetEnemyLocatorCost(), DOESNT_MATTER);
																			}
																		else	DrawNotification(For_ClientOnly, StrParam(s:"Not enough money to use Enemy Locator. $", i:GetEnemyLocatorCost(), s:" required!"), 		notepose_BOT, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
																		}
																	else		DrawNotification(For_ClientOnly, StrParam(s:"All the casual enemies were destroyed!"), 												notepose_BOT, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
																	}
																else			DrawNotification(For_ClientOnly, StrParam(s:"Enter the teleport to use this item!"), 												notepose_BOT, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);
																}
															else 				DrawNotification(For_ClientOnly, StrParam(s:"You have to be logged in to use this item"), 											notepose_BOT, notepara_ALIGN, ICON_Exclamation, StrParam(c:ICON_Exclamation), "g", "ERFONT",  ON, ON, noteFadeIn_Standart, noteHold_Standart, noteFadeOut_Standart);

															//H = IsEven(H);
															break;//SetPlayerChasecam(ClientPlayerNumber(), IsEven(GetPlayerChasecam(ClientPlayerNumber())));	break;


									}

						//ABILITY ACTION -------------------------
								Switch(H)
									{
									CASE 0:
											Switch(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
												{
												CASE id_DroneCam:
												break;
												}
									break;

									CASE 1:
											Switch(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
												{


												CASE id_DroneCam:
															//J += 	GetPlayerInput(ClientPlayerNumber(), INPUT_PITCH)*1024;
															//K += 	GetPlayerInput(ClientPlayerNumber(), INPUT_YAW)*512;
															//Thing_Remove(ACTORTID_DroneCam);//
															//SpawnForced("ClientSpotLoop", J, K, 0, ACTORTID_DroneCam, None);//
															//log(f:GetActorFloorZ(ACTORTID_DroneCam));
															//SetActorPosition(ACTORTID_DroneCam, J, K, GetActorFloorZ(ACTORTID_DroneCam) + int2fix(DroneCamHeight), 0);
															//if (GetActorZ(ACTORTID_DroneCam) >= GetActorCeilingZ(ACTORTID_DroneCam))
															//	SetActorPosition(ACTORTID_DroneCam, J, K, GetActorCeilingZ(ACTORTID_DroneCam), 0);

															Switch (SetActorPosition(ACTORTID_DroneCam, J + GetPlayerInput(ClientPlayerNumber(), INPUT_PITCH)*1024, K + GetPlayerInput(ClientPlayerNumber(), INPUT_YAW)*512, GetActorZ(ACTORTID_DroneCam), 0))
																	{
																	CASE TRUE:
																				if (GetActorFloorZ(ACTORTID_DroneCam) + int2fix(DroneCamHeight*2) < GetActorZ(ACTORTID_DroneCam))	G = GetActorZ(ACTORTID_DroneCam);
																				else 																								G = GetActorFloorZ(ACTORTID_DroneCam) + int2fix(DroneCamHeight);
																				SetActorPosition(ACTORTID_DroneCam, GetActorX(ACTORTID_DroneCam), GetActorY(ACTORTID_DroneCam), G, 0);
																				J += 	GetPlayerInput(ClientPlayerNumber(), INPUT_PITCH)*1024;					K += 	GetPlayerInput(ClientPlayerNumber(), INPUT_YAW)*512;




																	break;
																	CASE FALSE:	SetActorPosition(ACTORTID_DroneCam, J, K, GetActorZ(ACTORTID_DroneCam), 0);											break;
																	}
															SetActorPitch(ACTORTID_DroneCam, 0.25);
															ChangeCamera(ACTORTID_DroneCam, 0, 0);
												break;



												CASE id_GenCam:
															Thing_Remove(ACTORTID_GenCam);
															J = 	GetActorAngle(PLAYER_TID + ClientPlayerNumber())*-1;
															K += 	GetPlayerInput(ClientPlayerNumber(), INPUT_PITCH)/3;
															SpawnForced("ClientSpot", GetActorX(ACTORTID_PlaygroundCenter) + FixedMul(cos(J), int2fix(GenCamDistance)), 			GetActorY(ACTORTID_PlaygroundCenter) + FixedMul(sin(J), int2fix(GenCamDistance)), int2fix(K), ACTORTID_GenCam, None);
															SetActorAngle(ACTORTID_GenCam, J + 0.5);
															SetActorPitch(ACTORTID_GenCam, 0.025);
															ChangeCamera(ACTORTID_GenCam, 0, 0);
												break;



												CASE id_MoneyTransfer:		// Choose Money Ammount to send
															Switch(GetPort())
																{
																case ZDaemon:		ScreenFade(For_ClientOnly, 1.0, CR_BLACK, 0.0, ClientMsgDelay, 0.0);		break;
																case Zandronum:		ChangeCamera(ACTORTID_ShopCamera, 0, 0);									break;
																}


															if (C != GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxTransferProducts))		LocalAmbientSound("SFXSELE", 127);
															C = GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxTransferProducts);
															//Log(s:"1    ", i:C);
															SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
															SetFont("ERFONT");

															//PRODUCT NAMES
															counter = 0; StringA = "";
															while(counter < MaxTransferProducts)
																{

																if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) 		>= 		GetTransferCatalogue(counter))		StringA = StrParam(s:StringA, s:"\cj");
																else																											StringA = StrParam(s:StringA, s:"\cu");

																if (!GetTransferCatalogue(counter))		StringA = 	StrParam(s:StringA, s:"CANCEL TRANSFER\n");
																else									StringA = 	StrParam(s:StringA, s:"$", i:GetTransferCatalogue(counter), s:"   --->   ", s:"$", i:GetTransferCatalogue(counter) - GetTransferCatalogue(counter)/MoneyTransferFeeInt, s:"\n");
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_UNTRANSLATED, 	int2fix(HUDX_BIG/2 + 88), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);

															//CURSOR
															counter = 0; StringA = "";
															while(counter < MaxTransferProducts)
																{
																if (C == counter)	StringA = StrParam(s:StringA, s:">",  s:"\n");
																else				StringA = StrParam(s:StringA, s:" ",  s:"\n");
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_RED, 	int2fix(HUDX_BIG/2 - 24), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);
															HudMessageBold(s: "SELECT MONEY AMMOUNT YOU WANT TO TRANSFER. COMMISION IS ", i:MoneyTransferFee, s:"%";					HUDMSG_PLAIN, 0,	CR_ORANGE, 	int2fix(HUDX_BIG/2 + 80), 	int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/3),  		ClientMsgDelay);
												break;

												CASE id_Advertisement:		// Choose Advertisement SLOT

															ChangeCamera(ACTORTID_ShopCamera, 0, 0);

															if (C != GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxAdds + 1))		LocalAmbientSound("SFXSELE", 127);
															C = GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxAdds + 1);

															SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
															SetFont("ERFONT");

															//PRODUCT NAMES
															counter = 0; StringA = "";
															while(counter < MaxAdds + 1)
																{
																if (!counter)			StringA =	StrParam(s:StringA, s:"CANCEL", s:"\n");
																if (counter)
																	{
																	if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) 		>= 		(GetSectorLightLevel(TIDRAM_AdvertisementCost + counter) + AdvertisementCost))
																			StringA = StrParam(s:StringA, s:"\cj");
																	else 	StringA = StrParam(s:StringA, s:"\cu");

																			StringA = StrParam(s:StringA, s:"Advertisement SLOT #", i:counter, s:"\n");
																	}
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_WHITE, 	int2fix(HUDX_BIG/2 + 88), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);


															//COST
															counter = 0; StringA = "";
															while(counter < MaxAdds + 1)
																{
																if (!counter)			StringA =	StrParam(s:StringA, s:"CANCEL", s:"\n");
																if (counter)			StringA = 	StrParam(s:StringA, s:"$", i:GetSectorLightLevel(TIDRAM_AdvertisementCost + counter) + AdvertisementCost, s:"\n");
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_GOLD, 	int2fix(HUDX_BIG/2 - 64), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);

															//CURSOR
															counter = 0; StringA = "";
															while(counter < MaxAdds + 1)
																{
																if (C == counter)	StringA = StrParam(s:StringA, s:">",  s:"\n");
																else				StringA = StrParam(s:StringA, s:" ",  s:"\n");
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_RED, 	int2fix(HUDX_BIG/2 - 24), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);
															HudMessageBold(s: "SELECT AN ADVERTISEMENT SLOT";		HUDMSG_PLAIN, 0,	CR_ORANGE, 	int2fix(HUDX_BIG/2 + 80), 	int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/3),  		ClientMsgDelay);
												break;
												}
									break;

									CASE 2:
											Switch(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
												{
												CASE id_MoneyTransfer:		// Choose Player to send to
															ChangeCamera(ACTORTID_ShopCamera, 0, 0);


															if (C != GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), PlayerCount()))		LocalAmbientSound("SFXSELE", 127);
															C = GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), PlayerCount());
															//Log(s:"1    ", i:C);

															SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
															SetFont("ERFONT");

															//PLAYER NAMES
															counter = 0; StringA = "";
															while(counter < MaxPlayers)
																{
																if (
																	((GetPort() == ZDaemon) 	&& (ClientExist(counter)))	|
																	((GetPort() == Zandronum) 	&& (GetCVar(StrParam(s:"UACC_Logged", i:counter))))
																	)
																						StringA = StrParam(s:StringA, n:counter + 1, s:"\n");
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_UNTRANSLATED, 	int2fix(HUDX_BIG/2 + 88), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);

															//CURSOR
															counter = 0; StringA = "";
															while(counter < MaxPlayers)
																{
																if (
																	((GetPort() == ZDaemon) 	&& (ClientExist(counter)))	|
																	((GetPort() == Zandronum) 	&& (GetCVar(StrParam(s:"UACC_Logged", i:counter))))
																	)
																		{
																		if (C == counter)	StringA = StrParam(s:StringA, s:">",  s:"\n");
																		else				StringA = StrParam(s:StringA, s:" ",  s:"\n");
																		}
																counter++;
																}
															HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_RED, 	int2fix(HUDX_BIG/2 - 24), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);
															HudMessageBold(s: "SELECT A PLAYER YOU WANT TO SEND MONEY TO";					HUDMSG_PLAIN, 0,	CR_ORANGE, 	int2fix(HUDX_BIG/2 + 80), 	int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/3),  		ClientMsgDelay);

												break;


												CASE id_Advertisement:		// Choose COLOR
															ChangeCamera(ACTORTID_ShopCamera, 0, 0);

															if (C != GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxAddColors))		LocalAmbientSound("SFXSELE", 127);
															C = GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxAddColors);

															SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);


															//PRODUCT NAMES
															SetFont("ERICON");
															counter = 0; StringA = "";
															while(counter < MaxAddColors)
																{
																StringA = "";
																if (!counter)			StringA =	StrParam(s:"CANCEL");
																else					StringA = 	StrParam(c:ICON_Slider);
																HudMessageBold(s: StringA;							HUDMSG_PLAIN, 0,	counter, 	int2fix(HUDX_BIG/2 + 88), 	int2fix(HUDY_MEDIUM/2 - HUDY_MEDIUM/8 + counter*8),  		ClientMsgDelay);
																counter++;

																}



															//CURSOR
															SetFont("ERFONT");
															counter = 0; StringA = "";
															while(counter < MaxAddColors)
																{
																StringA = "";
																if (C == counter)	StringA = StrParam(s:">");
																else				StringA = StrParam(s:" ");
																HudMessageBold(s: StringA;							HUDMSG_PLAIN, 0,	CR_RED, 	int2fix(HUDX_BIG/2 - 24), 	int2fix(HUDY_MEDIUM/2 - HUDY_MEDIUM/8 + counter*8),  		ClientMsgDelay);
																counter++;
																}

															HudMessageBold(s: "SELECT AN ADVERTISEMENT COLOR";		HUDMSG_PLAIN, 0,	CR_ORANGE, 	int2fix(HUDX_BIG/2 + 80), 	int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/3),  					ClientMsgDelay);
												break;




												}
									break;

									CASE -99:

											Switch(GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
												{
												CASE id_ChaseCam:
															SetPlayerChasecam(ClientPlayerNumber(), FALSE);
												break;
												}
											H = 0;
									break;
									}


						}
/*
if ((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_USE) 	&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & BT_USE)))
ChangeCamera(ACTORTID_ShopCamera, 0, 0);
*/








					if (PlayerStatus(ClientPlayerNumber()) != ps_HUB)
						if (B)
							ChangeCamera(0, 0, 0);

					if (PlayerStatus(ClientPlayerNumber()) == ps_HUB)
							{

					//if(GetPort() == Zandronum)
					//		{
								counter = 0;
								while(counter < PlaygroundBlocks)
									{
									counter++;
									//SetCvar(StrParam(s:"ER_SRADAR", i:counter), None);
									Light_ChangeToValue(TIDRAM_Radar + counter, None);
									}
					//		}




							if (GetSectorLightLevel(TIDRAM_JoinTimeLeft) > 0)
								EntryTeleportWarning();



							if(			((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS)) && (GetPort() > ZDaemon)) ||  ((!(GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS))) && (GetPort()== ZDaemon))		)
								{
								//if (!(GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_USE))
							if(			((!(GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_USE)) && (GetPort() > ZDaemon)) ||  (((GetActorVelX(PLAYER_TID + ClientPlayerNumber())) || (GetActorVelY(PLAYER_TID + ClientPlayerNumber())) || (GetActorVelZ(PLAYER_TID + ClientPlayerNumber()))) && (GetPort()== ZDaemon))		)
							//if ((GetActorVelX(PLAYER_TID + ClientPlayerNumber())) || (GetActorVelY(PLAYER_TID + ClientPlayerNumber())) || (GetActorVelZ(PLAYER_TID + ClientPlayerNumber())))
									{
									if (B == 2)
											{
											ClientCall("Client_ExitShop", GetSectorLightLevel(TIDRAM_PasswordA), None, None);
											Switch(GetPort())
												{
												CASE ZDaemon:
												AmbientSound("SFXCANCE", 127);
												ScreenFade(For_ClientOnly, 1.0, CR_BLACK, 0.0, 0.0, 0.2);
												break;

												CASE Zandronum:
												CASE GZDoom:
												LocalAmbientSound("SFXCANCE", 127);
												ChangeCamera(0, 0, 0);
												H = -99;
												ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
												break;
												}
											}

									B = FALSE;
									}
								}



							else
									{
									if (B != 2)
										//if (F > 35)
											{
											B = 1;

											}

									}






								// SHOW SHOP KEY
							if (!GetSectorLightLevel(TIDRAM_Intro))
								//if (	(GetPort() > ZDaemon) 		||		 (((!GetActorVelX(PLAYER_TID + ClientPlayerNumber())) && (!GetActorVelY(PLAYER_TID + ClientPlayerNumber())) && (!GetActorVelZ(PLAYER_TID + ClientPlayerNumber()))) && (GetPort()== ZDaemon))	)
								//if 	(B)//(B != 2)
								if (GetPort() != GZDoom)
									{




									StringA = StrParam(k:"+use");
									if (GetPort() == ZDaemon) StringA = StrParam(s:StringA, s:" + stay still");

									SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
									D = StrLen(StringA);

									if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) > 0)		{	E = -44; 	StringA = "r\nt\ns";	}
									else																	{	E =  36;	StringA = "b\nf\nd";	}

									counter = 0;
									SetFont("ERICON");
									HudMessageBold(s:StringA;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 				HUDid_SHOP_BACKA,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E), 		int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.25);
									while(counter < D + 6)
										{
										HudMessageBold(s:"g\ni\nh";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 				HUDid_SHOP_BACKB + counter,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 		int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.25);
										counter++;
										}
									HudMessageBold(s:"a\ne\nc";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 				HUDid_SHOP_BACKC,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 		int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.25);
									SetFont("ERFONT");
									StringA = StrParam(k:"+use");
									if (GetPort() == ZDaemon) StringA = StrParam(s:StringA, s:" + stay still");
									HudMessageBold(s:StrToUpper(StringA);		HUDMSG_FADEOUT|HUDMSG_ALPHA, 							HUDid_SHOP_LETTER,	CR_WHITE, int2fix(X_MIDDLE_BACK + E - (1 + (counter - 4)/2)*8), 	int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.5);



									SetFont("ERICON");

									Switch(B)
										{
										CASE 0:
										CASE 1:	G = ICON_Shop;		break;
										CASE 2:	G = ICON_Money;		break;
										}

									HudMessageBold(c:G;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 							HUDid_SHOP_ICON,	CR_WHITE, int2fix(X_MIDDLE_BACK + E + 2 - (counter)*8), 	int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.5);
									}



								if (!GetSectorLightLevel(TIDRAM_Intro))
									if ((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_USE) 	&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & BT_USE)))
										Switch(B)
											{
											CASE 1:
											B = 2;

											Switch(GetPort())
												{
												CASE ZDaemon:

												//if facing Changelog
												if  (
														(PlayerJoined < SEC)		|

														((CheckActorPosition(PLAYER_TID + ClientPlayerNumber(), pos_ByXYZ, 48, DOESNT_MATTER, -388, 10712, 0))		&&
														((GetActorAngle(PLAYER_TID + ClientPlayerNumber()) < 0.625)	&&	(GetActorAngle(PLAYER_TID + ClientPlayerNumber()) > 0.125))		)

													)		B = 1;


												else
												ScreenFade(For_ClientOnly, 1.0, CR_BLACK, 0.0, 0.0, 0.0);
												break;

												CASE Zandronum:
												CASE GZDoom:
												if (GetCvar("ER_Tutorial") == 3)	SetCvar("ER_Tutorial", 4);
												ChangeCamera(ACTORTID_ShopCamera, 0, 0);
												H = -99;
												ScreenFade(For_ClientOnly, 1.0, CR_WHITE, 0.0, 0.0, 0.2);
												break;
												}


											break;

											CASE 2:

												ClientCall("BuyAccessory",	GetProductCatalogue(C), False, None);

												if (GetProductCatalogue(C) == id_GenCam)
												if (GetPort() == ZDaemon)
													{
														B = 1;
														ClientCall("ZDA_ShowPlayground",	None, None, None);
													}

											break;
											}






								Switch(B)
									{
									CASE 1:
									break;

									CASE 2: //entered the shop
									Switch(GetPort())
										{
										CASE ZDaemon:
										ScreenFade(For_ClientOnly, 1.0, CR_BLACK, 0.0, ClientMsgDelay, 0.0);
										break;

										CASE Zandronum:
										CASE GZDoom:

										break;
										}






									if (C != GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxProducts))
													Switch(GetPort())
														{
														CASE ZDaemon:	AmbientSound("SFXSELE", 127);		break;
														CASE Zandronum:
														CASE GZDoom: 	LocalAmbientSound("SFXSELE", 127); 	break;
														}

									C = GetShopSelection(GetActorPitch(PLAYER_TID + ClientPlayerNumber()), MaxProducts);



									SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
									SetFont("ERFONT");

									//PRODUCT NAMES
									counter = 0; StringA = "";
									while(counter < MaxProducts)
										{

										Switch(GetPort())
											{
											CASE ZDaemon:		if (counter == id_GenCam)	 	StringB = "\ck";
																else							StringB = "\cj";
																StringA = StrParam(s:StringA, s:StringB, s:ActorString(GetProductCatalogue(counter)   , as_TEXT), s:"\n");
																break;
											CASE Zandronum:
											CASE GZDoom:
																if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) 		>= 		GetProductProperties(GetProductCatalogue(counter), 1))
																StringA = StrParam(s:StringA, s:"\cj", s:ActorString(GetProductCatalogue(counter)   , as_TEXT), s:"\n");
																else
																StringA = StrParam(s:StringA, s:"\cu", s:ActorString(GetProductCatalogue(counter)   , as_TEXT), s:"\n");
																break;
											}
										//StringA = StrParam(s:StringA, s:ActorString(GetProductCatalogue(counter)   , as_TEXT), s:"\n");
										counter++;
										}

										Switch(GetPort())
											{
											CASE ZDaemon:		HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_WHITE, 			int2fix(HUDX_BIG/2 + 112), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);
																break;
											CASE Zandronum:
											CASE GZDoom:
																HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_UNTRANSLATED, 	int2fix(HUDX_BIG/2 + 112), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);
																break;
											}





									//PRODUCT COST
									counter = 0; StringA = "";
									while(counter < MaxProducts)
										{
										Switch(GetProductProperties(GetProductCatalogue(counter), 5))
											{
											CASE 1: 	StringA = StrParam(s:StringA, s:"$",  i:GetProductProperties(GetProductCatalogue(counter), 1), s:"\n");		break;
											CASE 2: 	StringA = StrParam(s:StringA, s:"W",  i:GetProductProperties(GetProductCatalogue(counter), 1), s:"\n");		break;
											}

										//StringA = StrParam(s:StringA, s:"$",  i:GetProductProperties(GetProductCatalogue(counter), 1), s:"\n");
										counter++;
										}
									HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_GOLD, 	int2fix(HUDX_BIG/2 - 64), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);


									//SPECIAL OR NOT
									SetFont("ERICON");
									counter = 0; StringA = "";
									while(counter < MaxProducts)
										{
										Switch(GetProductProperties(GetProductCatalogue(counter), 4))
											{
											CASE 0: G = ICON_None;		break;
											CASE 1: G = ICON_Special;	break;
											}
										if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) 		>= 		GetProductProperties(GetProductCatalogue(counter), 1))	StringA = StrParam(s:StringA, s:"\cj", c:G,  s:"\n");
										else																																StringA = StrParam(s:StringA, s:"\cu", c:G,  s:"\n");
										counter++;
										}
									HudMessageBold(s: StringA;					HUDMSG_PLAIN|HUDMSG_ALPHA, 0,	CR_UNTRANSLATED, 	int2fix(HUDX_BIG/2 - 4), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay, 0.75);


									//CURSOR
									SetFont("ERFONT");
									counter = 0; StringA = "";
									while(counter < MaxProducts)
										{
										if (C == counter)	StringA = StrParam(s:StringA, s:">",  s:"\n");
										else				StringA = StrParam(s:StringA, s:" ",  s:"\n");
										counter++;
										}
									HudMessageBold(s: StringA;					HUDMSG_PLAIN, 0,	CR_RED, 	int2fix(HUDX_BIG/2 - 24), 	int2fix(HUDY_MEDIUM/2),  		ClientMsgDelay);


									StringA = StrParam(s:ActorString(GetProductCatalogue(C)   , as_INFO));

									if  (GetSectorLightLevel(TIDRAM_Ability + ClientPlayerNumber()))
										G = GetProductProperties(GetProductCatalogue(C), 2);
											if ((G >= id_MinAbility) && (G <= id_MaxAbility))
												if (CarriesAbility(G, ClientPlayerNumber()))
													StringA = StrParam(s:StringA, s: "\n\n\cgIT WILL REPLACE YOUR CURRENT SPECIAL!");

									HudMessageBold(s:StringA;					HUDMSG_PLAIN, 0,	CR_ORANGE, 	int2fix(HUDX_BIG/2 + 80), 	int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/3),  		ClientMsgDelay);

									break;
									}



							}




					//EXIT MARKER	based on script by Kaminsky

						ExitMarkerPLUSDeathFloor();



				}



			break;


			CASE DeadSpectator:
			CASE TrueSpectator:






			LocalSetMusic(StrParam(s:"D_MUS", i:GetSectorLightLevel(TIDRAM_RoundMusic)));


			break;
			}

												/*
												 ___      ___   __    _____  ___    __     _______       __       ___      ___   _______
												|"  \    /"  | |" \  (\"   \|"  \  |" \   /" _   "|     /""\     |"  \    /"  | /"     "|
												 \   \  //   | ||  | |.\\   \    | ||  | (: ( \___)    /    \     \   \  //   |(: ______)
												 /\\  \/.    | |:  | |: \.   \\  | |:  |  \/ \        /' /\  \    /\\  \/.    | \/    |
												|: \.        | |.  | |.  \    \. | |.  |  //  \ ___  //  __'  \  |: \.        | // ___)_
												|.  \    /:  | /\  |\|    \    \ | /\  |\(:   _(  _|/   /  \\  \ |.  \    /:  |(:      "|
												|___|\__/|___|(__\_|_)\___|\____\)(__\_|_)\_______)(___/    \___)|___|\__/|___| \_______)

												*/
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------
// A - Alpha, B - BallMiss, C - mgPlayerCounter,

if (GetPort() != GZDoom)
	if (PlayerIsSpectator(ClientPlayerNumber()) != NotSpectator)
		//if ((GetSectorLightLevel(TIDRAM_GameSim) && (GetPort() == Zandronum)) || (GetPort() == ZDaemon))	//Zandronum tend to lag asf if server is idling
			if (GetSectorLightLevel(TIDRAM_WinCamera) == 101)
			{
					/*
					  _           _   _                       _    ____ _____ ___ ___  _   _
					 | |__  _   _| |_| |_ ___  _ __  _       / \  / ___|_   _|_ _/ _ \| \ | |
					 | '_ \| | | | __| __/ _ \| '_ \(_)     / _ \| |     | |  | | | | |  \| |
					 | |_) | |_| | |_| || (_) | | | |_     / ___ \ |___  | |  | | |_| | |\  |
					 |_.__/ \__,_|\__|\__\___/|_| |_(_)   /_/   \_\____| |_| |___\___/|_| \_|

					*/
					if ((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & ButtonIs(button_ACTION)) 		&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & ButtonIs(button_ACTION))))
						{
						//UPDATE
						A = mg_AlphaMax;
						ClientCall("mg_ACTION", GetSectorLightLevel(TIDRAM_PasswordA), ClientPlayerNumber(), None);
						}

						/*
												_     _
						   __ _ _ __ __ _ _ __ | |__ (_) ___ ___
						  / _` | '__/ _` | '_ \| '_ \| |/ __/ __|
						 | (_| | | | (_| | |_) | | | | | (__\__ \
						  \__, |_|  \__,_| .__/|_| |_|_|\___|___/
						  |___/          |_|

						*/
						//


						counter = 0;	C = 0;
						while (counter <= MaxPlayers)
							{

							if (GetSectorLightLevel(MGRAM_PlayerActivity + counter))	//if there is any active player

								{
								C++;

								//PLAYERNAME
								SetHUDSize(HUDX_MINIGAME/2, HUDY_MINIGAME/2, 0);
								SetFont("ERFONT");
								HudMessageBold(s:mg_PlayerName(counter);							HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDmg_PlayerName + mg_PlayerHUDid(counter, C), 	mg_PlayerColor(counter, C), 		int2fix((mg_offsetX + mg_YardEdge(counter) + mg_StatOffset(counter,  232))/2), 			int2fix((mg_offsetY + mg_SliderOffsetY() + GetSectorLightLevel(MGRAM_PlayerPos + counter))/2), 			ClientMsgDelay, 	A);		/*int2fix(HUDY_MINIGAME/2/2 + HUDY_MINIGAME/2/4)*/

								//PTS
								SetHUDSize(HUDX_MINIGAME/2, HUDY_MINIGAME/2, 0);
								SetFont("ERFONT");
								HudMessageBold(i:GetSectorLightLevel(MGRAM_PlayerPTS + counter);	HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDmg_PTS + mg_PlayerHUDid(counter, C), 		mg_PlayerColor(counter, C), 		int2fix((mg_offsetX + mg_YardEdge(counter) + mg_StatOffset(counter,  96))/2),			int2fix((mg_offsetY + mg_SliderOffsetY() + GetSectorLightLevel(MGRAM_PlayerPos + counter))/2), 			ClientMsgDelay, 	A);		//mg_PlayerAlpha(counter, A));

								//SLIDER
								SetHUDSize(HUDX_MINIGAME, HUDY_MINIGAME, 0);
								SetFont("ERICON");
								HudMessageBold(s:mg_SLIDER(counter);								HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDmg_Slider + mg_PlayerHUDid(counter, C), 		mg_PlayerColor(counter, C), 		int2fix(mg_offsetX + mg_YardEdge(counter) + mg_PlayerOffset(counter, C)),				int2fix(mg_offsetY /*+ mg_SliderOffsetY()*/ + GetSectorLightLevel(MGRAM_PlayerPos + counter)), 			ClientMsgDelay, 	A);		//mg_PlayerAlpha(counter, A));

								}

							counter++;
							}


						if (C)
						{
						//BACKGROUND
						SetHUDSize(HUDX_MINIGAME/8, HUDY_MINIGAME/8, 0);
						SetFont("ERICON");
/*
						if (B != GetSectorLightLevel(MGRAM_BallPosX1) + GetSectorLightLevel(MGRAM_BallPosX2))
						if (abs(B - GetSectorLightLevel(MGRAM_BallPosX1) + GetSectorLightLevel(MGRAM_BallPosX2)) > mg_WIDTH/2 - mg_WIDTH/8)
						HudMessage(s:mg_BACKGROUND(1);											HUDMSG_FADEOUT|HUDMSG_ALPHA, 		HUDmg_Background, 								CR_WHITE, 							int2fix(HUDX_MINIGAME/8/2), 												int2fix(mg_CenterY/8), 														0, 	0.5, 			A);

						B = GetSectorLightLevel(MGRAM_BallPosX1) + GetSectorLightLevel(MGRAM_BallPosX2);
*/
						HudMessageBold(s:mg_BACKGROUND(1);											HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDmg_Background, 								CR_BLACK, 							int2fix(HUDX_MINIGAME/8/2), 												int2fix(mg_CenterY/8 /*+ HUDY_MINIGAME/8/4*/), 														ClientMsgDelay, 	A);

						//BALL
						SetHUDSize(HUDX_MINIGAME, HUDY_MINIGAME, 0);
						SetFont("ERICON");
						HudMessageBold(c:ICON_WHiteScreen;											HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDmg_BALL, 									CR_GOLD, 							int2fix(mg_offsetX + GetSectorLightLevel(MGRAM_BallPosX1) + GetSectorLightLevel(MGRAM_BallPosX2)),			int2fix(mg_offsetY + GetSectorLightLevel(MGRAM_BallPosY)), 			ClientMsgDelay, 	A);		//mg_PlayerAlpha(counter, A));
						if (GetPort() == Zandronum)
						if (!GetSectorLightLevel(TIDRAM_GameSim))
							{
							DrawNotification(For_ClientOnly, StrParam(s:"This minigame may lag because zandronum works in a 'slow mode', when"), notepose_TOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_Minigame), 	"u", "ERFONT",  OFF, OFF, 0, ClientMsgDelay, 0);
							DrawNotification(For_ClientOnly, StrParam(s:"there in no players in the main game. Otherwise it works fine."), 		notepose_MID, notepara_ALIGN, ICON_None, StrParam(c:ICON_None), 		"u", "ERFONT",  OFF, OFF, 0, ClientMsgDelay, 0);
							}


						}
						else

							{


							SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);

							if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) > 0)		{	E = -44; 	StringA = "r\nt\ns";	}
							else																	{	E =  36;	StringA = "b\nf\nd";	}

							SetFont("ERICON");
							HudMessageBold(s:StringA;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 								HUDid_SHOP_BACKA,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E), 		int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.25);

							D = StrLen(StrParam(k:ButtonKeyIs(button_ACTION)));
							counter = 0;
							while(counter < D + 6)
								{
								HudMessageBold(s:"g\ni\nh";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 							HUDid_SHOP_BACKB + counter,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 		int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.25);
								counter++;
								}
							HudMessageBold(s:"a\ne\nc";		HUDMSG_FADEOUT|HUDMSG_ALPHA, 								HUDid_SHOP_BACKC,		COLORTEXT_MAIN, int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 		int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.25);
							SetFont("ERFONT");


							HudMessageBold(s:StrToUpper(StrParam(k:ButtonKeyIs(button_ACTION)));		HUDMSG_FADEOUT|HUDMSG_ALPHA, 		HUDid_SHOP_LETTER,	CR_WHITE, int2fix(X_MIDDLE_BACK + E - (1 + (counter - 4)/2)*8), 	int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.5);

							SetFont("ERICON");
							HudMessageBold(c:ICON_Minigame;		HUDMSG_FADEOUT|HUDMSG_ALPHA, 							HUDid_SHOP_ICON,	CR_WHITE, int2fix(X_MIDDLE_BACK + E + 2 - (counter)*8), 	int2fix(Y_MONEY), ClientMsgDelay, 0.25, 0.5);
							}


						if (A > mg_AlphaMax) 	A = mg_AlphaMax;
						if(!GetCVar("ER_OverlayPong"))	A -= mg_AlphaDec;
						else
							{
							if (A > mg_AlphaMin) 	A -= mg_AlphaDec;
							}

						//log(f:FixedMul(int2fix(31), 0.0001));



			//END OF MINIGAME


			//MUSIC
/*
					if (GetPort() == Zandronum)
							{
							SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);

//							if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) > 0)		{	E = -44; 	StringA = "r\nt\ns";	}
//							else																	{	E =  36;	StringA = "b\nf\nd";	}

							E = 36;		StringA = "b\nf\nd";
							SetFont("ERICON");
							HudMessage(s:StringA;									HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDid_BOTCORNER_BACKA,				COLORTEXT_MAIN,		 int2fix(X_MIDDLE_BACK + E), 							int2fix(Y_BOTCORNER_ICON), ClientMsgDelay, 0.25);

							D = StrLen(StrParam(k:"+crouch"));
							counter = 0;
							while(counter < D + 6)
								{
								HudMessage(s:"g\ni\nh";								HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDid_BOTCORNER_BACKB + counter,	COLORTEXT_MAIN, 	int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 			int2fix(Y_BOTCORNER_ICON), ClientMsgDelay, 0.25);
								counter++;
								}
							HudMessage(s:"a\ne\nc";									HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDid_BOTCORNER_BACKC,				COLORTEXT_MAIN, 	int2fix(X_MIDDLE_BACK + E - (1 + counter)*8), 			int2fix(Y_BOTCORNER_ICON), ClientMsgDelay, 0.25);
							SetFont("ERFONT");


							HudMessage(s:StrToUpper(StrParam(k:"+crouch"));			HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDid_BOTCORNER_LETTER,				CR_WHITE, 			int2fix(X_MIDDLE_BACK + E - (1 + (counter - 4)/2)*8), 	int2fix(Y_BOTCORNER_ICON), ClientMsgDelay, 0.5);

							SetFont("ERICON");
							HudMessage(c:ICON_MUSIC;								HUDMSG_PLAIN|HUDMSG_ALPHA, 			HUDid_BOTCORNER_ICON,				CR_WHITE, 			int2fix(X_MIDDLE_BACK + E + 2 - (counter)*8), 			int2fix(Y_BOTCORNER_ICON), ClientMsgDelay, 0.5);



							if ((GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_CROUCH) 	&& (!(GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS) & BT_CROUCH)))
								{
								}


							}

*/




			}




	//CAMERA------------------------------------------------------------------------

	if (GetSectorLightLevel(TIDRAM_WinCamera) == 100|| GetSectorLightLevel(TIDRAM_WinCamera) == 99)		//CREDITS ROLL, WINNER TITLE
		{
		J = 0;	K = 0;	H = 0;
		ChangeCamera(ACTORTID_SkyboxCamera, 0, 0);
		}


	if (GetSectorLightLevel(TIDRAM_WinCamera)  < 99)													//PLAYER INPUT HIS NAME
			if (ClientPlayerNumber() != GetSectorLightLevel(TIDRAM_WinCamera))
					{
						Thing_Remove(ACTORTID_WinnerCam);
						J += 	GetPlayerInput(ClientPlayerNumber(), INPUT_YAW);
						//K += 	GetPlayerInput(ClientPlayerNumber(), INPUT_PITCH)/3;
						SpawnForced("ClientSpot", GetActorX(PLAYER_TID + GetSectorLightLevel(TIDRAM_WinCamera)) + FixedMul(cos(J), int2fix(192)), 			GetActorY(PLAYER_TID + GetSectorLightLevel(TIDRAM_WinCamera)) + FixedMul(sin(J), int2fix(192)), GetActorZ(PLAYER_TID + GetSectorLightLevel(TIDRAM_WinCamera)) + int2fix(128), ACTORTID_WinnerCam, None);
						SetActorAngle(ACTORTID_WinnerCam, J + 0.5);
						SetActorPitch(ACTORTID_WinnerCam, 0.065);
						ChangeCamera(ACTORTID_WinnerCam, 0, 0);
					}

			else		ChangeCamera(0, 0, 0);



	// RAISE TEXTURE OFFSET
		DrawClientSubstanceOffset();

	//SKYBOX------------------------------------------------------------------------
	if (!GetSectorLightLevel(TIDRAM_Intro))
		{
			D = GetSectorLightLevel(TIDRAM_SkyboxVolume);

			// IF STAGE IS WON
			if (GetSectorLightLevel(TIDRAM_WinCamera) < 101)
				{

				if (GetSectorLightLevel(TIDRAM_WinCamera) < 99)
				if (ClientPlayerNumber() == GetSectorLightLevel(TIDRAM_WinCamera)) //if the winner is in it
					{
						StringA = "";
						Switch (GetCVar(StrParam(s:"UACC_Logged", i:ClientPlayerNumber())))
							{
							CASE FALSE:
								Switch(GetPort())
									{
									CASE ZDaemon:	StringA = "USE THE SAME NAME TO INCREMENT SEASON SCORES!";								StringB = "";		break;

									CASE Zandronum:	StringA = "LOG IN TO REGISTER YOUR WIN! OTHERWISE SEASON SCORE WON'T INCREMENT!";
													StringB = "THIS AREA IS FOR THE DECORATIVE NAME OF YOUR POTENTIAL MONUMENT!";
									break;	//71
									}
							break;
							CASE TRUE:
													StringA = "INPUT YOUR NAME FOR THE DECORATIVE PURPOSE!";
													StringB = "KEEP WINNING AND IT MAY APPEAR IN THE MONUMENTS OF THE LEGENDS!";
							break;
							}

						DrawNotification(For_ClientOnly, StrParam(s:StringA), 		notepose_SPECIAL, 	notepara_ALIGN, ICON_EXCLAMATION,	StrParam(c:ICON_EXCLAMATION), 	"j", "ERFONT",  OFF, ON, 0, ClientMsgDelay, 0);
						DrawNotification(For_ClientOnly, StrParam(s:StringB), 		notepose_TOP, 		notepara_ALIGN, ICON_NONE, 			StrParam(c:ICON_None), 			"j", "ERFONT",  OFF, ON, 0, ClientMsgDelay, 0);
					}


				StringA =  "00";
				TranslucentLine(LINETAG_VolumetricD_up, 0, 1);
				TranslucentLine(LINETAG_VolumetricD_dn, 0, 1);


				}

			// IF GAME IS ACTIVE
			else
				{
				if(GetClientSpectateStatus(ClientPlayerNumber()) == TrueSpectator)
						{
						StringA =  "00";
						TranslucentLine(LINETAG_VolumetricD_up, D, 1);
						TranslucentLine(LINETAG_VolumetricD_dn, D, 1);
						}
				else
				Switch(PlayerStatus(ClientPlayerNumber()))
						{
						CASE ps_HUB:
						StringA =  "00";
						TranslucentLine(LINETAG_VolumetricD_up, D, 1);
						TranslucentLine(LINETAG_VolumetricD_dn, D, 1);
						break;



						CASE ps_DEAD:
						if (!GetSectorLightLevel(TIDRAM_SkyType))
								{
								StringA =  "00";
								TranslucentLine(LINETAG_VolumetricD_up, 0, 1);
								TranslucentLine(LINETAG_VolumetricD_dn, 0, 1);
								}
						else
								{
								StringA =  StrParam(i:GetSectorLightLevel(TIDRAM_SkyType));
								TranslucentLine(LINETAG_VolumetricD_up, 0, 1);
								TranslucentLine(LINETAG_VolumetricD_dn, 0, 1);
								}


						break;




						CASE ps_PLAYGROUND:
						StringA =  StrParam(i:GetSectorLightLevel(TIDRAM_SkyType));
						TranslucentLine(LINETAG_VolumetricD_up, 0, 1);
						TranslucentLine(LINETAG_VolumetricD_dn, 0, 1);
						break;
						}
				}


			for (D = 1; D <= 64;  D++)
				{
				ChangeFloor		(SECTORTAG_Skybox + D,								StrParam(s:"SK", s:StringA, s:"FL", i:D));
				ChangeCeiling	(SECTORTAG_Skybox + D,								StrParam(s:"SK", s:StringA, s:"CE", i:D));
				}
			for (D = 1; D <=  4;  D++)
				SetLineTexture	(SECTORTAG_Skybox + D, SIDE_FRONT, TEXTURE_MIDDLE,	StrParam(s:"SK", s:StringA, s:"WA", i:D));
		}


//----------------------------------------------------------------------------------------


		//SHOW MONEY
	if (!GetSectorLightLevel(TIDRAM_Intro))
		if (GetSectorLightLevel(TIDRAM_WinCamera) == 101 )
		{
		if (GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber()) > 0)
				{
				SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
				SetFont("ERFONT");
				HudMessageBold(s:"$";																HUDMSG_FADEOUT|HUDMSG_ALPHA, 			HUDid_MoneyIcon, 		CR_GOLD, 		int2fix(X_TOP_ICON), 		int2fix(Y_MONEY), 			ClientMsgDelay, 1.0, 1.0);
				HudMessageBold(i:GetSectorLightLevel(TIDRAM_Money + ClientPlayerNumber());			HUDMSG_FADEOUT|HUDMSG_ALPHA, 			HUDid_MoneyValue, 		CR_GOLD, 		int2fix(X_TOP_LETTER), 		int2fix(Y_MONEY), 			ClientMsgDelay, 1.0, 1.0);
				SetFont("ERICON");
				HudMessageBold(s:FrameString();														HUDMSG_FADEOUT|HUDMSG_ALPHA, 			HUDid_MoneyBack, 		CR_GOLD, 		int2fix(X_TOP_BACK), 		int2fix(Y_MONEY), 			ClientMsgDelay, 1.0, 0.25);
				}

	if (GetSectorLightLevel(TIDRAM_QuizTimer))
				{
				SetFont("ERICON");
				HudMessageBold(c:ICON_Clock;													HUDMSG_FADEOUT, 						HUDid_VBOTTOM_ICON,		CR_CYAN, 		int2fix(X_VBOTTOM_ICON), 	int2fix(Y_VBOTTOM_ICON), 	ClientMsgDelay, 1.0);
				SetFont("ERFONT");
				HudMessageBold(s:PrintClock(GetSectorLightLevel(TIDRAM_QuizTimer));				HUDMSG_FADEOUT, 						HUDid_VBOTTOM_LETTER,	CR_CYAN, 		int2fix(X_VBOTTOM_LETTER), 	int2fix(Y_VBOTTOM_LETTER), 	ClientMsgDelay, 1.0);
				SetFont("ERICON");
				HudMessageBold(s:FrameString();													HUDMSG_FADEOUT|HUDMSG_ALPHA,			HUDid_VBOTTOM_BACK , 	CR_CYAN, 		int2fix(X_VBOTTOM_BACK), 	int2fix(Y_VBOTTOM_BACK), 	ClientMsgDelay, 1.0, 0.5);
				}
		}



	if  (GetSectorLightLevel(TIDRAM_EnemyCount) > 0)
		if (CheckActorFloorTexture(PLAYER_TID + ClientPlayerNumber(), "GATE1"))
				DrawNotification(For_ClientOnly, StrParam(s:"There is still ", i:GetSectorLightLevel(TIDRAM_EnemyCount), s:" enemies left!"),	notepose_BOT, notepara_ALIGN, ICON_None, StrParam(c:ICON_EnemyCount), "g", "ERFONT", OFF, ON, 0, noteHold_Short, noteFadeOut_Short);


		if (GetPort() == Zandronum)
			{

				//SERVER NOTIFICATION
				if (GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS) & BT_SHOWSCORES)
						{
						SetHUDSize(HUDX_MEDIUM, HUDY_MEDIUM, FALSE);
						SetFont("CONFONT");
						HudMessageBold(s:GetCvarString("ER_Note");		HUDMSG_PLAIN, 0, CR_GREY, int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 + HUDY_MEDIUM/3),  0.03 );
						}

				//DEBUG_CLIENT

				Switch(GetCvar("ER_DebugMode"))
					{
					CASE 0:	StringA = "None";
					break;


					CASE 1:	StringA = "Give Weapons/HP (while testing)";
					break;


					CASE 2:	StringA = "Show player's database money";
					break;


					CASE 3:	StringA = "Geometry Info";

					SetHUDSize(0, 0, 0);
					SetFont("ERFONT");
							HudMessageBold(


							s:"\n\n",
							s:"\n\n",
							s:"\n\n",
							s:"\n\n",
							s:"\n\n\n\n",
							s:"\n\n",
							s:"\n\n",
							s:"\n\n",
							s:"\ckHEIGHT  ", 			f:GetActorZ			(PLAYER_TID + ClientPlayerNumber()), 	s:"\n\n",
							s:"\ciCEILI HEIGHT    ",	f:GetActorCeilingZ	(PLAYER_TID + ClientPlayerNumber()),	s:"\n",
							s:"\ciFLOOR HEIGHT    ",	f:GetActorFloorZ	(PLAYER_TID + ClientPlayerNumber()),	s:"\n",

							s:"\n",
							s:"\n",
							s:"\cvVelocityX ", i:GetActorVelX(PLAYER_TID + ClientPlayerNumber())>>16, s:"    VelocityY ", i:GetActorVelY(PLAYER_TID + ClientPlayerNumber())>>16, s:"\n"

							;HUDMSG_PLAIN, HUDid_DebugCLIENT, CR_UNTRANSLATED, 0.2, 0.7, ClientMsgDelay);
					break;
					}
					if (IsNetworkGame())	StringA = StrParam(s:"\cu", s:StringA);
					SetCVarString("ER_DebugTitle", StringA);

			}



	if (!PlayerIsSpectator(ClientPlayerNumber()))		if (PlayerJoined < SEC)		PlayerJoined++;


	if (PerSec) PerSec--;
	else PerSec = Sec;

	delay(1);
	}


if (GetPort() == Zandronum)
	if (IsNetworkGame())
		if (GetGameModeState() == GAMESTATE_INRESULTSEQUENCE)
			if (GetCvar("ER_MarkedX") < MarkedXInfo)
			{
				A = 0;
				while (A < StrLen(GetCVarString("ER_Scoreboard")))
					{
						if (GetChar(GetCVarString("ER_Scoreboard"), A) == 38)
							{
								SetCvar("ER_MarkedX", GetCvar("ER_MarkedX") + 1);
								SetHUDSize(HUDX_MEDIUM,		HUDY_MEDIUM,	FALSE);		SetFont("ERFONT");
								HudMessageBold(	s:"Winners marked 'X' were not logged in their account upon their\n",
											s:"victory and thus their win won't be calculated when the game \n",
											s:"will decide a season winner.  Please, log in next time!";
											HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_RED,	int2fix(HUDX_MEDIUM/2), int2fix(HUDY_MEDIUM/2 - HUDY_MEDIUM/3 - HUDY_MEDIUM/8),	MissionFailed_Hold, MissionFailed_FadeIn, MissionFailed_FadeOut);
								break;
							}
						A++;
					}
			}



}






script "TOASTY" (void) CLIENTSIDE
{
int i = HUDX_BIG + ToastySize - 1;
int Tendency = ToLEFT;
int Hold = ToastyHold;
LocalAmbientSound("SFXTOAST", StandartVolume);
while(i < HUDX_BIG + ToastySize)
{
	SetHUDSize(HUDX_BIG, HUDY_BIG, FALSE);
	SetFont("MKTOASTY");
	HudMessage(s:"a";						HUDMSG_PLAIN, HUDid_TOASTY,	CR_UNTRANSLATED, 	int2fix(i), 		int2fix(HUDY_BIG - ToastySize/2),  		ClientMsgDelay);
		Switch(Tendency)
			{
			CASE ToLEFT:
				if (i > HUDX_BIG - ToastySize/64)	i-= ToastySpeed;
				else								Tendency = None;
			break;

			CASE None:
				if (Hold)							Hold--;
				else								Tendency = ToRIGHT;
			break;

			CASE ToRIGHT:
				if (i < HUDX_BIG + ToastySize)		i+= ToastySpeed;
			break;
			}
	delay(1);
}

}


function int mg_YardEdge (int counter)
{
int Result;

Switch(GetSectorLightLevel(MGRAM_EvenOdd + counter))
	{
	CASE 1: Result = -4; 			break;
	CASE 0: REsult = mg_WIDTH + 4;	break;
	}
return Result;
}





function str mg_PlayerName	(int counter)
{
str Result = ""; str StringA = "";
int i;
if (counter < MaxPlayers)	Result = StrParam(n:counter + 1);
else						Result = "AI";

Result = StripColors(Result);

if (StrLen(Result) > SPS_NameMaxChars)
	{
	while (StrLen(StringA) < SPS_NameMaxChars - 2)
		{
		StringA = StrParam(s:StringA, c:GetChar(Result, i));
		i++;
		}
	Result = StrParam(s:StringA, s:"..");
	}

Result = StrToUpper(Result);

return Result;
}








function int mg_PlayerHUDid	(int counter, int C)
{
int Result;
if (counter == ClientPlayerNumber())	Result = -1;
else									Result = C;
return Result;
}



function int mg_PlayerAlpha	(int counter, int Alpha)
{
int Result;

if (counter == ClientPlayerNumber())	Result = Alpha + 0.5;
else									Result = Alpha - 0.1;//Alpha - 0.003 - FixedMul(int2fix(counter), 0.0001);

return Result;
}



function int mg_StatOffset (int counter, int Dist)
{
int Result = 1;


	Switch(GetSectorLightLevel(MGRAM_EvenOdd + counter))
		{
		CASE 1:	Result = -Result;	break;
		CASE 0: Result = Result; 	break;
		}


		Result = Result*(Dist);


return Result;
}


function int mg_PlayerOffset (int counter, int C)
{
int Result;

if (counter == ClientPlayerNumber())	Result = 0;
else									Result = 1;


Switch(GetSectorLightLevel(MGRAM_EvenOdd + counter))
	{
	CASE 1:	Result = -Result;	break;
	CASE 0: Result = Result; 	break;
	}


Result = Result*(C*12);


return Result;
}




function int mg_PlayerColor	(int counter, int C)
{
int Result;

if (counter == ClientPlayerNumber())	Result = CR_WHITE;

else
	{
		Switch(C)
			{
			CASE 0:	Result = CR_BRICK;	break;		CASE 1:	Result = CR_TAN;	break;		CASE 2:	Result = CR_GREEN;	break;		CASE 3:	Result = CR_BROWN;	break;		CASE 4:	Result = CR_GOLD;	break;		CASE 5:	Result = CR_RED;	break;
			CASE 6:	Result = CR_BLUE;	break;		CASE 7:	Result = CR_ORANGE;	break;		CASE 8:	Result = CR_YELLOW;	break;		CASE 9:	Result = CR_CREAM;	break;		CASE 10:Result = CR_OLIVE;	break;		CASE 11:Result = CR_PURPLE;	break;
			CASE 12:Result = CR_BRICK;	break;		CASE 13:Result = CR_TAN;	break;		CASE 14:Result = CR_GREEN;	break;		CASE 15:Result = CR_BROWN;	break;		CASE 16:Result = CR_GOLD;	break;		CASE 17:Result = CR_RED;	break;
			CASE 18:Result = CR_BLUE;	break;		CASE 19:Result = CR_ORANGE;	break;		CASE 20:Result = CR_YELLOW;	break;		CASE 21:Result = CR_CREAM;	break;		CASE 22:Result = CR_OLIVE;	break;		CASE 23:Result = CR_PURPLE;	break;
			CASE 24:Result = CR_BRICK;	break;		CASE 25:Result = CR_TAN;	break;		CASE 26:Result = CR_GREEN;	break;		CASE 27:Result = CR_BROWN;	break;		CASE 28:Result = CR_GOLD;	break;		CASE 29:Result = CR_RED;	break;
			CASE 30:Result = CR_BLUE;	break;		CASE 31:Result = CR_ORANGE;	break;												CASE 32:Result = CR_WHITE;	break;		CASE 33:Result = CR_WHITE;	break;		//AI
			}
	}


return Result;
}






function int ButtonIs (int Which)
{
int Result, BT_ACTION, BT_QUIT;

Switch(GetPort())
	{
	CASE Zandronum:		BT_ACTION = BT_ATTACK;		BT_QUIT = BT_USE;	break;
	CASE ZDaemon:		BT_ACTION = BT_JUMP;		BT_QUIT = BT_USE;	break;
	}

Switch(which)
	{
	CASE button_ACTION:	Result = BT_ACTION;		break;
	CASE button_QUIT:	Result = BT_QUIT;		break;
	}
return Result;
}


function str ButtonKeyIs (int Which)
{
str Result = "";	str BT_ACTION = "";		str BT_QUIT = "";

Switch(GetPort())
	{
	CASE Zandronum:		BT_ACTION = "+attack";		BT_QUIT = "+use";	break;
	CASE ZDaemon:		BT_ACTION = "+jump";		BT_QUIT = "+use";	break;
	}

Switch(which)
	{
	CASE button_ACTION:	Result = BT_ACTION;		break;
	CASE button_QUIT:	Result = BT_QUIT;		break;
	}
return Result;
}


function bool KeyReleased(int key)
{
    int buttons     = GetPlayerInput(ClientPlayerNumber(), INPUT_BUTTONS);
    int oldbuttons  = GetPlayerInput(ClientPlayerNumber(), INPUT_OLDBUTTONS);
    int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

    if ((newbuttons & key) == key) { return true; }
        return false;
}


















function str mg_BACKGROUND (int Divide)
{
str StringA = ""; str StringB = "";
int A, B, i;
i = 8/Divide;
while(A < (mg_HEIGHT/8)/8)
	{
	B = 0;
	while(B < (mg_WIDTH/i)/8)
		{
		StringA = StrParam(s:StringA, c:ICON_BlackScreen); //s:"A");//
		B++;
		}
	StringA = StrParam(s:StringA, 	s:"\n");
	A++;
	}
return StringA;
}








function str mg_SLIDER (int counter)
{
str StringA = "";
int i, char;
if (counter == ClientPlayerNumber())	char = ICON_WhiteScreen;
else									char = ICON_Slider;
while(i < mg_SliderLen)
	{
	StringA = StrParam(s:StringA, c:char, s:"\n"); //c:ICON_WhiteScreen
	i++;
	}

return StringA;
}

function int mg_SliderOffsetY (void)		{		int Result = mg_SliderLen*8/2;		return Result;		}









#libdefine QuizRound	3

int mg_Activity[MaxPlayers];
int mg_Direction[MaxPlayers + 1];

//PlayerNumber 32 is AI
script "MISC" (void)
{
int QuizCooldown = RNG(60, 60*3);
int QuizAnswer;
int counter, Active, BallVelX, BallVelY, HoldSpeed, BallPosX, i, Hit, EvenOdd, PerSec, A, B, C, MiscSpecial, ResetPassword;
int BallDirY = RNG(1,2)*2;
int BallDirX = (RNG(1,2)*2) - 1;
if (ServerInfo[QuizIn] < QuizRound)	ServerInfo[QuizIn]++;

BallVelX = 3;
BallVelY = 3;
/*if (GetPort() == Zandronum)
	{
	while (!GetSectorLightLevel(TIDRAM_GameSim)) delay(1);	goota remove
	}
*/
while (!ClientCount()) delay(1);
while(!GetSectorLightLevel(TIDRAM_MapReset))
	{
	if (ClientCount() > 0)
	if (GetSectorLightLevel(TIDRAM_WinCamera) == 101)
			{


			// QUIZ-----------------------------------------------------------------------------------
			if (GetPort() < GZDoom)
			if (ServerInfo[QuizIn] >= QuizRound)
			if (GetSectorLightLevel(TIDRAM_GameSim))
			if (!GetSectorLightLevel(TIDRAM_Intro))
			{
			Switch(QuizCooldown)
				{
				CASE 0:
					while (A + B + C == 0)
						{
						A = RNG(100, 	500);
						B = RNG(-10,	100);
						C = RNG(-10,	10);
						}


					QuizAnswer = A + B + C;
					QuizCooldown = -1;
					Light_ChangeToValue(TIDRAM_QuizTimer, QuizAnswerTime);
				break;

//StrParam(s:"er_account \"", s:"login     YourUsername    YourPassword\"")
				CASE -1:
				counter = 0;
				while (counter < MaxPlayers)
					{
					if (PlayerAnswer[counter] == QuizAnswer)
						{
						i = 5*GetSectorLightLevel(TIDRAM_QuizTimer);
						RegisterPlayer(counter, i, DOESNT_MATTER);
						DrawNotification(For_Everyone, StripColors(StrParam(n:counter + 1, s:" is the quiz winner! Prize is $", i:i, s:"!")),	notepose_SPECIAL,	notepara_ALIGN, ICON_Quiz,			StrParam(c:ICON_Quiz), 	"v", "ERFONT",  ON,  OFF, 0, noteHold_Short, noteFadeOut_Short);
						DrawNotification(For_Everyone, StrParam(i:QuizAnswer, s:" was a correct answer."),										notepose_TOP,		notepara_ALIGN, ICON_Quiz,			StrParam(c:ICON_None), 	"v", "ERFONT",  ON,  OFF, 0, noteHold_Short, noteFadeOut_Short);
						AmbientSound("SFXQUIZ", StandartVolume);
						QuizCooldown = -2;
						break;
						}
					counter++;
					}

				if (!PerSec)
					if (GetSectorLightLevel(TIDRAM_QuizTimer))
						{
						Light_ChangeToValue(TIDRAM_QuizTimer, GetSectorLightLevel(TIDRAM_QuizTimer) - 1);
						//DrawNotification(For_Everyone, StrParam(i:A, s:PlusMinusChar(B), s:PlusMinusChar(C), s:"    | TYPE IN CONSOLE \"", s:"ERA <YOUR ANSWER>\""),			notepose_SPECIAL,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_Quiz), 	"v", "ERFONT",  OFF,  OFF, 0, 1.0, 1.0);
						if (!MiscSpecial)
							{
							DrawNotification(For_Everyone, StrParam(i:A, s:PlusMinusChar(B), s:PlusMinusChar(C), s:" = ?"),													notepose_SPECIAL,		notepara_ALIGN, ICON_Quiz,			StrParam(c:ICON_Quiz), 	"v", "ERFONT",  ON,  OFF, 0, 0, 0);
							MiscSpecial = TRUE;
							}
						DrawNotification(For_Everyone, StrParam(i:A, s:PlusMinusChar(B), s:PlusMinusChar(C), s:" = ?"),														notepose_SPECIAL,		notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_Quiz), 	"v", "ERFONT",  OFF,  OFF, 0, 1.0, 1.0);
						Switch(GetPort())
							{
							case ZDaemon:	DrawNotification(For_Everyone, StrParam(s:"type your answer in console like this:     set ERA  <YOUR ANSWER>"),										notepose_TOP,			notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"v", "ERFONT",  OFF,  OFF, 0, 1.0, 1.0);		break;
							case Zandronum:	DrawNotification(For_Everyone, StrParam(s:"type your answer in console like this:     ERA  <YOUR ANSWER>"),											notepose_TOP,			notepara_ALIGN, ICON_NONE,			StrParam(c:ICON_None), 	"v", "ERFONT",  OFF,  OFF, 0, 1.0, 1.0);		break;
							}



						/////////////////////////////////////VBOTTOM

						}
					else	//TIME IS OUT
						{
						DrawNotification(For_Everyone, StrParam(i:QuizAnswer, s:" was a correct answer."),	notepose_SPECIAL,		notepara_ALIGN, ICON_Quiz,			StrParam(c:ICON_None), 	"v", "ERFONT",  ON,  OFF, 0, noteHold_Short, noteFadeOut_Short);
						QuizCooldown = -2;
						}

				break;

				CASE -2:
				for(i = 0; i < MaxPlayers;  i++)	PlayerAnswer[i] = "";
				Light_ChangeToValue(TIDRAM_QuizTimer, 0);
				QuizCooldown = -3;
				ServerInfo[QuizIn] = RNG(0,1);
				break;

				}




			if (!PerSec)
				if (QuizCooldown > 0)	QuizCooldown--;
			}

			//----------------------------------------------------------------------------------------
















			counter = 0;	Active = 0;		EvenOdd = 0;	RoundInfo[MinigamePlayerCount] = 0;
			while (counter <= MaxPlayers)
				{
					if (GetPort() == Zandronum)
							if (IsNetworkGame())
									SetCVar(StrParam(s:"UACC_Logged", i:counter), PlayerIsLoggedIn(counter));
							else	SetCVar(StrParam(s:"UACC_Logged", i:counter), TRUE);

							//if (ClientExist(counter))	log(s:"LOG: ", i:PlayerIsLoggedIn(counter));

				//Activity
				if (counter < MaxPlayers)		if (!mg_Activity[counter])	Light_ChangeToValue(MGRAM_PlayerActivity + counter, FALSE);

				if (mg_Activity[counter])
											{
											RoundInfo[MinigamePlayerCount]++;
											Light_ChangeToValue(MGRAM_EvenOdd + counter, EvenOdd);
											EvenOdd = IsEven(EvenOdd);
											mg_Activity[counter]--;
											Active++;
											}



					//AI

					if(counter == MaxPlayers - 1)
						if (Active == 1)	//Just one real player
							{
							RoundInfo[MinigamePlayerCount]++;
							if (!GetSectorLightLevel(MGRAM_PlayerActivity 	+ MaxPlayers))		// and AI didnt spawn yet
									Light_ChangeToValue(MGRAM_PlayerActivity 	+ MaxPlayers, TRUE);
									Light_ChangeToValue(MGRAM_EvenOdd 			+ MaxPlayers, TRUE);

							}


							else
								{
								//KILL AI, if any other's Activity is shown
								Light_ChangeToValue(MGRAM_PlayerActivity 	+ MaxPlayers, FALSE);
								}









				//SLIDERS


				if (counter == MaxPlayers)		//AI
					if (GetSectorLightLevel(MGRAM_PlayerActivity			+ MaxPlayers))
						if (!RNG(0,2))
							if (GetSectorLightLevel(MGRAM_PlayerPos			+ MaxPlayers)		!=	GetSectorLightLevel(MGRAM_BallPosY))
								{
										if (GetSectorLightLevel(MGRAM_PlayerPos			+ MaxPlayers)		<	GetSectorLightLevel(MGRAM_BallPosY))
											mg_Direction[counter] = ToDOWN;

								else	if (GetSectorLightLevel(MGRAM_PlayerPos			+ MaxPlayers)		>	GetSectorLightLevel(MGRAM_BallPosY))
											mg_Direction[counter] = ToUP;


								}



				if (GetSectorLightLevel(MGRAM_PlayerActivity + counter))
				Switch(mg_Direction[counter])
					{
					CASE ToUP:
					if (GetSectorLightLevel(MGRAM_PlayerPos + counter) - mg_SliderRadius 	> 	0)
							{
							if (GetSectorLightLevel(MGRAM_PlayerPos + counter)  - mg_SliderRadius - mg_SliderSpeed	< 0)			Light_ChangeToValue(MGRAM_PlayerPos + counter, 0 + mg_SliderRadius);
							else																									Light_ChangeToValue(MGRAM_PlayerPos + counter, GetSectorLightLevel(MGRAM_PlayerPos + counter)/* - mg_SliderRadius */- mg_SliderSpeed);
							}
					break;

					CASE ToDOWN:
					if (GetSectorLightLevel(MGRAM_PlayerPos + counter) + mg_SliderRadius	< 	mg_HEIGHT )
							{
							if (GetSectorLightLevel(MGRAM_PlayerPos + counter) 	+ mg_SliderRadius + mg_SliderSpeed	> mg_HEIGHT)	Light_ChangeToValue(MGRAM_PlayerPos + counter, mg_HEIGHT - mg_SliderRadius);
							else																									Light_ChangeToValue(MGRAM_PlayerPos + counter, GetSectorLightLevel(MGRAM_PlayerPos + counter)/* + mg_SliderRadius */+ mg_SliderSpeed);
							}
					break;
					}

				counter++;
				}




				// BALL actions
					BallPosX =  GetSectorLightLevel(MGRAM_BallPosX1) + GetSectorLightLevel(MGRAM_BallPosX2);
					//Y
					Switch(BallDirY)
						{
						CASE ToUP:
										if (GetSectorLightLevel(MGRAM_BallPosY) - BallVelY - mg_BallRadius > 0)					Light_ChangeToValue(MGRAM_BallPosY,  GetSectorLightLevel(MGRAM_BallPosY) - BallVelY);
										else																					Light_ChangeToValue(MGRAM_BallPosY,  0);

						break;
						CASE ToDOWN:
										if (GetSectorLightLevel(MGRAM_BallPosY) + BallVelY + mg_BallRadius 	< mg_HEIGHT - 1)	Light_ChangeToValue(MGRAM_BallPosY,  GetSectorLightLevel(MGRAM_BallPosY) + BallVelY);
										else																					Light_ChangeToValue(MGRAM_BallPosY,  mg_HEIGHT - 1);


						break;
						}

					if 	((GetSectorLightLevel(MGRAM_BallPosY) == mg_HEIGHT - 1) | (GetSectorLightLevel(MGRAM_BallPosY) == 0))
							{
							BallDirY	= InvertDirection(BallDirY);
							i = 0;
							while(i < MaxPlayers)
								{
								if (GetSectorLightLevel(MGRAM_PlayerActivity + i))	ClientScript (i, "SFX", GetPort(), SFX_MinigameHit, mg_Activity[i]*8);
								i++;
								}
							}


					Switch(BallDirX)
						{
						CASE ToLEFT:
										if (BallPosX - mg_BallRadius - BallVelX  	> 0)										BallPosX = BallPosX - BallVelX;
										else																					BallPosX = 0;



						break;
						CASE ToRIGHT:
										if (BallPosX + mg_BallRadius + BallVelX 	< mg_WIDTH)									BallPosX = BallPosX + BallVelX;
										else																					BallPosX = mg_WIDTH;

						break;
						}


						mg_SplitBallPosX(BallPosX);
						// HIT
						if ((BallPosX <= 0) | (BallPosX >= mg_WIDTH))
							{
							counter = 0;	Hit = FALSE;
							while (counter <= MaxPlayers)
								{

								if ((GetSectorLightLevel(MGRAM_BallPosY)	 >= 	(GetSectorLightLevel(MGRAM_PlayerPos + counter)) - mg_SliderRadius - mg_BallRadius + 1) 			&& 		(GetSectorLightLevel(MGRAM_BallPosY)	<= 	(GetSectorLightLevel(MGRAM_PlayerPos + counter)) + mg_SliderRadius + mg_BallRadius - 1))

									if (((!GetSectorLightLevel(MGRAM_EvenOdd + counter)) && (BallPosX > mg_WIDTH/2))  |  ((GetSectorLightLevel(MGRAM_EvenOdd + counter)) && (BallPosX < mg_WIDTH/2)))
										{
										if (GetSectorLightLevel(MGRAM_PlayerActivity + counter)) Hit = TRUE;
										Light_ChangeToValue(MGRAM_PlayerPTS + counter,  GetSectorLightLevel(MGRAM_PlayerPTS + counter) + 1);

										if (GetSectorLightLevel(MGRAM_PlayerPTS + counter) >= 255) 	ReduceMinigameScores();
										}


								counter++;
								}




							Switch (Hit)
								{
								CASE FALSE:
										BallPosX = mg_WIDTH/2;	mg_SplitBallPosX(BallPosX);
										BallDirY = RNG(1,2)*2;
										BallVelX = 3;
										BallVelY = 3;

										counter = 0;
										while(counter < MaxPlayers)
											{
											if (GetSectorLightLevel(MGRAM_PlayerActivity + counter))	ClientScript (counter, "SFX", GetPort(), SFX_MinigameFail, mg_Activity[counter]*8);
											counter++;
											}

								break;

								CASE TRUE:

										counter = 0;
										while(counter < MaxPlayers)
											{
											if (GetSectorLightLevel(MGRAM_PlayerActivity + counter))	ClientScript (counter, "SFX", GetPort(), SFX_MinigameHit, mg_Activity[counter]*8);
											counter++;
											}


										if (BallVelX < 10)
											//if (!RNG(0,1))
													BallVelX += RNG(1,2);

										BallVelY = RNG(1,4);

								break;
								}

							BallDirX	= InvertDirection(BallDirX);
							}



			}
//if ((GetSectorLightLevel(MGRAM_BallPosY)	 >= 	(GetSectorLightLevel(MGRAM_PlayerPos)) - mg_SliderRadius - mg_BallRadius + 1) 			&& 		(GetSectorLightLevel(MGRAM_BallPosY)	<= 	(GetSectorLightLevel(MGRAM_PlayerPos)) + mg_SliderRadius + mg_BallRadius - 1))
//{SetHudSize(0, 0, 0);
//HudMessageBold(s:"TRUE";						HUDMSG_PLAIN, HUDid_Debug,	CR_PURPLE, 	0.5, 0.5,  	0.03);}
//log(s:"PLAYERPOS ", i:GetSectorLightLevel(MGRAM_PlayerPos), s:"    BALLPOS ", i:GetSectorLightLevel(MGRAM_BallPosY), s:"    BALLX ", i:BallPosX);
	if (!PerSec)
		{
		//PASSWORD

		Switch(ResetPassword)
		{
		CASE 0:	Light_ChangeToValue(TIDRAM_PasswordB, RNG(1, 255));								break;
		CASE 1:	Light_ChangeToValue(TIDRAM_PasswordA, GetSectorLightLevel(TIDRAM_PasswordB));	break;
		}
		ResetPassword = IsEven(ResetPassword);


		//if (!ServerInfo[66])	Light_ChangeToValue(10533,	random(0, 254));
								Light_ChangeToValue(10534,	random(0, 255));

		}


	if (!Persec) 	PerSec = Sec;
	else 			PerSec--;
	delay(1);
	}
}


function bool PasswordMatch (int Password)
{
bool Result;
if ((Password == GetSectorLightLevel(TIDRAM_PasswordA)) ||	(Password == GetSectorLightLevel(TIDRAM_PasswordB)))	Result = TRUE;
return Result;
}







function void mg_SplitBallPosX (int BallPosX)
{
if(BallPosX > 255)
	{
	Light_ChangeToValue(MGRAM_BallPosX1,  255);
	Light_ChangeToValue(MGRAM_BallPosX2,  BallPosX - 255);
	}
else
	{
	Light_ChangeToValue(MGRAM_BallPosX1,  BallPosX);
	Light_ChangeToValue(MGRAM_BallPosX2,  0);
	}
}





Script "mg_ACTION" (int Password, int PlayerNum, int arg2) NET
{
if (!PasswordMatch(Password))	Terminate;
if (RoundInfo[MinigamePlayerCount] < MaxMinigamePlayers)
if (!mg_Direction[PlayerNum])					mg_Direction[PlayerNum] = RNG(1,2)*2;
else											mg_Direction[PlayerNum] = InvertDirection(mg_Direction[PlayerNum]);

mg_Activity[PlayerNum] = mg_MaxActivity;
Light_ChangeToValue(MGRAM_PlayerActivity + PlayerNum, TRUE);
}




function void MinigameWinnerIs (void)
{
str Result = "";	bool Draw;
int counter, TopScore, TopPlayer;
while(counter <= MaxPlayers)
	{
	if (GetSectorLightLevel(MGRAM_PlayerPTS + counter) == TopScore) 		Draw = TRUE;
	if (GetSectorLightLevel(MGRAM_PlayerPTS + counter)  > TopScore)		{	Draw = FALSE;	TopPlayer = counter;	TopScore = GetSectorLightLevel(MGRAM_PlayerPTS + counter);	}
	counter++;
	}


if (TopScore)
	if (!Draw)
		if (ClientExist(TopPlayer))
			{
			GAMEINFO[MinigameWinPlayaPTS] = TopScore;
			GAMEINFO[MinigameWinPlayaNUM] = TopPlayer;
			/*Result = StrParam(s:"MINIGAME WINNER IS ", n:TopPlayer + 1);
			Result = StripColors(Result);
			Result = StrToUpper(Result);*/
			}
//return Result;
}

/*
function void MinigameWinnerIs (void)
{
str Result = "";	bool Draw;
int counter, TopScore, TopPlayer;
while(counter <= MaxPlayers)
	{
	if (GetSectorLightLevel(MGRAM_PlayerPTS + counter) == TopScore) 		Draw = TRUE;
	if (GetSectorLightLevel(MGRAM_PlayerPTS + counter)  > TopScore)		{	Draw = FALSE;	TopPlayer = counter;	TopScore = GetSectorLightLevel(MGRAM_PlayerPTS + counter);	}
	counter++;
	}


if (TopScore)
	if (!Draw)
		if (ClientExist(TopPlayer))
			{
			Result = StrParam(s:"MINIGAME WINNER IS ", n:TopPlayer + 1);
			Result = StripColors(Result);
			Result = StrToUpper(Result);
			}
return Result;
}
*/

function void ReduceMinigameScores (void)
{
int counter;	int by = 25;
while(counter <= MaxPlayers)
	{
	if (GetSectorLightLevel(MGRAM_PlayerPTS + counter) - by >= 0 )
			Light_ChangeToValue(MGRAM_PlayerPTS + counter, GetSectorLightLevel(MGRAM_PlayerPTS + counter) - by);
	else	Light_ChangeToValue(MGRAM_PlayerPTS + counter, 0);

	counter++;
	}
}
















script "Debug_SERVER" (void)
{
int counter, i;
str StringA = "", StringB = "";

while(TRUE)
Switch(GetCvar("ER_DebugMode"))
	{
	CASE 0: delay(1); break;

	CASE 1: //GIVE WEAPONS

		//if (!IsNetworkGame())
			{
			//SpawnSpot("Backpack",	ACTORTID_Debug, 0, 0);
			//SpawnSpot("Backpack",	ACTORTID_Debug, 0, 0);
			//SpawnSpot("Backpack",	ACTORTID_Debug, 0, 0);
			//SpawnSpot("Backpack",	ACTORTID_Debug, 0, 0);
			//SpawnSpot("Megasphere",	ACTORTID_Debug, 0, 0);
			//SpawnSpot("Chainsaw",	ACTORTID_Debug, 0, 0);
			}

	delay(SEC*10);
	break;




	CASE 2: //Money_Bug


		StringB = "";	counter = 0;
		while(counter <= ServerInfo[RegisteredPlayers])
			{
			i = 0;	StringA = "";
			while (i < 32)
				{
				StringA = StrParam(s:StringA, c:MoneyNAME[counter * 32 + i]);
				i++;
				}

			StringB = StrParam(s:StringB, i:counter, s:".", s:StringA, s:"|  $", i:MoneyInfo[counter], s:"    |", s:StripColors(FlagName(FlagInfo[counter])), s:"\n");
			//log(s:StringA);
			counter++;

			}
	//log(i:ServerInfo[MoneyNameCount]);
	SetHUDSize(HUDX_VERYSMALL, HUDY_VERYSMALL, FALSE);			SetFont("ERFONT");
	//HudMessageBold(s:"DATABASE: '"s:GetCvarString("databasefile"), s:"'\n\n\n", s:StringB;						HUDMSG_PLAIN, HUDid_Debug,	CR_PURPLE, 	int2fix(HUDX_MEDIUM/2), 		int2fix(HUDY_MEDIUM/2),  		int2fix(1));
	HudMessageBold(s:"SEASON ", i:ServerInfo[SEASON], s:";    STAGE ", i:ServerInfo[STAGE], s:";\n\n\n", s:StringB;						HUDMSG_PLAIN, HUDid_DebugSERVER,	CR_PURPLE, 	int2fix(HUDX_VERYSMALL/2), 		int2fix(HUDY_VERYSMALL/2),  		int2fix(1));

	delay(SEC/2);
	break;

/////////////////////////////////////////////
	CASE 3: //

	SetHUDSize(0, 0, 0);
	SetFont("ERFONT");
			HudMessageBold(
			s:BlockAt[0][0], s:"  ", s:BlockAt[0][1], s:"  ", s:BlockAt[0][2], s:"  ", s:BlockAt[0][3], s:"  ", s:BlockAt[0][4], s:"\n\n",
			s:BlockAt[1][0], s:"  ", s:BlockAt[1][1], s:"  ", s:BlockAt[1][2], s:"  ", s:BlockAt[1][3], s:"  ", s:BlockAt[1][4], s:"\n\n",
			s:BlockAt[2][0], s:"  ", s:BlockAt[2][1], s:"  ", s:BlockAt[2][2], s:"  ", s:BlockAt[2][3], s:"  ", s:BlockAt[2][4], s:"\n\n",
			s:BlockAt[3][0], s:"  ", s:BlockAt[3][1], s:"  ", s:BlockAt[3][2], s:"  ", s:BlockAt[3][3], s:"  ", s:BlockAt[3][4], s:"\n\n",
			s:BlockAt[4][0], s:"  ", s:BlockAt[4][1], s:"  ", s:BlockAt[4][2], s:"  ", s:BlockAt[4][3], s:"  ", s:BlockAt[4][4], s:"\n\n\n\n",
			i:AdventureInfo[0][adv_TYPE], s:"  ", i:AdventureInfo[1][adv_TYPE], s:"  ", i:AdventureInfo[2][adv_TYPE], s:"  ", i:AdventureInfo[3][adv_TYPE], s:"  ", i:AdventureInfo[4][adv_TYPE], s:"  ", i:AdventureInfo[5][adv_TYPE], s:"\n\n",
			s:"\cjMOOD  ", 	i:GetSectorLightLevel(TIDRAM_Mood),		i:GetSectorLightLevel(TIDRAM_Location), i:RoundInfo[CurrentRound], s:"\n\n",
			s:"                           \cjROUND #", 	i:RoundInfo[CurrentRound], s:"\n\n",
			s:"\n\n",
			s:"\n",
			s:"\n",
			s:"\cgDIFFICULTY  ",	i: AdventureInfo[RoundInfo[CUrrentRound]][adv_DIFFICULTY], s:"\n",
			s:"\cgROUNDS WEAPON IS ", s:ActorString(AdventureInfo[RoundInfo[CurrentRound]] [adv_WEAPON], as_TEXT), s:"\n",
			s:"\n"
			;HUDMSG_PLAIN, HUDid_DebugSERVER, CR_UNTRANSLATED, 0.2, 0.7, 2.0);

	if(!IsNetworkGame())
		{
			HudMessage(
			s:"\n\n",
			s:"\n\n",
			s:"\n\n",
			s:"\n\n",
			s:"\n\n\n\n",
			s:"\n\n",
			s:"\n\n",
			s:"\cjPLAYER's CP  ", 	i:PlayerCheckpoint[PlayerNumber()],		s:"\n\n",
			s:"\n\n",
			s:"\n",
			s:"\n",
			s:"\n",
			s:"\n",
			s:"\n"
			;HUDMSG_PLAIN, 0, CR_UNTRANSLATED, 0.2, 0.7, 1.5);
		}

	delay(SEC);
	break;
	}
}





function void ClientAdd (void)
{

int counter;

while(counter < MaxAddCharsY)
	{
	counter++;
	SetCvarString(StrParam(s:AdvertisementCvar, s:"C", s:LeadingZeros(counter, 2)), Advertisement[GetSectorLightLevel(TIDRAM_AdvertisementSlot)][counter]);
	}
	SetCvar(StrParam(s:AdvertisementCvar, s:"CC"), AdvertisementMisc[GetSectorLightLevel(TIDRAM_AdvertisementSlot)][adv_COLOR]);
	SetCvar(StrParam(s:AdvertisementCvar, s:"CCC"), AdvertisementMisc[GetSectorLightLevel(TIDRAM_AdvertisementSlot)][adv_COST] + AdvertisementCost);
}









Script "PlaceAdvertisement" (int Password, int SlotAndColor) NET
{
//if (!PasswordMatch(Password))	Terminate;
int counter, i;
int Slot = SlotAndColor/100;
int Color = SlotAndColor - Slot*100;
str StringA = "";

//COLOR
AdvertisementMisc[Slot][adv_COLOR] = Color;
//COST
AdvertisementMisc[Slot][adv_COST] += AdvertisementCost;
if (AdvertisementMisc[Slot][adv_COST] > MaxMoney - AdvertisementCost)		AdvertisementMisc[Slot][adv_COST] = MaxMoney - AdvertisementCost;
//SLOT
while(counter < MaxAddCharsY)
	{
	counter++; i = 0; StringA = "";
	while(i < MaxAddCharsX)
		{
		i++;
		StringA = StrParam(s:StringA, c:GetChar(GetCvarString(StrParam(s:AdvertisementCvar, s:LeadingZeros(counter, 2))), i));
		}
	Advertisement[Slot][counter] = StringA;//DefaultAdvertisement(Slot, counter);GetCvarString(s:AdvertisementCvar, i:counter);
	}
}






function str DefaultAdvertisementColor (int Slot)
{
int Color;
Switch(Slot)
	{
	CASE 0: color = CR_WHITE;	break;
	CASE 1: color = CR_YELLOW;	break;
	CASE 2: color = CR_RED;		break;
	CASE 3: color = CR_CYAN;	break;
	CASE 4: color = CR_PURPLE;	break;
	}
return Color;
}

function str DefaultAdvertisement (int Slot, int posY)
{
str Add = "";
Switch(Slot)
	{
	CASE 0:
	Switch(posY)
		{
		CASE  1: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  2: Add = "~~%%%%%%%~~%%%%%~%%~%%%%%%~%%~~~%%%~%%%%~~%%%%~%%%%%%%%~~%%%%~%%%%%%%%";	break;
		CASE  3: Add = "~~%%%%%%~~%%%%%%~%%~%%%%%%~%%%~~%%%~%%%%%~~%%%~%%%%%%%~~%%%%%~%%%%%%%%";	break;
		CASE  4: Add = "~~%%%%%%~%%%%%%%~%%~%%%%%%~%%%%~%%%~~%%%%%~~%%~%%%%%%~~%%%%%%~%%%%%%%~";	break;
		CASE  5: Add = "~~~~~~%%~~~~~~~~~%%~%%%~~~~%%%%%%%%~~~%%%%%~%%~%%%~~~~%%%~~~~~%%%~~~~~";	break;
		CASE  6: Add = "~%%%%%%%~%%%%%%%~%%~%%%%%%~%%%%%%%%~%~~%%%%~%%~%%%%%%~%%%%%%%~%%%%%%%~";	break;
		CASE  7: Add = "~%%%%%%%~%%%%%%%~%%~%%%%%%~%%%%%%%%~%%~~%%%~%%~%%%%%%~%%%%%%%~%%%%%%%~";	break;
		CASE  8: Add = "~%%%%%%%~%%%~~~~~%%~%%%~~~~%%%%%%%%~%%%~%%%~%%~%%%~~~~~~~~%%%~~~~%%%~~";	break;
		CASE  9: Add = "%%%~%%%%~~%%%%%%~%%~~%%%%%~%%%~%%%%~%%%%%%%~%%~~%%%%%~%%%%%%~~%%%%%%~~";	break;
		CASE 10: Add = "%%%~~%%%%~~%%%%%~%%%~~%%%%~%%%~~%%%~%%%%%%%~%%%~~%%%%~%%%%%~~%%%%%%~~~";	break;
		CASE 11: Add = "%%%~~~%%%%~~%%%%~%%%%~%%%%~%%%~~~%%~%%%%%%%~%%%%~~%%%~%%%%%~%%%%%%%~~~";	break;
		CASE 12: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 13: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 14: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 15: Add = "~~~~~~~~~~~~~~~~~~~~place~your~advertisement~here!~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 16: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 17: Add = "~~~~~~~~~~~~use~<PERCENTAGE>~symbol~to~draw~a~square~char.~~~~~~~~~~~~";	break;
		CASE 18: Add = "~~~~~~~~~~~~~~~~~~~use~<TILDE>~symbol~for~space.~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 19: Add = "~~~~~~~~~~~~Advert~resolution~must be~exactly~70x20~chars.~~~~~~~~~~~~";	break;
		CASE 20: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		}
	break;

	CASE 1:
	Switch(posY)
		{
		CASE  1: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  2: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  3: Add = "~~~~~~~~~~~~~~~~~~~https://i.imgur.com/ivXEvpK.png~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  4: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  5: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  6: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  7: Add = "~~~~~~~~~~~~~~~~~~~~~%~%~%%%%%~~%%%%%%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  8: Add = "~~~~~~~~~~~~~~~~~~~~~%%%%%%%~~~%%%%~%%%%~%%~%%%~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  9: Add = "~~~~~~~~~~~~~~~~~~~~~%%%%%%%~~~~~~~~~~%%~%%~%%%%~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 10: Add = "~~~~~~~~~~~~~~~~~~~~~%%%%%%%%~~~~~~%~%%%~%%~%%%%~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 11: Add = "~~~~~~~~~~~~~~~~~~~~~%~~%%%%~~~~%~~%%%%%~%%~~%~%~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 12: Add = "~~~~~~~~~~~~~~~~~~~~~%%%~%%%~~%~~~%%%%%%~%%~~%~%~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 13: Add = "%%%%%%%%%%%%%%%%%%%~~%~~~~%%%%%%%%%%%%%%%%%~~%~%~~~%%%%%%%%%%%%%%%%%%%";	break;
		CASE 14: Add = "~~~~~~~~~~~~~~~~~~~~~%~~~~%%%%%%%%%%%%%~%%~~~~~%~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 15: Add = "%%%%%%%%%%%%%%%%%%%~~%~~~%%%%%%%%%%%%%%~%%~~%~~%~~~%%%%%%%%%%%%%%%%%%%";	break;
		CASE 16: Add = "%%%%%%%%%%%%%%%%%%%~~%~~%%%%%%%%%%%%%%%~%%~~%~%%%~~%%%%%%%%%%%%%%%%%%%";	break;
		CASE 17: Add = "~~~~~~~~~~~~~~~~~~~~~%~~%%%%%%%%%%%%%%%~%%~%%~%~%~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 18: Add = "%%%%%%%%%%%%%%%%%%%~~%%~%~%%%%%%%%%%%%%~%%~%~~%~%~~%%%%%%%%%%%%%%%%%%%";	break;
		CASE 19: Add = "%%%%%%%%%%%%%%%%%%%~~%%~%%~~%%%%%%%%%%%~%%~~~~%~%~~%%%%%%%%%%%%%%%%%%%";	break;
		CASE 20: Add = "%%%%%%%%%%%%%%%%%%%~~%%~%%%%%%%%%%%%%%%~~%~%~%%~%~~%%%%%%%%%%%%%%%%%%%";	break;
		}
	break;

	CASE 2:
	Switch(posY)
		{
		CASE  1: Add = "A~great~enhancement~and~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%~~~~";	break;
		CASE  2: Add = "addition~to~the~original~~~~~~~~~~%~~~%~~%~~~~~~~~%%%~~~~~~~~~~~~%~~~~";	break;
		CASE  3: Add = "survival~mystery~mod!~~~~~~~~~~~~~%~%~%~~%~~~~~~~~%~~%~~~~~~~~~~~%~~%~";	break;
		CASE  4: Add = "It~contains~new modes~~~~~~~~~~~~~%~%~%~~%%%~%%%~~%~~~%~%~%~%%~~~%~%%%";	break;
		CASE  5: Add = "and~features,~such~as:~~~~~~~~~~~~%%%%%~~%~%~%~%~~%~~~%~%~%~%~%~~%~~%~";	break;
		CASE  6: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%~~%~%~%%%~~%~~%~~%%%~%~%~~%~~%%";	break;
		CASE  7: Add = "*~BONUS~ABILITIES~to~diverse~~~~~~~%~%~~~~~~~~~~~~%%%~~~~~~~~~~~~%~~~~";	break;
		CASE  8: Add = "~~and~advance~WDI~gameplay!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  9: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 10: Add = "*~THE~MUTILATOR:~a~refreshing~~~~~~~~~~~~~~~~~~~~~~~~~~%~~%%~~~~~%~~~~";	break;
		CASE 11: Add = "~~survival~horror~mode!~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~~~%%~%%%~~~~%~~%~";	break;
		CASE 12: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%~%%%~%%%%~~~%~%%~";	break;
		CASE 13: Add = "*~MINIGAMES~for~spectators~~~~~~~~~~~~~~~~~~~~~~~%%%%%%%%~%~%%~~~%%%~~";	break;
		CASE 14: Add = "~~to~not~be~bored~while~waiting!~~~~~~~~~~~~~~~~~%%%%%%%%~%~%%~~%%%~~~";	break;
		CASE 15: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~%%~%%~%%%~~%%%%~~~";	break;
		CASE 16: Add = "*~GAMEPLAY~VOTES~that~allows~you~~~~~~~~~~~~~~~~~%%~~~~%%~%%%~%%~%~~~~";	break;
		CASE 17: Add = "~~to~change~the~game~as~you~like!~~~~~~~~~~~~~~~~%~~~~~~%~%~%~%~~%~~~~";	break;
		CASE 18: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 19: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 20: Add = "forum.zdoom.org/viewtopic.php?f=19&t=66620~~~~~~~discord.gg/G7hkQhYHvx";	break;
		}
	break;

	CASE 3:
	Switch(posY)
		{
		CASE  1: Add = "~~~%%%%%%~%%%%%~%%%%%%~%%%%~%%%%%~~~~~~~~~If~you~enjoy~RELENDLESS,~you";	break;
		CASE  2: Add = "~~~%%%%%%~%%%%%~%%%%%%~%%%%~%%%%%~~~~~~~~~could~also~try~this~hardcore";	break;
		CASE  3: Add = "~~~~~%%%~~~~~~~~%~~~%~~~~~~~~~%%%~~~~~~~~~~~one-level~miniwad~as~well!";	break;
		CASE  4: Add = "~~~~%%%~~%%%%%~%%%%%%~%%%%~%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  5: Add = "~~~%%%~~~%%~~~~%%~~%%~%%~~~%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  6: Add = "~~~%%%%%~%%%%%~%%%%%~~%%%%~%%~%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE  7: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~%%~~~~~~~~~A~long~and~dangerous~survival";	break;
		CASE  8: Add = "~~~%%%%%%~~%%%%~%%~~%%~%%~%%%~~%%~~~~~~~adventure~in~the~surreal~world";	break;
		CASE  9: Add = "~~%%%~%%~~%%%%~~~~~%%%%%%~%%~~~%%~~~~~~full~of~monsters,~environmental";	break;
		CASE 10: Add = "~~%%%%%~~%%%%%~%%%~%%%%%%~%%~~~~~~~~~~obstacles,~nasty~bosses,~secrets";	break;
		CASE 11: Add = "~~%%~~~~%%%~%%~%%%~%%%%%~~%%~~~~~~~~~~~~and~various~endings~to~unlock!";	break;
		CASE 12: Add = "~~%%~~~%%%~~%%~%%%~%%~%%~%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 13: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~%%~~~~~~~~~~As~a~bonus~it~also~contains~a~map";	break;
		CASE 14: Add = "~~~~[LA]~OUTER~WORLDS~~~~%%~~~~~~from CONGESTION192~community~project!";	break;
		CASE 15: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 16: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 17: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 18: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 19: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";	break;
		CASE 20: Add = "~~~~~~~~~~~~~~forum.zdoom.org/viewtopic.php?f=42&t=69193~~~~~~~~~~~~~~";	break;
		}
	break;

	CASE 4:
	Switch(posY)
		{
		CASE  1: Add = "STRANGE~WORLD~CONSTRUCTION~SITE~~~~~~~~~~~DOOMCENTER~2:ANYWHERE~CITY~";		break;
		CASE  2: Add = "~NIGHTSHIFT~SECURITY~SIMULATOR~~~~~~~~~~~~grand theft auto II remake~";		break;
		CASE  3: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
		CASE  4: Add = "~~~~~~%%%%%%~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~%%%%%~~~~~~~~";		break;
		CASE  5: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%%~%%~%%~~~~~~~~";		break;
		CASE  6: Add = "~~~~%%%%~~%%%%~%%%%~~~~%%%%~~~~~~~~~~~~~~~~~~~~~~%%%%%%~%%~~~~~~~~~~~";		break;
		CASE  7: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~~%%~%%~%%~~~~~~~~";		break;
		CASE  8: Add = "~~%%%%~~~~~~~~~%%%%~~~~%%%%~~~~~~~~~~~~~~~~~~~~~~%%%%%%~%%%%%~~~~~~~~";		break;
		CASE  9: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%%~~~~~~~~~~~~~~";		break;
		CASE 10: Add = "~~%%%%~~~~~~~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%~~~~~~~~";		break;
		CASE 11: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%%%%~%%%%%%~~~~~~~~";		break;
		CASE 12: Add = "~~%%%%~~~~~~~~~%%%%~~~~%%%%~~~~~~~~~~~~~~~~~~~~~~%%~%%~%%~~%%~~~~~~~~";		break;
		CASE 13: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~%%~~~~~~~~~~~~";		break;
		CASE 14: Add = "~~~~%%%%~~%%%%~%%%%~~~~%%%%~~~~~~~~~~~~~~~~~~~~~~%%%%%~%%~~%%~~~~~~~~";		break;
		CASE 15: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%%~%%~%%%%%%~~~~~~~~";		break;
		CASE 16: Add = "~~~~~~%%%%%%~~~%%%%%%%%%%~~~~~~~~~~~~~~~~~~~~~~~~%%%%%~%%%%%%~~~~~~~~";		break;
		CASE 17: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
		CASE 18: Add = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";		break;
		CASE 19: Add = "TECHDEMO~at~forum.zdoom.org/~~~~~~~~~~~~~TECHDEMO~at~forum.zdoom.org/";		break;
		CASE 20: Add = "viewtopic.php?f=19&t=53202~~~~~~~~~~~~~~~~~viewtopic.php?f=19&t=37466";		break;
		}
	break;
	}

return Add;
}



Script "EnemyLocator" (int Password, int PlayaNum) CLIENTSIDE
{
Switch(GetPort())
{
case ZDaemon:		Client_NamedExecute(PlayaNum, "EnemyLocatorEXE");		break;
case Zandronum:		ACS_NamedExecute("EnemyLocatorEXE", 0);					break;
}
}



//ENEMY MARKER	based on script by Kaminsky
Script "EnemyLocatorEXE" (void) CLIENTSIDE
{
//if (!PasswordMatch(Password))	Terminate;
int Time, A, B, C, D, E, counter;
Time = Sec*3;
while(Time > 0)
	{
		counter = ACTORTID_Enemy;
		while(counter < ACTORTID_Enemy + MaxEnemy)
			{
			if (ClassifyActor(counter) & ACTOR_ALIVE)
					{
						A = GetActorX(counter) - GetActorX(PLAYER_TID + ClientPlayerNumber());
						B = GetActorY(counter) - GetActorY(PLAYER_TID + ClientPlayerNumber());
						C = GetActorZ(counter) + (GetActorProperty(counter, APROP_HEIGHT) >> 1) - (GetActorZ(PLAYER_TID + ClientPlayerNumber()) + GetActorViewHeight(PLAYER_TID + ClientPlayerNumber()));

						D =  FixedMul(A, cos(GetActorAngle(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(B, sin(GetActorAngle(PLAYER_TID + ClientPlayerNumber())));
						E = -FixedMul(A, sin(GetActorAngle(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(B, cos(GetActorAngle(PLAYER_TID + ClientPlayerNumber())));

						A = FixedMul(D, cos(GetActorPitch(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(C, sin(GetActorPitch(PLAYER_TID + ClientPlayerNumber())));

							if(A > 0)
							{
								//C = -FixedMul(D, sin(GetActorPitch(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(C, cos(GetActorPitch(PLAYER_TID + ClientPlayerNumber())));

								SetFont("ERICON");
								SetHudSize((HUDX_BIG >> 1) << 1, (HUDY_BIG >> 1) << 1, true);

								HudMessageBold(c:ICON_EnemyMarker; HUDMSG_FADEOUT, HUDid_EnemyMarker + counter, CR_ORANGE, (((HUDX_BIG >> 1) << 16) - ((HUDX_BIG >> 1) * FixedDiv(E, A))) & 0xFFFF0000, int2fix(192), ClientMsgDelay, 0.25);
							}
					}

			counter++;
			}




	Time--;
	DrawNotification(For_ActivatorOnly, StrParam(f:tic2sec(Time)),	notepose_TOP, notepara_ALIGN, ICON_None, StrParam(c:ICON_Clock), "i", "ERFONT", OFF, ON, noteFadeIn_None, ClientMsgDelay, 0.25);
	delay(1);
	}


}




Script "SCRIPT_RegisterPlayer" (int Password, int arg2, int arg3) NET
{
if (!PasswordMatch(Password))	Terminate;
RegisterPlayer(PlayerNumber(), arg2, arg3);
}












function int GetEnemyHealth (int Enemy)
{
int Result;
Switch(Enemy)
	{
	CASE id_Zombieman:			Result = 20;		break;
	CASE id_Imp:				Result = 60;		break;
	CASE id_ShotgunGuy:			Result = 30;		break;
	CASE id_Demon:
	CASE id_Spectre:			Result = 150;		break;
	CASE id_LostSoul:			Result = 100;		break;
	CASE id_HeavyWeaponDude:	Result = 70;		break;
	CASE id_Cacodemon:			Result = 400;		break;
	CASE id_HellKnight:			Result = 500;		break;
	CASE id_BaronOfHell:		Result = 1000;		break;
	CASE id_Mancubus:			Result = 600;		break;
	CASE id_Arachnotron:		Result = 500;		break;
	CASE id_Archvile:			Result = 700*2;		break;
	CASE id_SpiderMastermind:	Result = 3000;		break;
	CASE id_PainElemental:		Result = 400;		break;
	CASE id_Railgunner:			Result = 100;		break;
	CASE id_Cyberdemon:			Result = 4000;		break;
	}

return Result;

}





#libdefine gwi_DAMAGE					0
#libdefine gwi_AMMOTAKEN					1

function int GetWeaponInfo (int Weapon, int Which)
{
int Result, AverageDamage, AmmoTaken;
Switch(Weapon)
	{
	CASE id_Pistol:				AverageDamage = 10;		AmmoTaken = 1;		break;
	CASE id_Shotgun:			AverageDamage = 70;		AmmoTaken = 1;		break;
	CASE id_Chaingun:			AverageDamage = 10;		AmmoTaken = 1;		break;
	CASE id_SuperShotgun:		AverageDamage = 170;	AmmoTaken = 2;		break;
	CASE id_Railgun:			AverageDamage = 100;	AmmoTaken = 10;		break;
	CASE id_RocketLauncher:		AverageDamage = 200;	AmmoTaken = 1;		break;
	CASE id_PlasmaRifle:		AverageDamage = 25;		AmmoTaken = 1;		break;
	CASE id_BFG9000:			AverageDamage = 400;	AmmoTaken = 40;		break;
	}

Switch(which)
	{
	CASE gwi_DAMAGE: 		Result = AverageDamage;		break;
	CASE gwi_AMMOTAKEN: 	Result = AmmoTaken;			break;
	}

return Result;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
/*


ADD 	rng(15: Obstacle,		40:	Amount,			45:	Upgrade)



ADD Obstacle:			MaxObstacles ~= 4 perBlock;		RNG(+12, +13);

ADD Amount:				+5;

ADD Upgrade:			+ RNG (50: +1;		35: +5;		15: +10);



int Container

function




TrialStock = FixedMul(int2fix(AdventureInfo[RoundInfo[CUrrentRound]][adv_DIFFICULTY]), 	TrialStockMultiply(ContainerType))	>> 16;


int function TrialStockMultiply	(int ContainerType)
{
int Result;
Switch(ContainerType)
	{
	Case OneBlock:		Result = 1.0;		break;
	Case TwoBlocks:		Result = 1.875;		break;
	Case ThreeBlocks:	Result = 2.75;		break;
	}
return Result;
}

Winners, that are marked 'X' were not logged in their account upon
their victory and thus their win won't be calculated when it's
time to decide a season winner. Please, log in next time!
*/


Script "ZDA_ShowPlayground" (void) NET
{
ChangeCamera(ACTORTID_PlaygroundCamera - RNG(0, 3), 0, 1);
}


function str AlphaWeapon (int Type, int What)
{
str Ammo, WeakWeap, HardWeap, ExtraWeap = "";
str Result = "";
Switch(Type)
	{
	case 0:	Ammo = "Clip";			WeakWeap = "Pistol";			HardWeap = "Chaingun";			ExtraWeap = "";			break;
	case 1:	Ammo = "Shell";			WeakWeap = "Shotgun";			HardWeap = "SuperShotgun";		ExtraWeap = "";			break;
	case 2:	Ammo = "RocketAmmo";	WeakWeap = "RocketLauncher";	HardWeap = "";					ExtraWeap = "";			break;
	case 3:	Ammo = "Cell";			WeakWeap = "PlasmaRifle";		HardWeap = "BFG9000";			ExtraWeap = "Chainsaw";	break;
	}


Switch(What)
	{
	case 0:	Result = Ammo;			break;
	case 1:	Result = WeakWeap;		break;
	case 2:	Result = HardWeap;		break;
	case 3:	Result = ExtraWeap;		break;
	}

return Result;

}

function int AlphaWepGiveAmmo (int What)
{
int Result;


Switch(What)
	{
	case 0:	Result = RNG(20,25);	break;
	case 1:	Result = RNG(3,4);		break;
	case 2:	Result = RNG(1,2);		break;
	case 3:	Result = RNG(10,13);	break;
	}

return Result;

}

Script "ALPHA_GiveAmmo"	(void)
{
int counter, i;
SetActivator(0, AAPTR_NULL);

while(!GetSectorLightLevel(TIDRAM_MapReset))
		{
		if(GAMESTATE == gs_ACTIVE)
			{
				counter = 0;
				While(counter <= GetPlayerTopIndex())
					{
					if (ClassifyActor(PLAYER_TID + counter) & ACTOR_ALIVE)
						{
						SetActivator(PLAYER_TID + counter);
						i = 0;
						while(i < 4)
							{

										if	(
											(CheckWeapon(AlphaWeapon (i, 1)))	|
											(CheckWeapon(AlphaWeapon (i, 2)))	|
											(CheckWeapon(AlphaWeapon (i, 3)))
											)
											GiveActorInventory(PLAYER_TID + counter, 	AlphaWeapon (i, 0),   AlphaWepGiveAmmo(i) )	;


								else	if	(
											(CheckActorInventory(PLAYER_TID + counter, AlphaWeapon (i, 1)))	|
											(CheckActorInventory(PLAYER_TID + counter, AlphaWeapon (i, 2)))	|
											(CheckActorInventory(PLAYER_TID + counter, AlphaWeapon (i, 3)))
											)
											GiveActorInventory(PLAYER_TID + counter, 	AlphaWeapon (i, 0),   AlphaWepGiveAmmo(i)/2 )	;

									//{

									//break;
									//}
							i++;
							}

						}


					counter++;

					}
			SetActivator(0, AAPTR_NULL);
			}
		delay(SEC*3);
		}
}



function str BadFloors (int Index)
{
str Result = "";
Switch(index)
	{
	case 0:	Result = TextureIs(FlatFAILtx);	break;
	case 1:	Result = TextureIs(FlatCOALtx);	break;
	case 2:	Result = TextureIs(FlatWORMtx);	break;
	case 3:	Result = TextureIs(FlatBOMBtx);	break;
	}

return Result;
}



function void IsPlayerOnDeathFloor (int Player, int Tag)
{
int counter;

while(counter <= 3)
	{
	if (CheckActorFloorTexture(Tag, BadFloors(counter)))
				{
					if (GetActorZ(PLAYER_TID + Player) <= GetSectorFloorZ(Tag, 0, 0))		ClientCall("PlayerDeathFloor",	GetSectorLightLevel(TIDRAM_PasswordA), Player, None);
					else 	break;
				break;
				}
	counter++;
	}
}



Script "PlayerDeathFloor" (int Password, int counter, int arg2) NET
{
if (!PasswordMatch(Password))	Terminate;

int HP = InstantDeath;
int i;
					if (CheckActorFloorTexture(PLAYER_TID + counter, "F_SKY1"))
						{
						HP = GetActorProperty(PLAYER_TID + counter, APROP_Health);
						ClientScript (counter, "PlayerScreenFade", CR_WHITE, 0.5, 1.0);
						SpawnForced("MapSpot", GetActorX(PLAYER_TID + counter) + int2fix(SkyfallOffset), GetActorY(PLAYER_TID + counter), GetActorZ(PLAYER_TID + counter) - int2fix(PlayerHeight), ACTORTID_Skyfall + counter, GetActorAngle(PLAYER_TID + counter)>>16);
						Thing_Move(PLAYER_TID + counter, ACTORTID_Skyfall + counter, TRUE);
						Thing_Remove(ACTORTID_Skyfall + counter);
						//if (GetSectorLightLevel(TIDRAM_Mood) == mood_SPACE)
						SetActorProperty(PLAYER_TID + counter, APROP_Alpha, 0.0);
						i = TRUE;
						}

			else	if (CheckActorFloorTexture(PLAYER_TID + counter, "FLTBLACK"))
						{

						HP = GetActorProperty(PLAYER_TID + counter, APROP_Health);
						ClientScript (counter, "PlayerScreenFade", CR_BLACK, 0.25, 1.0);
						Thing_Move(PLAYER_TID + counter, ACTORTID_SkyfallInner, TRUE);
						//SetActorAngle(PLAYER_TID + counter, RNG(0,255) << 8);
						SetActorProperty(PLAYER_TID + counter, APROP_Alpha, 0.0);
						i = TRUE;
						}

			else	if (CheckActorFloorTexture(PLAYER_TID + counter, StrParam(i:GetSectorLightLevel(TIDRAM_Mood), s:"FLFA", i:GetSectorLightLevel(FlatFAILtx))))
						{
						Thing_Damage(PLAYER_TID + counter, HP, MOD_SLIME);
						ClientScript (counter, "PlayerScreenFade", CR_BLACK, 0.25, 1.0);
						SetActorProperty(PLAYER_TID + counter, APROP_Alpha, 0);
						Thing_Move(PLAYER_TID + counter, ACTORTID_DeathSubstance, TRUE);
						i = FALSE;
						}


//at this point Player teleported if there was pit



			Thing_Damage(PLAYER_TID + counter, HP, MOD_UNKNOWN);


if (!i)	Terminate;
if (CheckActorFloorTexture(PLAYER_TID + counter, "F_SKY1"))	Terminate;


i = SEC*5;
while (GetActorZ(PLAYER_TID + counter) > GetActorFloorZ(PLAYER_TID + counter))
	{
	if (!i)	Terminate;
	i--;
	delay(1);
	}


ThingSound(PLAYER_TID + counter, "SFXSPLAT", StandartVolume);
DeathSplatter(counter);


//quake
i = 5;
while(i)
	{
	Radius_Quake(i, 5, None,  4, PLAYER_TID + counter);
	delay(5);
	i--;
	}
}




function str GetGore (void)
{
str Result ="";

Switch(RNG(0,5))
	{
	case 0:	Result = "Gibs";			break;
	case 1:	Result = "SmallBloodPool";	break;
	case 2:	Result = "ColonGibs";		break;
	case 3:	Result = "BrainStem";		break;
	case 3:
	case 4:
	case 5:
	case 6:	Result = "Blood";			break;
	}
return Result;
}



function void DeathSplatter (int counter)
{
//GORE
int i;
int c;
int PitThrustRad = 64;
while(i < 255)
	{
	c = RNG(false, true);
	SpawnForced(GetGore(), GetActorX(PLAYER_TID + counter) + int2fix(RNG(-PitThrustRad, +PitThrustRad)), GetActorY(PLAYER_TID + counter) + int2fix(RNG(-PitThrustRad, +PitThrustRad)), GetActorZ(PLAYER_TID + counter),   ACTORTID_Temp, i);
	//SpawnSpotForced(GetGore(), PLAYER_TID + counter, 	ACTORTID_Temp, 	i);
	ThrustThing(i, RNG(1, 4), FALSE, ACTORTID_Temp);
	ThrustThingZ(ACTORTID_Temp,  RNG(1, 2), 0, TRUE);
	i += RNG(3,8);
	}

}



Script SCRIPT_Changelog (void)			{
											Client_NamedExecute(PlayerNumber(), "ChangeLog");
											ActivatorSound("menu/activate", StandartVolume);
											SetLineTexture(LINETAG_ChangelogTX	, SIDE_FRONT, TEXTURE_BOTTOM, "CLOGBUT2");
											delay(10);
											SetLineTexture(LINETAG_ChangelogTX	, SIDE_FRONT, TEXTURE_BOTTOM, "CLOGBUTT");

										}





Script "ZDA_SendMemoMSG" (int Password, int Char, int SYNC) NET
{
if (!PasswordMatch(Password))	Terminate;

if (!SYNC)
	{
	int i;
	for (i = 0; i < MaxMemoOwnerMSGChars;  i++)		MemoOwnerMSG[i] = None;
	}


MemoOwnerMSG[SYNC] = Char;
Light_ChangeToValue(TIDRAM_MemoOwnerSYNC, SYNC + 1);
}





Script "ZDA_DoneMemoMSG" (int Password, int SYNC) NET
{
if (!PasswordMatch(Password))	Terminate;
if (!MemoOwnerMSG[0])			Terminate;

//MemoOwner[MemoOwnerType] = Type;
SetMemoOwnerTexture ();
}



Script "ZDA_BoughtMemo" (int Password) NET
{
if (!PasswordMatch(Password))	Terminate;

Light_ChangeToValue(TIDRAM_Ability + PlayerNumber(), None);

int a;
//Reset Last Winner
for (a = 0; a < MaxPortNameCharsZDA;	a++)		MemoOwner[a]		= 0;
for (a = 0; a < MaxMemoOwnerMSGChars;  a++)			MemoOwnerMSG[a]		= 0;


//fill the new one
str StringA = StrParam(n:PlayerNumber() + 1);
for (a = 0; a < StrLen(StringA);  a++)
	{
	Light_ChangeToValue(TIDRAM_Temp, GetChar(StringA, a));
	MemoOwner[a] = GetSectorLightLevel(TIDRAM_Temp);
	}
MemoOwner[MemoOwnerType] = AsAdvertOwner;
Light_ChangeToValue(TIDRAM_MemoOwnerType, MemoOwner[MemoOwnerType]);
//Light_ChangeToValue(TIDRAM_MemoOwnerSYNC, SYNC + 1);
}


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

function void ClearMemoOwnerTexture (void)
{
int i;
for (i = 0; i < MemoOwnerSphereLines;  i++)
		{
		Line_SetTextureOffset(LINETAG_MemoOwnerString + i, 0, NO_CHANGE, SIDE_FRONT,	TEXFLAG_MIDDLE);
		Line_SetTextureOffset(LINETAG_MemoOwnerString + i, 0, NO_CHANGE, SIDE_BACK,	TEXFLAG_MIDDLE);
		}
}



//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////



function void SetMemoOwnerTexture (void)
{
int counter, i;
ClearMemoOwnerTexture();

str String = "";

Switch(MemoOwner[MemoOwnerType])
	{
	case AsLastWinner:		String = StrParam(s:" left a message as a winner of the previous stage:       ", 	c:'"');		break;
	case AsAdvertOwner:		String = StrParam(s:" bought an advertisement line to place this message:       ", 	c:'"');		break;
	}


while (i < MaxPortNameCharsZDA)		//filling with winner's Name
	{
	if (MemoOwner[i])
		{
		Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, int2fix(MemoOwner[i]*8), NO_CHANGE, SIDE_FRONT,	TEXFLAG_MIDDLE);
		Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, int2fix('#'*8),	NO_CHANGE, SIDE_BACK,	TEXFLAG_MIDDLE);
		i++;
		counter++;
		}
	else break;
	}

// now , continue with a sentence

i = 0;

while(i < StrLen(String))
	{
	Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, 	int2fix(GetChar(String, i)*8),	NO_CHANGE, SIDE_FRONT, TEXFLAG_MIDDLE);
	i++;
	counter++;
	}



i = 0;
while (i < MaxMemoOwnerMSGChars)		//filling with winner's message
	{
	if (MemoOwnerMSG[i])
		{
		Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, 	int2fix(MemoOwnerMSG[i]*8), 	NO_CHANGE, SIDE_FRONT,	TEXFLAG_MIDDLE);
		i++;
		counter++;
		}
	else break;
	}

Light_ChangeToValue(TIDRAM_MemoMSGexist, i);
Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, 	int2fix('"'*8), NO_CHANGE, SIDE_FRONT,	TEXFLAG_MIDDLE);

//now backwards

i = 0;
while (i < MaxPortNameCharsZDA)		//filling with winner's Name
	{
	if (MemoOwner[i])
		{
		Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, int2fix(MemoOwner[i]*8), NO_CHANGE, SIDE_BACK,	TEXFLAG_MIDDLE);
		i++;
		counter--;
		}
	else break;
	}


// now , continue with a sentence


i = 0;

while(i < StrLen(String))
	{
	Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, 	int2fix(GetChar(String, i)*8),	NO_CHANGE, SIDE_BACK, TEXFLAG_MIDDLE);
	i++;
	counter--;
	}

i = 0;
while (i < MaxMemoOwnerMSGChars)		//filling with winner's message
	{
	if (MemoOwnerMSG[i])
		{
		Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, 	int2fix(MemoOwnerMSG[i]*8), 	NO_CHANGE, SIDE_BACK,	TEXFLAG_MIDDLE);
		i++;
		counter--;
		}
	else break;
	}

Line_SetTextureOffset(LINETAG_MemoOwnerString + counter, 	int2fix('"'*8), NO_CHANGE, SIDE_BACK,	TEXFLAG_MIDDLE);







Light_ChangeToValue(TIDRAM_MemoOwnerSYNC, i);
int r, g, b = 128;
Switch(RNG(1,3))
	{
	case 1:	r = RNG(204, 256);	break;
	case 2:	g = RNG(204, 256);	break;
	case 3:	b = RNG(204, 256);	break;
	}

Sector_SetColor(SECTORTAG_MemoSector, r, g, b, 0);
}





function void ExitMarkerPLUSDeathFloor (void)
{
int A, B, C, D, E, counter;

	if (PlayerStatus(ClientPlayerNumber()) == ps_PLAYGROUND)
			{


			//Check outside Playground

			if 	(		//if player is outside the boundaries
					(
					((GetActorX(PLAYER_TID + ClientPlayerNumber()) < 	GetActorX(ACTORTID_NorthWestCorner))	|
					 (GetActorY(PLAYER_TID + ClientPlayerNumber()) > 	GetActorY(ACTORTID_NorthWestCorner)))


								|

					((GetActorX(PLAYER_TID + ClientPlayerNumber()) > 	GetActorX(ACTORTID_SouthEastCorner))	|
					 (GetActorY(PLAYER_TID + ClientPlayerNumber()) < 	GetActorY(ACTORTID_SouthEastCorner)))
					)

																	&&
						// and is on pit height
					(GetActorZ(PLAYER_TID + ClientPlayerNumber()) <= 	GetSectorFloorZ(SECTORTAG_Pit, 0, 0))

				)		ClientCall("PlayerDeathFloor",	GetSectorLightLevel(TIDRAM_PasswordA), ClientPlayerNumber(), None);//IsPlayerOnDeathFloor(ClientPlayerNumber(), SECTORTAG_Pit);



				else
				{
				// Check inside Playground
				counter	= 0;
				A 		= 0;
				while(counter < PlaygroundBlocks)
					{
					counter++;


										B = GetActorX(counter*100 + BlockCenter);
										C = GetActorY(counter*100 + BlockCenter);
										//BlockZ = GetActorY(BlockCounter*100 + BlockCenter);

										if 	(
											(GetActorX(PLAYER_TID + ClientPlayerNumber()) > 	B - int2fix(BlockDiameter/2) )	&&
											(GetActorX(PLAYER_TID + ClientPlayerNumber()) < 	B + int2fix(BlockDiameter/2) )	&&
											(GetActorY(PLAYER_TID + ClientPlayerNumber()) > 	C - int2fix(BlockDiameter/2) )	&&
											(GetActorY(PLAYER_TID + ClientPlayerNumber()) < 	C + int2fix(BlockDiameter/2) )
											)

											while(A < MaxMiniBlocks)
												{
												A++;
														B = GetActorX(counter*100 + A);
														C = GetActorY(counter*100 + A);



													if 	(
														(GetActorX(PLAYER_TID + ClientPlayerNumber()) > 	B - int2fix(PlayerRadius*2) )	&&
														(GetActorX(PLAYER_TID + ClientPlayerNumber()) < 	B + int2fix(PlayerRadius*2) )	&&
														(GetActorY(PLAYER_TID + ClientPlayerNumber()) > 	C - int2fix(PlayerRadius*2) )	&&
														(GetActorY(PLAYER_TID + ClientPlayerNumber()) < 	C + int2fix(PlayerRadius*2) )
														)

															{
															IsPlayerOnDeathFloor(ClientPlayerNumber(), counter*100 + A);

															break;
															}




												}


					}

				}


	if (GetSectorLightLevel(TIDRAM_ExitMarkerB) > 0)
			{





			A = GetActorX(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB)) - GetActorX(PLAYER_TID + ClientPlayerNumber());
			B = GetActorY(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB)) - GetActorY(PLAYER_TID + ClientPlayerNumber());
			C = GetActorZ(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB)) + (GetActorProperty(GetSectorLightLevel(TIDRAM_ExitMarkerA)*100 + GetSectorLightLevel(TIDRAM_ExitMarkerB), APROP_HEIGHT) >> 1) - (GetActorZ(PLAYER_TID + ClientPlayerNumber()) + GetActorViewHeight(PLAYER_TID + ClientPlayerNumber()));

			D = FixedMul(A, cos(GetActorAngle(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(B, sin(GetActorAngle(PLAYER_TID + ClientPlayerNumber())));
			E = -FixedMul(A, sin(GetActorAngle(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(B, cos(GetActorAngle(PLAYER_TID + ClientPlayerNumber())));

			A = FixedMul(D, cos(GetActorPitch(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(C, sin(GetActorPitch(PLAYER_TID + ClientPlayerNumber())));

				if(A > 0)
				{
					//C = -FixedMul(D, sin(GetActorPitch(PLAYER_TID + ClientPlayerNumber()))) + FixedMul(C, cos(GetActorPitch(PLAYER_TID + ClientPlayerNumber())));

					SetFont("ERICON");
					SetHudSize((HUDX_BIG >> 1) << 1, (HUDY_BIG >> 1) << 1, true);

					HudMessageBold(c:ICON_Waypoint; HUDMSG_PLAIN, HUDid_Waypoint, RandomMarkerColor(), (((HUDX_BIG >> 1) << 16) - ((HUDX_BIG >> 1) * FixedDiv(E, A))) & 0xFFFF0000, int2fix(16), ClientMsgDelay);
				}

			}

		}
}





Script "PukeMoney" (int PlayaNum, int Amount)
{
GiveActorInventory(PLAYER_TID + PlayaNum, Money, Amount);
}







function int Crypt (int How, int Char)
{
int Result = Char;


			if (How == Encrypt)
				{
					Switch(Char)
						{
						CASE 32: 	Result	=	97;		break;
						CASE 33: 	Result	=	57;		break;
						CASE 34:	Result	=	92;		break;
						CASE 35:	Result	=	75;		break;
						CASE 36:	Result	=	108;	break;
						CASE 37:	Result	=	76;		break;
						CASE 38:	Result	=	33;		break;
						CASE 39:	Result	=	95;		break;
						CASE 40:	Result	=	90;		break;
						CASE 41:	Result	=	85;		break;
						CASE 42:	Result	=	54;		break;
						CASE 43:	Result	=	126;	break;
						CASE 44:	Result	=	40;		break;
						CASE 45:	Result	=	77;		break;
						CASE 46:	Result	=	111;	break;
						CASE 47:	Result	=	91;		break;
						CASE 48:	Result	=	113;	break;
						CASE 49:	Result	=	66;		break;
						CASE 50:	Result	=	63;		break;
						CASE 51:	Result	=	78;		break;
						CASE 52:	Result	=	35;		break;
						CASE 53:	Result	=	61;		break;
						CASE 54:	Result	=	37;		break;
						CASE 55:	Result	=	32;		break;
						CASE 56:	Result	=	47;		break;
						CASE 57:	Result	=	69;		break;
						CASE 58:	Result	=	43;		break;
						CASE 59:	Result	=	98;		break;
						CASE 60:	Result	=	51;		break;
						CASE 61:	Result	=	101;	break;
						CASE 62:	Result	=	86;		break;
						CASE 63:	Result	=	50;		break;
						CASE 64:	Result	=	124;	break;
						CASE 65:	Result	=	94;		break;
						CASE 66:	Result	=	44;		break;
						CASE 67:	Result	=	68;		break;
						CASE 68:	Result	=	116;	break;
						CASE 69:	Result	=	45;		break;
						CASE 70:	Result	=	106;	break;
						CASE 71:	Result	=	104;	break;
						CASE 72:	Result	=	109;	break;
						CASE 73:	Result	=	100;	break;
						CASE 74:	Result	=	81;		break;
						CASE 75:	Result	=	119;	break;
						CASE 76:	Result	=	93;		break;
						CASE 77:	Result	=	67;		break;
						CASE 78:	Result	=	118;	break;
						CASE 79:	Result	=	55;		break;
						CASE 80:	Result	=	122;	break;
						CASE 81:	Result	=	53;		break;
						CASE 82:	Result	=	110;	break;
						CASE 83:	Result	=	117;	break;
						CASE 84:	Result	=	46;		break;
						CASE 85:	Result	=	38;		break;
						CASE 86:	Result	=	89;		break;
						CASE 87:	Result	=	84;		break;
						CASE 88:	Result	=	121;	break;
						CASE 89:	Result	=	102;	break;
						CASE 90:	Result	=	52;		break;
						CASE 91:	Result	=	60;		break;
						CASE 92:	Result	=	34;		break;
						CASE 93:	Result	=	82;		break;
						CASE 94:	Result	=	83;		break;
						CASE 95:	Result	=	112;	break;
						CASE 96:	Result	=	48;		break;
						CASE 97:	Result	=	87;		break;
						CASE 98:	Result	=	79;		break;
						CASE 99:	Result	=	71;		break;
						CASE 100:	Result	=	39;		break;
						CASE 101:	Result	=	56;		break;
						CASE 102:	Result	=	88;		break;
						CASE 103:	Result	=	65;		break;
						CASE 104:	Result	=	99;		break;
						CASE 105:	Result	=	120;	break;
						CASE 106:	Result	=	114;	break;
						CASE 107:	Result	=	115;	break;
						CASE 108:	Result	=	96;		break;
						CASE 109:	Result	=	58;		break;
						CASE 110:	Result	=	105;	break;
						CASE 111:	Result	=	49;		break;
						CASE 112:	Result	=	125;	break;
						CASE 113:	Result	=	72;		break;
						CASE 114:	Result	=	64;		break;
						CASE 115:	Result	=	103;	break;
						CASE 116:	Result	=	36;		break;
						CASE 117:	Result	=	42;		break;
						CASE 118:	Result	=	123;	break;
						CASE 119:	Result	=	70;		break;
						CASE 120:	Result	=	41;		break;
						CASE 121:	Result	=	62;		break;
						CASE 122:	Result	=	74;		break;
						CASE 123:	Result	=	59;		break;
						CASE 124:	Result	=	107;	break;
						CASE 125:	Result	=	80;		break;
						CASE 126:	Result	=	73;		break;
						}
				}


			else if (How == Decrypt)
				{
					Switch(Char)
						{
						CASE 97: 	Result	=	32;		break;
						CASE 57: 	Result	=	33;		break;
						CASE 92:	Result	=	34;		break;
						CASE 75:	Result	=	35;		break;
						CASE 108:	Result	=	36;		break;
						CASE 76:	Result	=	37;		break;
						CASE 33:	Result	=	38;		break;
						CASE 95:	Result	=	39;		break;
						CASE 90:	Result	=	40;		break;
						CASE 85:	Result	=	41;		break;
						CASE 54:	Result	=	42;		break;
						CASE 126:	Result	=	43;		break;
						CASE 40:	Result	=	44;		break;
						CASE 77:	Result	=	45;		break;
						CASE 111:	Result	=	46;		break;
						CASE 91:	Result	=	47;		break;
						CASE 113:	Result	=	48;		break;
						CASE 66:	Result	=	49;		break;
						CASE 63:	Result	=	50;		break;
						CASE 78:	Result	=	51;		break;
						CASE 35:	Result	=	52;		break;
						CASE 61:	Result	=	53;		break;
						CASE 37:	Result	=	54;		break;
						CASE 32:	Result	=	55;		break;
						CASE 47:	Result	=	56;		break;
						CASE 69:	Result	=	57;		break;
						CASE 43:	Result	=	58;		break;
						CASE 98:	Result	=	59;		break;
						CASE 51:	Result	=	60;		break;
						CASE 101:	Result	=	61;		break;
						CASE 86:	Result	=	62;		break;
						CASE 50:	Result	=	63;		break;
						CASE 124:	Result	=	64;		break;
						CASE 94:	Result	=	65;		break;
						CASE 44:	Result	=	66;		break;
						CASE 68:	Result	=	67;		break;
						CASE 116:	Result	=	68;		break;
						CASE 45:	Result	=	69;		break;
						CASE 106:	Result	=	70;		break;
						CASE 104:	Result	=	71;		break;
						CASE 109:	Result	=	72;		break;
						CASE 100:	Result	=	73;		break;
						CASE 81:	Result	=	74;		break;
						CASE 119:	Result	=	75;		break;
						CASE 93:	Result	=	76;		break;
						CASE 67:	Result	=	77;		break;
						CASE 118:	Result	=	78;		break;
						CASE 55:	Result	=	79;		break;
						CASE 122:	Result	=	80;		break;
						CASE 53:	Result	=	81;		break;
						CASE 110:	Result	=	82;		break;
						CASE 117:	Result	=	83;		break;
						CASE 46:	Result	=	84;		break;
						CASE 38:	Result	=	85;		break;
						CASE 89:	Result	=	86;		break;
						CASE 84:	Result	=	87;		break;
						CASE 121:	Result	=	88;		break;
						CASE 102:	Result	=	89;		break;
						CASE 52:	Result	=	90;		break;
						CASE 60:	Result	=	91;		break;
						CASE 34:	Result	=	92;		break;
						CASE 82:	Result	=	93;		break;
						CASE 83:	Result	=	94;		break;
						CASE 112:	Result	=	95;		break;
						CASE 48:	Result	=	96;		break;
						CASE 87:	Result	=	97;		break;
						CASE 79:	Result	=	98;		break;
						CASE 71:	Result	=	99;		break;
						CASE 39:	Result	=	100;	break;
						CASE 56:	Result	=	101;	break;
						CASE 88:	Result	=	102;	break;
						CASE 65:	Result	=	103;	break;
						CASE 99:	Result	=	104;	break;
						CASE 120:	Result	=	105;	break;
						CASE 114:	Result	=	106;	break;
						CASE 115:	Result	=	107;	break;
						CASE 96:	Result	=	108;	break;
						CASE 58:	Result	=	109;	break;
						CASE 105:	Result	=	110;	break;
						CASE 49:	Result	=	111;	break;
						CASE 125:	Result	=	112;	break;
						CASE 72:	Result	=	113;	break;
						CASE 64:	Result	=	114;	break;
						CASE 103:	Result	=	115;	break;
						CASE 36:	Result	=	116;	break;
						CASE 42:	Result	=	117;	break;
						CASE 123:	Result	=	118;	break;
						CASE 70:	Result	=	119;	break;
						CASE 41:	Result	=	120;	break;
						CASE 62:	Result	=	121;	break;
						CASE 74:	Result	=	122;	break;
						CASE 59:	Result	=	123;	break;
						CASE 107:	Result	=	124;	break;
						CASE 80:	Result	=	125;	break;
						CASE 73:	Result	=	126;	break;
						}
				}




Result = RemoveBadCharEnc(Result);  


Return Result;
}
